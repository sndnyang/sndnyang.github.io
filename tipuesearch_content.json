{"pages":[{"text":"2D 转换 translate rotate scale skew matrix 3D 转换 rotateX rotateY rotateZ","tags":"web","loc":"http://sndnyang.github.io/2d-3d-transform.html","title":"2D,3D转换"},{"text":"区别 乐器(instruments): 电子(electronic) vs 声学(acoustic) 歌词(lyrics): 有歌词 vs 纯器乐(usually purely instrumental) 节奏(beat): 强节奏(strong beat) vs 弱节奏(subdued) 篇幅(length): 短而重复(often short and repetitious) vs 长而延续(long and continual) 演稿(notation): 表现时不用 vs 一般都有 声波 sound wave 高 8 度 -- 声波频率翻倍 听觉形成过程 1. 声音到达耳朵 2. 耳道处 放大声音 3. 耳蜗 Cochlea － 神经 ( Nerve ) － 脑干 ( brain stem ) 4. 到达相应皮质区域 ( cortex ) 识别处理 情感 limbic 系统， amygdala 节奏、 旋律","tags":"music","loc":"http://sndnyang.github.io/classical-music-week1.html","title":"古典音乐概论 第一周"},{"text":"Java 比较器 Comparator 接口 Comparable 内置方法 int compareTo(Item other); 接口 Comparator 内置方法 int compare(Item x, Item y); 使用 import java . util . Comparator ; 方法有二： 实现Comparable 按类型的自然次序进行排序——或者就是支持一种排序（自定义） public class Point< Key > implements Comparable< Key > { public int compareTo(Point that) {} } 变量使用 Comparator 使用不同的 Comparator 变量， 实现不同的排序方式。 public class MinPQ { private Comparator comparator; // optional comparator; public MinPQ(int initCapacity, Comparator comparator) { this.comparator = comparator; pq = (Key[]) new Object[initCapacity + 1]; N = 0; } } Comparator 实现 为数据类 定义一个（多半是内嵌）类型来实现Comparator接口, 使用 static。 实现 compare() 方法 public class Student { public static final Comparator ORDER = new OrderName(); private static class OrderName implements Comparator { public int compare(Student a, Student b) {} } }","tags":"Java","loc":"http://sndnyang.github.io/Java-Comparator.html","title":"Java比较器Comparator"},{"text":"Java 泛型机制及迭代器 泛型 Generic 基本框架 public class Stack < Item > { private Item x ; public void push ( Item item ) { Node < Item > oldfirst = first ; first = new Node < Item > (); first.item = item ; first.next = oldfirst ; N ++ ; } } 上面代码中的Item 可以是任意内置、自定义类型, 所以达到了极佳的代码复用效果。 使用 例： Stack < String > x = new Stack < String > (); Stack < YourClass > y = new Stack < YourClass > (); Stack < Integer > i = new Stack < Integer > (); 注意事项 Java 不支持 泛型的创建， 如上例，则有： 不支持： public ArrayStack(int capacity) { Item[] s = new Item[capacity]; } 支持: public ArrayStack(int capacity) { Item[] s = (Item[]) new Object[capacity]; } 基本类型的Item int\\float等基本的数据类型不能直接用作 Item, 必须使用如下转换： byte -> Byte short -> Short int -> Integer long -> Long float -> Float double -> Double char -> Character 迭代器 Iterator 迭代器接口 Iterable 内置方法iterator()， 返回一个新建的 Iterator。 如： public interface Iterable { Iterator Iterator(); } Iterator 有 hasNext() 和 next() 两个方法要实现。 public interface Iterator { boolean hasNext(); Item next(); void remove(); //可选实现 } 实现 导入 import java.util.Iterator; 泛型的类， 实现Iterable接口 implements Iterable< Item > 实现Iterable的iterator()方法， 返回任意定义迭代器类型。 定义迭代器类型 implements Iterator< Item > 实现 hasNext()、 next()、 remove() 示例: public class Stack < Item > implements Iterable < Item > { public Iterator < Item > iterator () { return new ListIterator < Item > ( first ); } private class ListIterator < Item > implements Iterator < Item > { private Node < Item > current ; public ListIterator ( Node < Item > first ) { current = first ; } public boolean hasNext () { return current != null ; } public void remove () { throw new UnsupportedOperationException (); } public Item next () { if ( ! hasNext ()) throw new NoSuchElementException (); Item item = current.item ; current = current.next ; return item ; } } } 调用方法 foreach 迭代 for (String s : stack) System.out.println(s); 如果是 int\\double 等基本类型， 请使用之前的转换关系 循环遍历 Iterator i = stack.iterator(); while (i.hasNext()) { String s = i.next(); }","tags":"Java","loc":"http://sndnyang.github.io/Java-Generic-Iterator.html","title":"Java 泛型机制及迭代器"},{"text":"儒家真牛 名声响 地位高 辩论厉害 无责任 待遇好 自由度高 待续 名声响 上流社会大名鼎鼎。 地位高 个个是帝师、个个正能量。 辩论厉害 他总能把你的智商降到零下， 再用他无上的智商打败你。 无责任 因为只用动嘴， 过失都不算他们的 待遇好 除了朱元璋这些草根造反派狠点， 其他时候都跟祖宗一样供着 自由度高 领导惹我不高兴、同事惹我不高兴， 说走人就走人","tags":"essay","loc":"http://sndnyang.github.io/wu-liao-xin-de-zhi-ru-jia-zhen-niu.html","title":"无聊心得之儒家真牛"},{"text":"编程容易，笔算不易，且写且珍惜 有点像个傻子一样在发广告 csdn 博客在 sndnyangd github 博客在 sndnyang github 在 sndnyang 开篇语 第二周的编程练习非常简单——前两轮开课时不知道是不是会难很多， 总之这次把代码框架都搭好了， 顺利的话， 10分钟就OK了。 不顺利的地方在哪儿——我使用的是神算on版本， 里面有个小bug，看不懂输出 载。社文件里找了半天代码结构没明白， 最后打算从main开始吧， 一看， 代码里面是这样写的 def main ( filepath ) : return Start ( ' testRE . in ' ) if __name__ == ' __main__ ' : main ( sys . argv [ 1 ]) 好吧，难怪我的文件名参数没用——剩下的在看懂他输出是什么内容后很快就解决了。 无耻的分界线 你以为我就想说这个？ NO！ 最起码笔算不易还没说呢！！！ 本周第一个视频讲的是正则表达式基础，从定义到正则表达式转换成NFA CUT！！！ 概念没兴趣， RE转NFA 学过的内容，看到那张图就OK了， 主要是确实so easy. CONTINUE！！！ 然后就到DFA转RE了， 说实话吧， 过程不是很复杂，对于我这种人来说，就一个公式（虽然后面不停地修正自己对过程理解上的缺陷）， 套公式，谁不会呢？！ 转折 我还真不会了， 小测第一题就是DFA转RE, 4个状态之间的转换， 套用公式简单 $$R&#94;k_{ij} =R&#94;{k-1} {ij} + R&#94;{k-1} (R&#94;{k-1} {kk})* R&#94;{k-1} $$ 问题有几个： 1. 状态的序号， 给状态按什么顺序分配序号最好呢，在这里可能没影响，不过我换了好几次。 2. 手算真是很绕， 整个下午，多半时间都花在推导上了，连午觉都想想后起来先推导了几次，实在绕晕了才午休。 在纸上推导被绕的过程中， 顺手写代码，模拟一下这个公式， 就是个递归的公式，用n n n 的数组来记录状态嘛。 初始版的数组下标就不对，不经过额外状态的路径（直接连结或无连结）被我忽略了， 另外也没有组织好正则表达式的表达形式，括号没用好。 输出的结果自然是无效的。 最后第二周的第一个小测是我经过7次连蒙带猜后，总算拿到5分。 第一题纸算太难，第二题花费很长时间来理解题意，后3题时不时拖后腿，几次前两题答对（后几次已经不是猜了），后三题不小心出错。 万万没想到（其实不至于） 到晚上， 做其他事耐心缺失之下， 又打开了代码， 决定调整好数组下标， 再组织好括号的输出。很快修改完毕， 随意运行之后，输出结果居然就这么达到预期 因 honor code， 只摘取与题目要求无关的输出部分 k i j regular expression 4 1 1 1 ( 11 + 0 ( 01 + 10 )) * ( 1 + 00 ) 4 1 2 1 ( 11 + 0 ( 01 + 10 )) * 01 4 1 3 1 ( 11 + 0 ( 01 + 10 )) * 0 4 1 4 1 + 1 ( 11 + 0 ( 01 + 10 )) * ( 11 + 0 ( 01 + 10 )) 4 2 1 0 ( 11 + 0 ( 01 + 10 )) * ( 1 + 00 ) 4 2 2 0 ( 11 + 0 ( 01 + 10 )) * 01 4 2 3 0 ( 11 + 0 ( 01 + 10 )) * 0 4 2 4 0 + 0 ( 11 + 0 ( 01 + 10 )) * ( 11 + 0 ( 01 + 10 )) 4 3 1 0 + ( 01 + 10 )( 11 + 0 ( 01 + 10 )) * ( 1 + 00 ) 4 3 2 1 + ( 01 + 10 )( 11 + 0 ( 01 + 10 )) * 01 4 3 3 ( 01 + 10 )( 11 + 0 ( 01 + 10 )) * 0 虽然没有经过完全化简——也不确认全部正确，但形式上是没问题了。 测验第一题对应的结果也是正确的。 根据输出的结果， 回顾题目， 我去， 选项怎么这么明显啊， 我之前的推导都在为了什么？ 结论 个人经验， 手工推导DFA到RE 非常容易错乱，而老师题目中的几个选项稍认真分析下，可以直接判断正误， 我之前是有多不认真呢。 总 中秋节学习是好事， 可这样不认真导致时间浪费，真是不应该。","tags":"mooc","loc":"http://sndnyang.github.io/automata-hw1.html","title":"正则表达式作业"},{"text":"简述 本课是生物信息学算法的第一部分， 内容主要是一些生物信息学里的算法。主要对应以下主题：基因组合，DNA和蛋白质序列比对，regulatory motifs（调控特征序列？），基因重组分析，蛋白质识别等 概述 人类基因序列点燃了生物学里的计算革命。于是，现代生物学和其他科学领域一样，产生了很多新的算法。计算机科学与生物学之间的新关联，影响了我们向计算机科学家教授应用算法的方式。 基因序列只是无数生物学问题中的一个，但与计算方法有着解不开的关系，需要计算方法来解决。 在本课程中，我们将覆盖一些现代生物学中的基本算法思想。 计算概念，如动态规划和图论，能帮助我们探索各种算法，以便应用于大量生物学课题中，课题可以从寻找regulatory motifs（调控特征序列？）到确定人类基因的\"脆弱\"区域。课程进行过程中，各种生物学算法将被应用于实际的基因数据上。 本课的每一章节会涵盖单个生物学问题，并细致地构建相应算法知识来解决这个挑战性问题。通过这种方式， 编码挑战及练习（很多会要求你将新学到的技能应用到实际的基因数据上）就能无缝整合到教学情景中。 授课大纲 本课将分成6章，包含以下核心问题，及括号中相应的用于解决问题的算法思想。 DNA序列重复的起始位置？（算法热身） 如何制定抗生素使用顺序？（暴力算法，穷举） 哪种DNA模式作为细胞锁？（贪心和随机算法） 如何进行基因序列的组合？（图算法） 如何比较生物学里的序列？（动态规划算法） 基因中是否存在脆弱区域？（组合算法） 本课的分数来自每周的若干编程挑战和每个章节末尾的测试。 生物信息学算法（部分2） 将包含以下问题： 哪个动物给人类带来了非典？ （进化树） 如何定位致病突变基因位置？ （组合模式匹配） 酵母怎么成为了啤酒制造商？ （聚类算法） 为什么还没有艾滋病的疫苗？ （隐马尔可夫模型） 霸王龙其实就是大号的小鸡？ （可计算蛋白质） 人口体现了何种的基因特征？ （主成分分析） 先修知识 一点编程基础，语言不限。以下是我们推荐的编程学习资源： Codecademy , 特别是Python Coursera课程 An Introduction to Interactive Programming with Python Rosalind 上的引导问题， 这是本课教师创建的生物信息学学习网址。 参考资料 略 授课形式 除了教学视频， 没说什么，略。 常见问题解答 课程有证书吗？ 是的， 完成本课的学生将有我们签名的完成声明。 课程有认证证书吗？ 是的， 想要认证证书，请选本课的 Signature Track 方式。","tags":"cs","loc":"http://sndnyang.github.io/bioinform-intro.html","title":"生物信息学算法课程概述"},{"text":"项目介绍 Your independent data analysis project will be done in two phases, each assessed by other students using peer assessment. You can also share your projects via the forums for additional feedback. The project counts as 15% of your grade for a certificate with distinction. 独立的数据分析项目需分两步完成。每一个阶段结束后都有学生互评。你可以在讨论区里分享你的项目，以便获得一些额外的反馈信息。在评\"优秀证书\"时，本项目会占到15%的分值。 Before the deadline, use the discussion forum to ask specific questions about the assignment. Please don't post your proposal. 在截止日期前，允许在讨论区里讨论一些特定的问题，但请不要把你的方案直接发出来。 After the deadline, we encourage you to post your project submission to the forum to show other students interesting data sets and questions, and to get additional feedback on project (in addition to the three peer assessments you will receive formally that will be used to calculate your score for the project). 截止日期之后，我们鼓励大家把自己的项目方案发到讨论区中，同学间互享数据集及问题，还能获得额外的反馈，这是三份互评之外最好的补充。 Both phases of the project are open so that you can see what is expected. As we learn how you work, we may make small modifications to the project requirements as the course progresses, so please check again before the due dates. You can resubmit your work up until the due date. 项目的两个阶段都已开放， 你现在可以看到阶段要求。 随着课程进行，我们可能会对项目要求进行微调， 所以请在提交日期前再确认一下。在提交日期前，你可以重复提交你的方案。 Follow these steps when working on your project: 请完成以下项目步骤： 安装最新版本的 R 和 RStudio 点击本页底部的\"Go To Assignment\"的两个作业链接，检查下项目的评分标准。这些信息可以帮助你弄清项目各阶段的准确需求。 选择一个数据集（下方列表中选一 或 自备） 提交 阶段1：项目提案， 时间在 9月22号之前 在10月6号之前，完成至少3份项目提案的评分 查看自己项目提案的评分情况 开始 阶段2：数据分析项目 前，下载RMarkdown 模板，请使用如下代码： download.file(url = \"http://bit.ly/dasi_project_template\", destfile = \"dasi_project_template.Rmd\") 如果上面的链接失败了，请使用这个URL： 模板URL 更多RMarkdown语法请看 http://rmarkdown.rstudio.com/. 提交 阶段2：数据分析项目，在10月20号之前。请注意，这最终产品只能是一个HTML文件，HTML里使用\"cerulean\"主题（上面模板会帮你弄好主题）。这个HTML文件必须是自完备的（包括了全部代码，文字描述，图形）。另外，请限制在 7页 以内。 在11月3号前，完成至少3份互评， 11月3号就可以收获你最后的成果反馈了。 If you haven't yet done so, download the latest version of R (http://cran.r-project.org/) and the latest version of RStudio (http://www.rstudio.com/products/rstudio/download/). Click the \"Go To Assignment\" links at the bottom for both the project proposal and the project to review the rubric to see how you will be graded. This information is going to be immensely useful in figuring out the exact expectations of both phases of the project. Choose a dataset (either from the ones listed below or another dataset of your choice) Submit Phase 1: Project Proposal before Monday September 22 (see below for details) Evaluate at least 3 proposals before Monday October 6 Review your evaluations Before starting Phase 2: Data Analysis Project download the RMarkdown template using the following code: download.file(url = \"http://bit.ly/dasi_project_template\", destfile = \"dasi_project_template.Rmd\") If the above shortened link doesn't work for you, try the following URL instead: http://d396qusza40orc.cloudfront.net/statistics/project/dasi_project_template.Rmd. More information on the RMarkdown syntax: http://rmarkdown.rstudio.com/. Watch a video on using RMarkdown to complete your project: https://class.coursera.org/statistics-002/lecture/179 Submit Phase 2: Data Analysis Project before Monday, October 20 (see below for details). Note that the final product must be an HTML file that uses the \"cerulean\" theme (this is indicated in the template you download above). This HTML file is fully self contained (includes all code, write-up, and figures). Also note that there is a seven page limit to your write up. You can check whether or not you meet this page limit by using a print preview. Evaluate at least 3 projects before Monday, November 3 by opening the HTML file that they submitted in a browser of your choice (Chrome or Firefox recommended) Receive your project evaluations on Monday, November 3 Phase 1: Project Proposal 阶段1： 项目提案 Identify a research question similar to questions we've talked about in this course. Choose a dataset, and one or two variables from that dataset, with which to answer this question using a hypothesis test or confidence intervals (the dataset used is entirely up to you, it can be one of the datasets listed below under \"Datasets for the Project\", or another one of your own choosing). You should pick two variables of interest, and you will be exploring the relationship between them. These variables should be either numerical and categorical, or both categorical (but they cannot be both numerical, see below for examples). All analysis must be completed in R. As part of the proposal stage you are also asked to complete a brief exploratory data analysis to determine if your data is appropriate for the project. You should submit a proposal with enough detail so that your peers can give you feedback before you start the full data analysis. You can begin working on the proposal immediately, following the link at the bottom of this page. Please save your work as you go along. When you're ready to submit your work for evaluation, remember to click the \"Submit\" button. If the deadline passes and you haven't clicked \"Submit\" yet, then your saved work will not be evaluated. Note: You can re-submit your work for evaluation as many times as you want before the submission deadline September 22. Only your last submission will be seen and evaluated by your classmates. After the submission deadline, you will have two weeks to provide feedback to others on their project proposals. Please assess at least 3 proposals before October 6th. This peer assessment will help you prepare for your project and provide you with experience with a variety of data sets and research questions. Phase 2: Data Analysis Project 阶段2： 数据分析项目 Once you receive feedback on your proposal, you will then continue onto the data analysis project. This peer assessment will count towards your grade for a certificate with distinction. You will answer the research question you developed in the proposal phase using methods you've learned in this class, and summarize your findings into a report. More details on what should be included are in the assessment itself, linked below. All analysis must be completed in R. This project is due on October 20th, and then you will have two weeks to provide feedback to other students on their projects. You will only receive full credit for your project if you evaluate 3 other projects before the November 3rd deadline. Datasets for the project 项目数据集 We are providing two datasets that you can use for your project. Both of them come from large-scale US surveys, and they have been modified slightly to make them easier to use as part of this course. Even though there are only two datasets, each contains many variables and hopefully you should be able to find some combination of variables that are of interest to you. （1）General Social Survey (GSS): 一份社会调查，收集了 (1) General Social Survey (GSS): A sociological survey used to collect data on demographic characteristics and attitudes of residents of the United States. The codebook below lists all variables, the values they take, and the survey questions associated with them. There are a total of 57,061 cases and 114 variables in this dataset. Note that this is a cumulative data file for surveys conducted between 1972 - 2012 and that not all respondents answered all questions in all years. Codebook: Review the codebook to view a list of all variables, the values they take, and the original survey questions associated with the variables. Use the following code to load the GSS dataset into R: load(url(\"http://bit.ly/dasi_gss_data\")) For access from China try using the following URL in the code above: http://d396qusza40orc.cloudfront.net/statistics/project/gss.Rdata The name of the dataset that you load is gss. For example, you can see a list of the variable names using the following command: names(gss) Note that this dataset includes data from many years. In your analysis it might make sense to first subset the data for a particular year (or years) and analyze only data pertaining to those years. This might be especially useful if you're using a variable from a survey question that was only asked in certain years. (2) American National Elections Study (ANES): (2) American National Elections Study (ANES): A survey of voters in the United States, conducted before and after every presidential election. The codebook below lists all variables, the values they take, and the survey questions associated with them.There are a total of 5,914 cases and 205 variables in this dataset. Note that not all respondents answered all questions. Codebook: Review the codebook to view a list of all variables, the values they take, and the original survey questions associated with the variables. Use the following code to load the ANES dataset into R: load(url(\"http://bit.ly/dasi_anes_data\")) For access from China try using the following URL in the code above: http://d396qusza40orc.cloudfront.net/statistics/project/anes.RData The name of the dataset that you load is anes. For example, you can see a list of the variable names using the following command: names(anes) Examples of variables and research questions appropriate for the project Provided below are some examples of types of research questions and data that are appropriate for the project: One numerical and one categorical: Is there a relationship between whether the mother worked during the first 5 years of the child's life and the highest level of education the child attains? [Data: Number of years of education of child; Mom's working status - yes, no] Two categorical: Do racial minority groups in North Carolina have less access to health care coverage? [Data: Ethnicity - various levels; Health coverage - yes, no] Note that you can work with one numerical and one categorical variable, or two categorical variables (but not two numerical variables, as we'll learn methods associated with those later in the course). While it may not be clear to you yet which techniques you would use to do statistical inference to answer these questions, you will have learned all the tools you need for the proposal by the end of Week 1 and all the tools you need for the actual project by the end of Week 6. Questions and answers about the project What type of variables should I use for my project? You need to pick two variables and evaluate the relationship between them. These can be a numerical and a categorical variable or two categorical variables. Do not use two numerical variables. How will I find a dataset for my project? You can either find your own dataset on the web, collect your own data, or use one of the datasets we provide specifically to be used in the project (listed above). While finding or collecting your own dataset is an eye-opening experience that we think is immensely valuable, it can be very time consuming. There are a variety of data resources online, some of which we'll point you to throughout the course and some of which you might discover yourself. However, the internet is a bottomless well of information, and finding a dataset that interests you, that is appropriate for this project, and that can be analyzed using tools from this course can be challenging. Therefore, choosing to work with one of the datasets we provide to get a head start on the project quickly can also be a good idea. You are the best judge of how much time you can devote to the project, so it is your choice and responsibility to decide which route you want to take. Can I use a dataset from the labs? No, you can to work with just about any dataset you like (as long as it meets the conditions required to apply the inferential methods we learn in this class), but you cannot re-use a dataset from the labs. One of the main objectives of this project is to work with a novel (to you) dataset. You can, however, choose to work with one of the datasets we provide specifically for the project (listed above). Do I have to use R for my project? Yes. While there are other statistical packages and/or programming languages that may be perfectly appropriate for your project, since one of the goals of this course is to learn R, all analysis must be completed in R. Projects completed using other statistical packages and/or programming languages will receive a penalty. Do I have to use RMarkdown for writing my project? Yes. While there are other options for word processors (Word, LibreOffice, etc.), the goal of this project is to create a fully reproducible data analysis document. RMarkdown is the perfect, easy-to-use environment for this. Projects completed in other formats will receive a penalty. What format should my project be submitted in? You should submit your project as an HTML file. This is the file that RStudio writes out when you hit \"Knit HTML\" in your markdown document. Simply upload the HTML file and your peer reviewer will be able to view your project in their browser. Where can I find a list of R commands that might be useful for the project? See this document for a list of R commands you encountered in labs as well as a few others that you might find useful for the project. Note that this is not an exhaustive list. Can I use DataCamp for my project? No, for the project you will need to use R/RStudio. Who am I writing for? Write as if you are explaining your results to whomever would be interested in your research question, whether this is another scholar in your field or peers sharing your interest in the topic. This audience may not have taken a statistics course. You must be statistically accurate and use correct statistical terminology, but must also explain your conclusions in a way that anyone can understand. Who will see my work? Other students who have submitted similar work will be given your work to evaluate. In addition, you will be able to share your work via the forum with the rest of the students to benefit everyone in class. You will benefit by receiving additional ideas about your project. How will this project be graded? The projects will be evaluated via peer assessment. Three other students will carefully read your project proposal and will provide feedback on your project proposal. This part will not count towards your final grade, but it will prepare you for the data analysis project, show you other data sets and other ways of approaching questions, and give you practice with peer assessment. For the data analysis project, you will receive a score that is the median of your peer reviewers. You will receive the full score if you perform all 3 of your peer assessments; if you do not complete 3 peer assessments, your final score will be decremented by 20%. The project score counts as 15% towards your final grade for a certificate with distinction. What do I have to do when? 我何时做何事？ 本项目有两阶段，项目提案和数据分析。 There are two phases of the project: a project proposal phase and a data analysis project phase. Each phase contains a submission period and an evaluation period where you will provide feedback on others projects. Although you can access the data analysis project right away, you are more likely to be successful if you wait until you get feedback on your project proposal before submitting a completed data analysis project. See the Due Dates page. 互评项目涉嫌抄袭，怎么办？ 遵照互评/反馈指导，完成项目互评。 向Coursera报告抄袭 我自己该如何避免抄袭？ 抄袭是指未加引用地使用了他人的工作成果。关于来源引用，请访问 OWL 。在你个人项目中，需要对所有来源给出可信引用，甚至你就是原作者但发表在其他地方。","tags":"data","loc":"http://sndnyang.github.io/dasi-project-translate.html","title":"杜克大学数据分析与统计推断 互评项目翻译"},{"text":"转换方法 正则表达式 -> epsilon-NFA DFA -> re 正则2自动机 自动机2正则 k-Paths 路径中， 不存在序号大于k的状态结点 末端点不限状态 转换步骤 k=0; 仅有直接相连的边或结点本身 归纳： 从 k-1 Paths 归纳出 k Paths, 即： 结点从序号不大于k-1 到 不大于 k 公式: $$R&#94;k_{ij} =R&#94;{k-1} {ij} + R&#94;{k-1} (R&#94;{k-1} {kk})* R&#94;{k-1} $$","tags":"cs","loc":"http://sndnyang.github.io/re-2-fa.html","title":"正则表达式转自动机"},{"text":"definition algebraic notation that describes the regular languages. E 是 RE， L（E）则是它定义的语言 基本定义 如果 a 是个符号， a 是个正则表达式， L( a ) = {a} 如果 $\\epsilon$ 是正则表达式， L( eps ) = {eps} 如果 空集 是正则表达式， L() = 空集 归纳 以下三种操作 $L(E_1+E_2) = L(E_1) \\cup L(E_2)$ $ L(E_1E_2) = L(E_1)L(E_2) $ 操作 交集，连结， Kleene star Union 对语言的集合求交集 连结 { wx for w in L for x in M } star { l ** n for l in L for n in range ( 0 , infinity )}","tags":"cs","loc":"http://sndnyang.github.io/RE-Basic.html","title":"正则表达式概念"},{"text":"列表 reduce","tags":"python","loc":"http://sndnyang.github.io/pythonBuiltinLib.html","title":"python 内建函数"},{"text":"列表 1. ' cmp_to_key ' , - ' get_cache_token ' , - ' lru_cache ' , - ' namedtuple ' , - ' partial ' , - ' partialmethod ' , - ' reduce ' , - ' singledispatch ' , - ' total_ordering ' , - ' update_wrapper ' , - ' wraps '","tags":"python","loc":"http://sndnyang.github.io/stdlib-functools.html","title":"标准库functools"},{"text":"语法 变量 {{var}} , render _ template(\"index.html\", title = 'Home', user = user) 控制 {% if title %} <title> {{ title }} - microblog </title> {% else %} <title> Welcome to microblog </title> {% endif %} 循环 { % for post in posts % } < p > {{ post.author.nickname }} says : < b > {{ post.body }} </ b ></ p > { % endfor % } 模板继承 super(base.html): 其他内容 ＋ {% block content %}{% endblock %} 如base 里面定义导航栏， 其他页面用 block content 扩展其他内容 sub(index.html): {% extends \"base.html\" %} {% block content %} Hi, {{user.nickname}}! {% for post in posts %} {{post.author.nickname}} says: {{post.body}} {% endfor %}","tags":"web","loc":"http://sndnyang.github.io/HtmlTemplatesInPython.html","title":"python web框架html模板"},{"text":"记号 Annotation 类上 @Controller 方法上 @RequestMapping(\"/path/{str}\") 方法的参数 @RequestParam(\"name\") type name 参数 路径变量匹配 @PathVar(\"str\") 参数报文体 @RequestBody type var type是自定义类 返回 public @ResponseBody type function() 其他参数 参数@RequestParam(\"var\") MultipartFile var, InputStream in = var.getInputStream() 转换 json 到 ResponseBody 和 RequestBody 之间的转换","tags":"web","loc":"http://sndnyang.github.io/springController.html","title":"controller.mkd"},{"text":"boolean 可以用作整数， True 1 ， False 0 for while 可以有 else sum(y in t.lower() for y in w) 字符串代表真， 不用bool, sum\\all\\any使用的是迭代器， 所以不用建[] 对元组或列表使用 * , 就可以将 之转成不定长参数","tags":"python","loc":"http://sndnyang.github.io/pythonTipsCheckIO.html","title":"checkio.mkd"},{"text":"常用命令列表 常用命令大概20个左右， 非要分类的话，大致可以分成以下几类： 1. 文件系统相关 2. 系统管理相关 3. 文本操作相关 按常用来排序，同时考虑分类的话，个人这样分类： 基础的基础 cd 路径切换 ls 查看目录下文件列表 more/less 文本文件内容游览 在命令行模式下，这三个命令是最容易使用，也最容易掌握的。 文本编辑 vi/vim/emacs 系统管理 ps 进程列表 kill 结束进程 top(as) CPU、内存状态 文件操作 cat head/tail wc touch > mkdir rm find grep cut 较高级命令 sed awk 命令使用总结 cd 基本使用方法 cd 相对或绝对的路径 Linux的根路径是 / 用户主目录是 ~ 或者干脆不带路径 上一层路径是 .. 上一个路径是 - ls 以下参数随意组合，如 -lrt, -alF -l 文件详细信息列表 -t 按修改时间排序 -r 逆序 -A 全部，包括隐藏文件 -a 还多出 . 和 .. -F 带颜色，并区别文件和文件夹 more/less 对于大文件也可使用， Vim等可能内存不足 f 向下翻页 b 向上翻页 g 文件首行 G 文件末行 /内容 在文件中搜索内容 vi/vim/emacs 内容太丰富， 是编辑器们， 不只是个命令 ps ps 当前用户运行的进程 ps -A 所有进程， 等效于 -e ps -f 详细信息 cat/head/tail cat filename 输出文件内容 head filename 输出文件头10行 tail filename 输出文件尾10行 head/tail -n filename 输出文件头/尾 x行 wc wc filename 统计文件的行数，单词数及字符数 wc -l filename 统计文件行数（带个文件名） cat filename | wc -l 输出行数 touch/mkdir touch filename 新建文件， 有些支持 > filename mkdir dirname 新建文件夹 rm rm filename 删除指定文件 rm -fr dirname 强制删除文件夹全部内容 或是 rm part 删除文件名带part 的文件， 支持?(单个字符), *(多个字符) cut 文本分割 cut -d \"x\" -f n filename 对文件用x字符进行分割，并输出第n列 cat filename | cut -d \"x\" -f n 脚本里好使用 说明 x 只能是单个字符， n可以是单个数字， 也可以是\" \"里写多个数字 其他 find/grep sed awk 见其他文章， 谢谢","tags":"shell","loc":"http://sndnyang.github.io/LinuxCommand.html","title":"Linux常用命令"},{"text":"union find 并查集优化 方法 1 带权重快速合并 好处: 优化 快速合并 ，避免树的层次过多 随时记录每棵树（子树）的大小 通过将较小子树的根挂在较大树的根下，来获得平衡 数据结构 比快速合并算法，增加一个大小为N的整型数组sz。 sz[i]代表以i为根的对象个数。 查找 与快速合并相同， return root(p) == root(q) 合并 将较小子树的根结点连接到较大子树的根结点 更新sz数组 public void union(int p, int q) { int i = root(p); int j = root(q); if ( sz [ i ] < sz [ j ]) { id [ i ] = j ; sz [ j ] += sz [ i ];} else { id [ j ] = i ; sz [ i ] += sz [ i ]; } } 算法分析 运行时间: 查找: 与p和q的深度成正比 即 lg N 合并: 对给定的根，只花费常数时间 lg N 命题: 结点x的尝试最多为 lg N. 路径压缩 方法: 计算出p的根结点后， 将每个被检测到的结点都指向这个根结点 实现: 两次遍历: 循环中再增加一次处理， 将每个被检测到的结点的id 指向上一层的根结点。 private int root(int i) { while (i != id[i]) { id[i] = id[id[i]]; i = id[i]; } return i; } 命题: 从空集开始，N个对象的任意M次操作，对数组的访问次数萍踪: <= c ( N + M lg * N ) lg * N 其实就是 lg N 的再次求对数的样子。 In computer science, the iterated logarithm of n, written log* n (usually read \"log star\"), is the number of times the logarithm function must be iteratively applied before the result is less than or equal to 1. 本算法理论上非线性复杂度， 实际上可以看作线性。","tags":"cs","loc":"http://sndnyang.github.io/union_find_opt.html","title":"并查集优化"},{"text":"quick union 快速合并 数据结构 大小为N 的整型数组 解释: id[i] 是 i 的父结点。 i 的根结点就是 id[id[id[...id[i]...]]] java 实现重点 public boolean connected ( int p , int q ) { return root ( p ) == root ( q ) } private int root ( int i ) { while ( i != id [ i ]) i = id [ i ]; return i ; } public void union ( int p , int q ) { int i = root ( p ); int j = root ( q ); id [ i ] = j ; } 算法分析 成本分析: 初始化: N 合并: N 查找: N 缺陷: 生成树太高、太深 查找的成本也高。","tags":"cs","loc":"http://sndnyang.github.io/quick_union_algo.html","title":"快速合并算法"},{"text":"percolation 作业 描述 N * N的方格（site） 如果方格与顶层中的某一方格是连通的，则称其 is full 如果方格与底层中的某一方格是连通的，则称其 是开放的。is open 当顶层中的某一方格与底层中的某一方格连通时，则称这整个N ﹡ N个方格的系统为percolation的。 状态 蒙特卡罗算法 初始化N﹡N个关闭的格子 任意开放某个格子，直到这个系统percolation 计算 概率 tip 提示","tags":"cs","loc":"http://sndnyang.github.io/percolation_assignment.html","title":"percolation作业"},{"text":"连通性问题 问题定义： 给定 N个物体（点） 存在两种操作： 1. 连接： 连接两点 2. 查询连通性： 两点间是否存在路径 问题建模： 对象建模： 简单就是个点， 然后用个数组下标0 —— N-1来表示 连通性建模： '连接到' 等价于以下数学表示： 1. 反射： 自身是连通的。 2. 对称： 如果p连接到q，则q也连接到p 3. 传递： 如果p连接到q，q又连通r， 则p 也连通r. 连通分量(connected component) 相互连通的物体的最大集合 操作的实现: Find查询: 查询两点是否在同一分量 Union连接：","tags":"cs","loc":"http://sndnyang.github.io/algo_connectivity.html","title":"连通性问题"},{"text":"什么是机器学习 定义： 从数据中获取到的经验，使某方面的表现更好(如更高的准确率、识别速率) 为什么使用机器学习 规则难定义或未知 程序编写复杂 从数据中学习中相对容易 使用情形示例： 无法人工编写出全部规则 (规则未可尽知) 无法准确定义 (规则难以言表) 快速决策 面向大量用户 所以 机器学习是编写复杂规则系统的一种替代方法","tags":"cs","loc":"http://sndnyang.github.io/ML_define.html","title":"什么是机器学习"},{"text":"1.语法 特殊的文件 /etc/profile 在登录时首先自动执行。 $HOME/.profile 在登录时第二个自动执行。 $ENV 在创建一个新的KShell时指定要读的一个文件。 文件名元字符 匹配有零或零个以上字符的字符串 ? 匹配任何单个字符 [abc…] 匹配括号内任何一个字符，也可用连字符指定一个范围（例如，a-z,A-Z,0-9） [!abc…] 匹配任何不包括在括号内的字符 ?(pattern) 匹配模式的零个或一个实例 *(pattern) 匹配指定模式的零个或多个实例 ＋(pattern) 匹配指定模式的一个或多个实例 ＠(pattern) 只匹配指定模式的一个实例 ！(pattern) 匹配任何不匹配模式的字符串 \\n 匹配与(…)中的第n个子模式匹配的文本。 这个模式pattern可能是由分隔符\"|\"或\"＆\"分隔的模式的序列， 例：pr !(*.o|core) | lp 引用 ; 命令分隔符 ＆ 后台执行 ( ) 命令分组 | 管道 < > & 重定向符号 ? [ ] ~ + - @ ! 文件名元字符 \"\" 中间的字符会逐字引用，除了`` 替换命令和$ 替换变量. ‘' 中间的所有字符都会逐字引用 \\ 在其后的字符会按其原来的意义逐字采用.如在\"\"中使用 \\\",`,\\$ \\a 警告，\\b退格,\\f 换页,\\n 换行,\\r 回车,\\ 制表符,\\v 垂直制表符, \\nnn 八进制值,\\xnn 十六进制值,\\' 单引号,\\\" 双引号,\\ 反斜线, `` 命令的替换 $ 变量的替换 命令形式 Cmd & 在后台执行 Cmd1;cmd2 命令序列，依次执行 {cmd1;cmd2;} 将命令做为一组来执行 (cmd1;cmd2) 在子shell中，将命令做为一组执行 Cmd1|cmd2 管道;将cmd1的输出作为cmd2的输入 Cmd1 cmd2 命令替换;用cmd2的输出作为cmd1的参数 Cmd1$(cmd2) 命令替换，可以嵌套 Cmd$((expression)) 运算替换。用表达式结果作为参数 Cmd1&&cmd2 逻辑与。如果cmd1成功才执行cmd2 Cmd1||cmd2 逻辑或。如果cmd1成功则不会执行cmd2 重定向形式 文件描述符： 0 标准输入 stdin 默认为键盘 1 标准输出 stdout 2 标准错误 stderr Cmd > file 将cmd的结果输出到file(覆盖) Cmd >> file 将cmd的结果输出到file(追加) Cmd < file 从file中获取cmd 的输入 Cmd << text 将shell脚本的内容（直到遇见一个和text一样的标记为止）作为cmd的输入 Cmd <> file 在标准输入上打开文件以便读写 Cmd >&n 将输出发送到文件描述符n。ll >&1 Cmd m>&n 将本来输出的m中的内容转发到n中。Ll 3>&2 Cmd >&- 关闭标准输出 Cmd <&n 获取输入 Cmd m<&n Cmd <&- 关闭标准输入 在文件描述符和一个重定向符号间不允许有空格。 Cmd 2>file 将标准错误发到file中 Cmd > file 2>&1 将标准错误和标准输出都发到file Cmd > f1 2>f2 将标准输出发到f1,标准错误发到f2 Cmd | tee files 将输出发送到标准输出和files中 Cmd 2>&1 | tee files 将输出和错误同时发到标准输出和files中 2. 变量 变量替换 下列表达式中不允许使用空格。冒号是可选的，如果用冒号那么变量必须是非空的并设置了初始值。 Var=value… 将变量var 设为value ${var} 使用变量var的值;如果变量和其后面的文本是分开的则可以不加大括号。 ${var:-value} 如果变量var已设置则使用它，否则使用值value ${var:=value} 如果变量var已设置则使用它，否则使用值value并将value赋给变量var ${var:+value} 如果变量var已设置则使用value，否则什么也不使用 例:echo ${u-$d};echo ${tmp- date }如果没设tmp,则执行date; 内置变量 $# 命令行参数的个数 $? 上一条命令执行后返回的值 $$ 当前进程的进程号(PID), 通常用于在shell脚本中创建临时文件的名称 $0 第一个参数即命令名 $n 命令行上的第n个参数 $ * 将命令行上所有参数作为一个字符串 $@ 命令行上所有参数，但每个参数都被引号引起来 特殊内置变量 LINENO 脚本或函数内正在执行的命令的行号 OLDPWD 前一个工作目录（由CD设置） PPID 当前SHELL的父进程的进程号 PWD 当前工作目录（由CD设置） RANDOM[=n] 每次引用时产生一个随机数，如果给定n则以整数n开始 SECONDS 这个整型变量的值是指从这个shell会话启动算起所过去的秒数。但它更有用的是用脚本中的计时。 例：start=$SECONDS read answer finish=$SECONDS 特殊内置变量续 TMOUT 如果设置了该变量，则在没有输入的情况下经过TMOUT变量所指定的秒数后，shell退出。值为0时无效。 CDPATH 允许用户使用简单文件名作为CD的参数，从而快速改变目录。设置方法与PATH类似，通常在启动文件中设置。如果CD的参数是一个绝对路径，则不会查询CDPATH. 例：CDPATH=:/u1/nr:/u1/progs: export CDPATH cd nr 就会进到nr中去。 注意：变量必须大写，定义后必须导出. 数组 Kshell支持一维数组，最多支持1024个元素。第一个元素为０。 Set –A name value0 value1 … 声明数组，指定的值就成为name的元素。 ${name[i]} i为0至1023的值，可以是表达式。返回数组元素i ${name} 返回数组元素０ ${name[ ]},${name[@]} 返回所有元素 下标[ ]和[@]都可以提取整个数组的内容。但当它们在引号中使用时其行为是不同的。使用@可生成一个数组，这个数组是原始数组的副本，而使用 ，则生成的仅仅是具有单一元素的数组(或者是一个普通变量)。 例：set -A a \"${names[ ]}\" set -A b \"${names[@]}\" set|head -5 a[0]='alex helen jenny scott' b[0]=alex b[1]=helen b[2]=jenny b[3]=scott ${#name[*]} 返回数组元素个数 运算符 Kshell使用C语言中的运算符。 % 求余;<< 左移;>> 右移;<= 小于等于;>= 大于等于;< 小于; 大于;== 相等;!= 不等;&& 逻辑与;|| 逻辑或; 3.内置命令 条件执行语句。 If condition1 Then commands1 [elif condition2 Then commands2] … [else commands3] Fi 循环控制 for For x [ in list ] Do Commands Done 使变量x(在可选的值列表中)执行commands，省略时假定为\"$@\"位置参数 例: For item in cat program_list Do Grep –c \"$item.[co]\" chap* Done repeat repeat word do commands done 指定一个命令序列执行的次数。 例： repeat 3 do echo \"bye\" done select Select x [ in list ] Do Commands Done 显示一列按list中顺序编号的菜单项。让用户键入行号选择或按return重新显示。 例: Ps3=\"select thd item number:\" Select event in format page view exit Do Case \"event\" in Format) nroff $file | lp;; Page) pr $file | lp;; View) more $file;; Exit) exit 0;; *) echo \"invalid selection\";; Esac Done 控制语句case Case value in Pattern1 ) cmds1 ;; Pattern2 ) cmds2 ;; … … Esac 类似于select case.例: Case $ 1 in No | yea ) response = 1 break ;; - [ tT ]) table = TRUE ;; * ) echo \" unknown option \" ; exit 1 ;; Esac 函数 Function name{commands;} 定义一个函数 or functionName {commands;} 必须有commands Eval args args是一行包含shell变量的代码.eval首先进行变量扩展，并且运行由此产生的命令。在shell变量包括了重定向符号，别名或其他变量时是有用的。 例: Eval sort $file $out Export [name=[value]…] 定义全局变量，让其它shell脚本也可以使用。无参数时输出当前定义的全局变量。 Let expressions 执行一个或多个表达式。表达式中的变量前不必有$.如果表达式中包含了空格或其他特殊字符，则必须引起来。 例：let \"I = I + 1\" 或 let i=i+1 Read [var1[?string]] [var2 …] 从标准输入读入一行给相应的变量，并把剩余的单词给最后一个变量。String为相应的提示信息.无参时只等待一次输入。 Readonly [var1[=value] var2[=value] …] 设置只读变量,无参时显示所有只读变量 select the item number: set [options arg1 arg2 …] 无参时输出所有已知变量的值。 Shift [n] 交换位置参数（如将$2变为$1）.如果给出n,则向左移动n个位置。通常用于在while循环中迭代命令行参数。N可以是一个整数表达式。 Sleep [n] 睡眠n秒钟 条件判断 Test condition 或[ condition ] 判断条件，为真返回0,否则返回非0. 文件： -a filename 如果该文件存在而为真 -d filename 如果该文件存在且为一个目录，则为真 -f filename 如果该文件存在且为一个常规文件，则为真 -L filename 如果该文件存在且为一个符号链接，为真 -r filename 如果该文件存在且用户对其有读取权限，真 -s filename 如果该文件存在且包含信息(大于0字节)，真 -w filename 如果该文件存在且对其有写入权，真 -x filename 如果该文件存在且对其有执行权，真 File1 -nt file2 如果file1存在且在file2后修改则值为真(指修改时间) File1 -ot file2 如果file1存在且在file2前修改则值为真(指修改时间) 字符串： string 如果string不为空字符串则值为真 -n string 如果string字符长度大于0则值为真 -z string 如果string字符长度等于0则值为真 string1=sting2 如果string1等于string2则值为真 string1!=string2 如果string1不等于string2则值为真 string2可以是通配符模式。 整数比较： - gt 大于； - ge 大于或等于； - eq 等于； - ne 不等于 ; - le 小于或等于 ; - lt 小于 组合： ! condition 如果condition为假则为真 condition1 –a condition2 如果两个条件都为真则为真 condition1 –o condition2 如果两个条件有一个为真则为真 trap [[commands] signals] 如果接收到任何的信号signals则执行命令commands.如果完全忽略commands则会重新设置由默认行为处理指定的信号。 例： Trap \"\" 2 ;忽略信号2（中断，通常是ctrl+c） Trap 2 ;恢复中断2 Trap \"rm –f $tmp;exit\" 0 1 2 15 ;当shell程序退出，用户退出，按ctrl+c或执行kill时删除$tmp. Typeset [options] [var [var]…]设置变量属性 - -u 将变量值中所有字母全部转换成大写 - -l 将变量值中所有字母全部转换成小写 - -i 将变量值设为整数类型.-ix x为相应的进制，表示时为x#变量值，可用于进制转换。 例：typeset -i2 vv vv=2 echo $vv 2#10 typeset -i 相当于integer - -L width 在width宽度之内左对齐 - -R width 在width宽度之内右对齐，前面空位用空格填充 - -Z width 在width宽度之内右对齐，变量如果是数字，则前面空位用零填充 如果忽略width,将使用赋给这个变量的第一个值的宽度。 - -x 设置一个变量全局。typeset -x 相当于 export - -r 设置一个变量具有只读属性，在设置的同时或之前，要先给这些变量赋值。 例：typeset -r PATH FPATH=/usr/local/funcs typeset -r 相当于 readonly 不带参数的typeset可以列出变量和变量的属性。查看指定的变量属性可用type|grep day 使用带有某一选项的typeset来看看哪一个变量具有特定的属性：typeset -z Unset var 删除一个变量，将它置为空 Until condition Do Commands Done 执行命令command直到满足条件condition. While condition Do Commands Done 如果满足条件condition则执行commands","tags":"shell","loc":"http://sndnyang.github.io/ksh_manual.html","title":"ksh手册"},{"text":"[TOC] impress js 介绍 pandoc 模板 参数列表 都需要指定坐标，因为是绝对位置 所以如果pandoc 能自动地对impress.js 进行相对处理，会好很多 位置 位置坐标，物体中心所在 data-x=-1500 data-y=1500 data-z=1500 外观 data-perspective=\"500\" data-scale=4 动作 data-transition-duration=\"2000\" 顺时针旋转 data-rotate=180 data-rotate-x=60 data-rotate-y=60","tags":"tool","loc":"http://sndnyang.github.io/impress-jsjiao-cheng.html","title":"impress js教程"},{"text":"[TOC] 跟我一起写 Makefile 概述 —— 什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。 因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 makefile带来的好处就是——\"自动化编译\"，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。 现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在\"文件依赖性\"上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。 在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。 关于程序的编译和链接 —————————— 在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫\"库文件\"（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。 总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File. 好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。 Makefile 介绍 ——————— make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。 首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是： 1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。 2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。 3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。 只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。 一、Makefile的规则 在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。 target ... : prerequisites ... command ... ... target 也就是一个目标文件，可以是 Object File ，也可以是执行文件。还可以是一个标签（ Label ），对于标签这种特性，在后续的\"伪目标\"章节中会有叙述。 prerequisites 就是，要生成那个 target 所需要的文件或是目标。 command 也就是 make 需要执行的命令。（任意的 Shell 命令） 这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。 说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）","tags":"makefile","loc":"http://sndnyang.github.io/makefile.html","title":"跟我一起写 Makefile"},{"text":"[TOC] markdown 模板格式要求 文章模板如下： Title : My super title Date : 2010 - 12 - 03 10 : 20 Category : Python Tags : pelican , publishing Slug : my - super - post Author : Alexis Metaireau Summary : Short version for index and feeds This is the content of my super blog post . [ TOC ] # 这个是生成目录用的 说明 slug 是生成的html 文件名， 不然中文转换成拼音，英文则是原文件名。 语法要求 图片等资源 建议放到顶层目录的 res 或 imags 下。 链接到其他 mkd 转化成的html时， 路径不是实际路径，都在 / 下， 名字对应为 title 或 slug 应该是这样。 暂时没想到其他的了。","tags":"tool","loc":"http://sndnyang.github.io/pelican_config.html","title":"pelican_config"},{"text":"[TOC] 插入 sed ' 1 i \\ sdfasdf ' file sed \"1i \\\\ $var\" file 替换 sed ' s / abc / def / g ; s / dsfds / gdkok / g ' file","tags":"shell","loc":"http://sndnyang.github.io/awkyu-sed.html","title":"awk与sed"},{"text":"sed 使用技巧 替换 插入 sed ' 1 i \\ sdfasdf ' file sed \"1i \\\\ $var\" file","tags":"shell","loc":"http://sndnyang.github.io/shell-ti-huan-yu-cha-ru.html","title":"shell 替换与插入"},{"text":"Nginx 服务器配置 路径 /etc/nginx","tags":"server","loc":"http://sndnyang.github.io/nginx-pei-zhi.html","title":"nginx 配置"},{"text":"科学方法 设计有效算法的步骤 对问题建模 寻找算法来解决 判定是否高效、内存足够 如果不够好，找出原因 优化算法来解决问题 迭代直到满意","tags":"cs","loc":"http://sndnyang.github.io/suan-fa-ke-bi-ji-zhi-ke-xue-fang-fa.html","title":"算法课笔记之科学方法"},{"text":"% shell 特殊功能 % 杨秀隆 % 20140605 有用功能 编码判断加转换 enca 或 iconv 一、利用iconv命令进行文件内容编码转换 下载地址 iconv 用法：iconv [选项...] [文件...] 有如下选项可用: 输入/输出格式规范： -f, --from-code=名称 原始文本编码 -t, --to-code=名称 输出编码 二、enca 下载地址 enca 和 enconv enca用法如下： enca -L zh_CN file 检查文件的编码 enca -L zh_CN -x UTF-8 file 将文件编码转换为\"UTF-8\"编码 enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样 除了有检查文件编码的功能以外，\"enca\"还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而\"iconv\"则会报错。这对于脚本编写是比较方便的事情。 转换单个文件的编码 enca -L none -x utf-8 index.html 参数太长 如 rm -f * 删除当前路径下所有文件时，可能文件太多，报错Argument list too long 解决方法: ls | xargs rm - f 写个循环也行，但是肯定没有上面一句就搞定简单。 判断操作系统 uname 命令行参数处理模块 Shell中提供了一条获取和处理命令行选项的语句，即getopts语句。该语句的格式为: getopts option_string variable option_string中包含一个有效的单字符选项。若getopts命令在命令行中发现了连字符，那么它将用连字符后面的字符同 option_string相比较。若有匹配，则把变量variable的值设为该选项。若无匹配，则variable设为?。当getopts发现连字符后面没有字符，会返回一个非零的状态值。Shell程序中可以利用getopts的返回值建立一个循环。 有时侯选项中还带一个值，getopts命令同样也支持这一功能。这时需要在option_string中选项字母后加一个冒号。当 getopts命令发现冒号后，会从命令行该选项后读取该值。若该值存在，那么将被存在一个特殊的变量OPTARG中。如果该值不存在，getopts命令将在OPTARG中存放一个问号，并且在标准错误输出上显示一条消息。 optstring option字符串，会逐个匹配 varname 每次匹配成功的选项 arg 参数列表，没写时它会取命令行参数列表 $OPTIND 特殊变量，option index，会逐个递增, 初始值为1 $OPTARG 特殊变量，option argument，不同情况下有不同的值 细则1： 当optstring以\":\"开头时,getopts会区分invalid option错误和miss option argument。 invalid option错误时,varname会被设成?,$OPTARG是出问题的option；miss option argument时,varname会被设成:(在我的fedora系统里测试OPTARG为?),$OPTARG是出问题的option. 当optstring不以\":\"开头,invalid option错误和miss option argument错误都会使varname被设成?, $OPTARG是出问题的option(在我的fedora系统里测试OPTARG为空). 细则2： 当optstring中的字母跟\":\"时,表明该option可接参数,参数(argument)放在$OPTARG中,如果缺参数,且optstring是以\":\"开头,则varname的值会是:(在我的fedora系统里测试OPTARG为?),$OPTARG是该option, 否则varname的值是?,$OPTARG是该option.(参照细则1)(在我的fedora系统里测试OPTARG为空)","tags":"shell","loc":"http://sndnyang.github.io/shell_gong-neng.html","title":"shell_功能"},{"text":"% 第一周 % 杨秀隆 % 2014-06-22 课程介绍 原则 be real 直面自我 know what matters 知道 embody values consistently 体现价值 align actions with values 价值驱动行动 envision your legacy 想像自己的财产 convey values with stories hold yourself accountable be whole clarify expectations help others build supportive networks apply all your resources manage boundaries intelligently weave disparate strands be innovative focus on results resolve conflicts among domains challenge the status quo see new ways of doing things embrace change courageously create culture of innovation 评价技能，定制目标","tags":"totalleader","loc":"http://sndnyang.github.io/week1.html","title":"week1"},{"text":"% shell 语法 % 杨秀隆 % 2014-06-11 数学运算 使用的是 (( 运算式 )) 示例 : (( bch_id += 1 )) 不支持 ++ (( next = pre + 1 )) 不能用 next = (( pre + 1 )) 或是 let var=运算式 示例: let new_rank = $ old_rank - 1 进制情况 value too great for base : let new_rank = 10 #$ old_rank - 1 十进制 分支条件 shell 或者说 ksh 的else if 使用 elif 写法， 简洁易用的写法 示例: if [[ x - eq \"3456\" ]] then echo \"3456\" elif [[ x - eq \"4567\" ]] then echo \"4567\" elif [[ x - eq \"1234\" ]] then echo \"1234\" else echo \"none\" fi","tags":"shell","loc":"http://sndnyang.github.io/ksh_yu-fa.html","title":"ksh_语法"},{"text":"﻿% C/C++ 编程规范 % 杨秀隆 % 20140616 源代码组织 源文件 .h .c .cpp .hpp 库文件 动态库 .a(UNIX) / .dll(Windows) 优点: 执行过程中装载 程序较小 共享动态库 注意点: 动态库需要一同发布 静态库 .so(UNIX) / .lib(Windows) 优点： 执行时不需要静态库 注意点： 链接时，库中数据加入 占用空间、资源多 静态变量 static 特点: 1. 分配在全局数据区 2. 在声明时初始化一次 3. 不显式初始化，则为0 外部变量 extern 排版命名 匈牙利命名法 组成： 作用域前缀 _ 类型简称 [ _ 基本名称 ][ _ 限定词 ] m : 类的成员变量 sm : 类的静态成员变量 g : 全局变量 s : 静态变量 函数事项 命名 参数 某个参数（指针或引用）功能上不会在函数中修改时， 必须定义为const 尽量用引用传参 函数对参数进行合法性检查 局部变量 返回时会被释放或析构——别返回错了。 对象设计原则 抽象、封装、继承、多态","tags":"c_c++","loc":"http://sndnyang.github.io/bian-cheng-gui-fan.html","title":"编程规范"},{"text":"% cscope % 杨秀隆 % 20140619 cscope 相当于 source insight 里的 look up reference 帮助文档 :help if_cscop.txt 它被设计用来回答以下的问题: 什么地方用到了这个符号？ 这是在什么地方定义的？ 这个变量在哪里被赋值？ 这个全局符号的定义在哪里？ 这个函数在源文件中的哪个地方？ 哪些函数调用了这个函数？ 这个函数调用了哪些函数？ 信息 \"out of space\" 从哪来？ 这个源文件在整个目录结构中处于什么位置？ 哪些文件包含这个头文件？ 安装Cscope 如果你的系统中有cscope命令, 则可以跳过这一小段, 如果没有, 就先跟着我一起安装一个吧. 在Cscope的主页: http://cscope.sourceforge.net 下载一个源码包, 解压后编译安装: ./configure make make install //需要root权限 配置 在~/vimrc中增加一句: :setcscopequickfix=s-,c-,d-,i-,t-,e- 这个是设定是否使用 quickfix 窗口来显示 cscope 结果, 用法在后面会说到。 跟Ctags一样, 要使用其功能必须先为你的代码生成一个cscope的数据库, 在项目的根目录运行下面的命令: $ cscope - Rbq 会生成三个文件 $ ll cscope . * - rw - rw - r -- 1 wooin wooin 1.1 M 2007 - 09 - 30 10 : 56 cscope . in . out - rw - rw - r -- 1 wooin wooin 6.7 M 2007 - 09 - 30 10 : 56 cscope . out - rw - rw - r -- 1 wooin wooin 5.1 M 2007 - 09 - 30 10 : 56 cscope . po . out 使用cscope 进入vim后第一件事是要把刚才生成的cscope文件导入到vim中来, 用下面的命令: : cs add .. / cscope . out / home / wooin / vim71 不能只写前半句 : cs add .. / cscope . out 因为源码是多级目录的, 如果这样写, cscope是无法在子目录中的源码中工作的, 当然, 如果你的源码都在同一级目录中就无所谓了.如果你要经常用cscope的话, 可以把上面那句加到~/.vimrc中去. 下面我们来操练一下, 查找函数vim_strsave()的定义, 用命令: :csfind g vim_strsave 如下图: 按下回车后vim会自动跳转到第一个符合要求的地方, 并且在命令栏显示有多少符合要求的结果, 如图: 如果自动跳转的位置你不满意, 想看其他的结果, 可以用下面的命令打开QuickFix窗口: :cw 这时你就可以慢慢挑选了&#94;_&#94; cscope的主要功能是通过同的子命令\"find\"来实现的 \"cscope find\"的用法: cs find c|d|e|f|g|i|s|t name 0 或 s 查找本 C 符号(可以跳过注释) 1 或 g 查找本定义 2 或 d 查找本函数调用的函数 3 或 c 查找调用本函数的函数 4 或 t 查找本字符串 6 或 e 查找本 egrep 模式 7 或 f 查找本文件 8 或 i 查找包含本文件的文件 如果每次查找都要输入一长串命令的话还真是件讨人厌的事情, Cscope的帮助手册中推荐了一些快捷键的用法, 下面是其中一组,也是我用的, 将下面的内容添加到~/.vimrc中, 并重启vim: nmap s :cs find s =expand(\" \") nmap g :cs find g =expand(\" \") nmap c :cs find c =expand(\" \") nmap t :cs find t =expand(\" \") nmap e :cs find e =expand(\" \") nmap f :cs find f =expand(\" \") nmap i :cs find i&#94; =expand(\" \") $ nmap d :cs find d =expand(\" \") 当光标停在某个你要查找的词上时, 按下 g, 就是查找该对象的定义, 其他的同理. 按这种组合键有一点技巧,按了 后要马上按下一个键,否则屏幕一闪就回到nomal状态了 g的按法是先按\"Ctrl+Shift+-\", 然后很快再按\"g\" reset :重新初始化所有连接。 用法 : csreset","tags":"vim","loc":"http://sndnyang.github.io/cscope_tips.html","title":"cscope_tips"},{"text":"% 使用shell 来完成建label % 杨秀隆 % 20140508 建label 整体流程 设置全局参数 hff_global.sh 检查开发环境 hff_check_repo.sh 检查link hff_check_link.sh 新建link hff_create_link.sh 开发环境建label makelabel_dev.sh 提交到编译环境 （未完成, 手工) 编译环境建label makelabel_rel.sh 运行实例建label （未完成， 手动） 下载编译环境label download_label.sh 提交到ftp upload_label.sh 步骤详述 设置全局参数 根据提示的文件路径，检查版本库地址、用户、密码信息 windows下使用git bash时，请使用utf-8 格式 unix/linux下，则使用默认格式即可 项目参数配置 检查开发环境 检查Link 配置 建链接方法待更新，敬请期待，哈哈。 开发环境建label 编译环境更新label 编译环境建label 使用环境 99.1.57.232 开发环境，任意目录下 hff_label.sh 99.1.57.232 /home/midsrv/user/yxl/tools/firefly 所有shell文件在这里 使用说明 以上步骤，使用hff_label.sh 完整运行。 也可以使用单个脚本文件执行部分功能。 既能拆分，也能组合。","tags":"firefly","loc":"http://sndnyang.github.io/label_shellgong-ju.html","title":"label_shell工具"},{"text":"% Git安装使用手册 % 杨秀隆 % 20140604 Git安装手册 下载（非最新版） 链接地址 Res 下载 git 和 github 安装 git， 解压 github chrome 和 markdown reader 可以实时预览mkd文件，宽屏幕或多屏幕肯定特好用 安装步骤 偏傻瓜，要么上网搜搜 汉字等配置 见另一文档 中文配置 如果chrome 装有 markdown reader， 可以访问下面这个: 中文配置 版本库手册（纯GitHub版） 打开解压后的github(GitHub.exe) 样式图——略 创建新的本地版本库， create（空文件夹拖进来也行) 配置信息 打开， 点击 tools-> settings 配置远程版本库信息 填写 用户名@IP:相对路径 用户名 -- 我的版本库都是rbcmb IP -- 我的电脑IP 99.6.145.70 路径 -- tools 从tools可以拿到其他几个 完成后，同步 sync 版本库手册（git命令行 + GitHub版） 在git bash或cmd里 克隆到当前目录 git clone rbcmb @ 99.6.145.70 : rbcmb 克隆到指定目录 git clone rbcmb @ 99.6.145.70 : rbcmb path 将文件夹拖进github 基础使用手册 注意 同步之前，本地变更集需要先提交完毕，再同步，否则文件容易混乱。 可以使用命令行、Git Gui、GitHub等多种方式查看log。推荐比较全面的gui工具 Tortoise Git， 虽然用到的时候不多。 本地配置 进行操作前的配置，也是安装后的配置： git config --global user.name 你的名字 省略 --global 也行 git config --global user.email \"你的邮件地址\" 等同于 tortoise git 右键 Settings-Git-Edit local(global) .git/config 等同于GitHub里 create键旁边的 tools->options->configure git","tags":"git","loc":"http://sndnyang.github.io/git_an-zhuang-shi-yong-shou-ce.html","title":"git_安装使用手册"},{"text":"db2 特殊查询 增加列 alter table emp add sex char(1); ---增加sex这一列 更改字段类型 alter table emp alter column sex set data type char ( 3 ); --- 将 sex 这一列修改为 char ( 3 ) alter table emp alter column sex set data type char ( 2 ); --- 将 sex 这列修改回 char ( 2 ) insert into emp values ( 1 , ' smith ' , 18.23 , ' 22 ' ); --- 向 emp 表插入一条记录 alter table emp alter column sex set data type char ( 3 ); --- 在有记录的情况下，将 sex 这列修改为 char ( 3 ), 成功 alter table emp alter column sex set data type char ( 1 ); --- 在有记录的情况下，将 sex 这列修改为 char ( 1 ), 失败 --- \"指定的属性与现有列不兼容\" alter table emp alter column sex set data type decimal ( 18 , 2 ); --- 在有记录的情况下，将 sex 这列修改为 decimal ( 18 , 2 ), 成功 ( 原来是' 22 '被转换成了 22.00 ) alter table emp alter column sex set data type char ( 2 ); --- 将 sex 这列修改回 char ( 2 ) 失败 --- \"指定的属性与现有列不兼容\" alter table emp alter column sex set data type char ( 5 ); --- 将 sex 这列修改为 char ( 5 ) 成功 ( 原来的数字 22.00 被转换成了字符' 22.00 ' , 5 个字节 ) delete from emp ; insert into emp values ( 1 , ' smith ' , 18.23 , ' dd ' ); ---- 删除原来的数据，并插入新的数据 alter table emp alter column sex set data type decimal ( 18 , 2 ); --- 在有记录的情况下，将 sex 这列修改为 decimal ( 18 , 2 ), 失败 --- \"指定的属性与现有列不兼容\" ( ' dd '和数字不兼容 ) 如果要更改db2的类型， 首先要保证目标类型和要当前表中所有的数据类型都要兼容，比如如果要更改char为decimal，那么原先的字段就不能出现字符，比如abcd等，只能出现数据型字符，比如1,2,3等。否则db2就报错，说\"格式不兼容\"。 如果你要更改的只是size大小，而数据的类型不变，那么要保证字段是增加的，比如从char(5)到char(10),decimal(18,2)到decimal(19,2),这样是没问题的。 如果想缩减字段的size，那么就要保证所有表中的数据都小于你缩减后的值，否则也会报错。此时如果有需求必须要改变，那么就只能删除列，然后重建列了。当然重建表也可以。 删除列 alter table emp drop column sex ; 为字段添加默认值 alter table emp add sex char ( 1 ); alter table emp alter column sex set default 'm' ; 添加带默认值的字段 alter table emp add addr char ( 20 ) not null with default ' beijing ' ; 注意 另外要注意的是，无论是添加，删除，还是更改字段的时候，为了保险起见，最好都运行一下reorg命令 reorg table table_name ; 否则可能会造成其他操作时报错。","tags":"db2","loc":"http://sndnyang.github.io/db2_alter.html","title":"db2_alter"},{"text":"% 编写健壮的 shell 脚本 % 杨秀隆 % 20140605 有效技巧 防止变量未赋值 set - o nounset / set - u 使用这个选项可以使脚本在使用未初始化的变量时直接退出 shell 字符串变量中的空格 示例： x = \" dokjd \" 保留全部空格： echo \"$x\" 去除头尾空格: echo $ x shell string总结 空串判断 if [ -z \"$line\" ] 在awk使用时，全部是数字的外部string变量需要前后加双引号，不然会当作数值，打印时会出bug for循环遍历文件时，使用 for line in cat $filename 缺点: 当行内有空格时，一行会被划分成两行 上一条的替代方法 while read line do done < filename 缺点：过程中需要 命令行交互时， 无法输入命令。 shell 字符串格式化 和C相似 printf \"%-12s\" \"$x\" awk 和 c 的几乎一样 awk ' { printf \"%s-%s\" , $ 1 , $ 2 } ' 二次赋值 数组中二次赋值 i=1; x[1]=2; echo ${ x [ $ i ] } eval 变量二次赋值 见证奇迹的时刻: first_item = \"PROJECT_NAME\" eval $ first_item = \"LB03\" echo $ PROJECT_NAME 结果是 LB03 引申到数组的利用上 set -A array_name \"PROJECT_NAME\" \"BRANCH\" set -A array_value \"LB03\" \"DEV\" eval ${ array_name [ 1 ] } = ${ array_value [ 1 ] } echo \"BRANCH =\" $BRANCH 结果应该是 BRANCH = DEV 参数太长 如 rm -f * 删除当前路径下所有文件时，可能文件太多，报错Argument list too long 解决方法: ls | xargs rm - f 写个循环也行，但是肯定没有上面一句就搞定简单。 判断操作系统 uname","tags":"shell","loc":"http://sndnyang.github.io/shell_ji-qiao.html","title":"shell_技巧"},{"text":"% find与grep % 杨秀隆 % 20140606 find 手册 grep 手册 grep使用shell环境变量 grep -p \"$var\" 即可 只要在var里把形式定义好 整词匹配 -w find 加 grep 递归查找文件中字符串 命令: find . - name \"GateWay.cfg\" 2 >/ dev / null | xargs grep - E \"&#94;9520\" 递归查找 名为GateWay.cfg文件下 含有的 9520打头的字符 并将错误信息重定向到/dev/null下 格式说明: find 部分 find 主要使用格式如下: find path - name \"file_name_pattern\" 说明： file_name_pattern中，支持shell 通配符 * grep 部分 grep 主要使用格式如下： grep pattern filelist 常用参数 : -E 正则表达式 3. 管道 部分 find 后 | xargs 表示 将find到的文件内容作为参数。","tags":"shell","loc":"http://sndnyang.github.io/find_grep.html","title":"find_grep"},{"text":"% ksh数组的使用方法 一、 定义 定义与初始化数组变量： set - A name value1 value2 ... valuen 对应bash定义形式 arr = ( element1 element2 element3 ...... ) 给数组赋值也可以定义数组： name [ index ] = value 注意 下标是从0开始 二、 使用 访问数组变量： ${ name [ index ] } 一次访问数组变量中的所有元素： ${ name [ * ] } ${ name [ @ ] }","tags":"shell","loc":"http://sndnyang.github.io/ksh_shu-zu.html","title":"ksh_数组"},{"text":"% shell中时间相关说明 % 杨秀隆 % 20140606 date命令的使用 不带任何参数的使用，结果: Tue Jan 7 07:25:17 CST 2014 时间显示格式 date +%Y%m%D%H%M%S, 即加号后%字母%字母2...... 常用格式参数 %Y year %m month %d 当月几号 %D 等价于 %m/%d/%y %H 24小时制 %h 月份的英文缩写 %M 分钟 %S 秒 %s January 1, 1970至今多少秒，UNIGW系统的标准方式 sleep sleep只支持整数，即秒为单位 sleep 10 # 10 秒 需要毫秒级的sleep时，需要使用外部工具，如perl，C perl - e ' sleep ( 0.3 ) ' # 300 毫秒","tags":"shell","loc":"http://sndnyang.github.io/shell_shi-jian.html","title":"shell_时间"},{"text":"[TOC] Git hooks Remote Machine We create a bare git repo, then point the working tree at the docroot of our website. This means all the git stuff is kept in the somesite.git folder, but the files themselves are checked out to the website's folder. Then we setup a post-receive hook to update the worktree folder after new changes have been pushed to the repo. $ cd git $ mkdir somesite.git $ cd somesite.git/ $ git init --bare Initialized empty Git repository in /home/caius/git/somesite.git/ $ git --bare update-server-info $ git config core.worktree /home/caius/vhosts/somesite.com/htdocs $ git config core.bare false $ git config receive.denycurrentbranch ignore $ cat > hooks/post-receive !/bin/sh git checkout -f &#94;D $ chmod +x hooks/post-receive Local Machine And now on the client machine we add the remote repo as a git remote, and then push to it. $ git remote add web ssh://myserver/home/caius/git/somesite.git $ git push web +master:refs/heads/master Counting objects: 3, done. Writing objects: 100% (3/3), 229 bytes, done. Total 3 (delta 0), reused 0 (delta 0) To ssh://myserver/home/caius/git/somesite.git * [new branch] master -> master All Done And now if you go to somesite.com you'll see the contents of your git repo there. (somesite.com is just an example url though, I don't actually own it!) 文件夹 hook 下 post-receive 这些都是脚本","tags":"git","loc":"http://sndnyang.github.io/git-hooks.html","title":"Git hooks"},{"text":"% FireFly 总结 % 杨秀隆 % 2014-05-28 FireFly 总结 FireFly 命令 hff 会直接显示命令， 效果等同于 hff -? hff create 文件名 文件名 文件名 hff submit 文件名 文件名 文件名 hff edit 文件名 文件名 文件名 hff list-out 目录，查看是否有 edit，但没有submit的文件 hff list-hijacked 目录，查看是否有强行非法修改的文件 hff list-nwf 目录，查看是否有没有添加到Firefly管理的文件 hff diffs 文件名 查看版本区别 FireFly 问题 firefly 提交或签出 No changeset found 错误 在Firefly Command Line 中，进入工作区目录，输入：hff check -repair , 即可修复变更集","tags":"firefly","loc":"http://sndnyang.github.io/fireflyming-ling.html","title":"Firefly命令"},{"text":"% vim技巧总结 % 杨秀隆 % 20140528 vim 技巧 模式 ctrl-v 或 ctrl-q 进入可视块状态， 即 列编辑模式。 页面跳转 gg 文件首行 G 文件末尾 H M L 光标跳转页顶，页中，页底 zt zz zb 光标所在行置顶、置中、置底 排版缩进 按v进入visual状态，选择多行，用>或<缩进或缩出 等效于 x >>/<< x行缩进 通常根据语言特征使用自动缩进排版：在命令状态下对当前行用== （连按=两次）, 或对多行用n==（n是自然数）表示自动缩进从当前行起的下面n行。你可以试试把代码缩进任意打乱再用n==排版，相当于一般IDE里的code format。使用gg=G可对整篇代码进行排版 至于如何针对自定义语言制订缩进规则，还有点问题，成功率不高。 代码跳转 % 跳转到配对的括号去 [[ 跳转到代码块的开头去(但要求代码块中'{'必须单独占一行) gD 跳转到局部变量的定义处 '' 跳转到光标上次停靠的地方, 是两个', 而不是一个\" 书签 mx 设置书签,x只能是a-z的26个字母 x 跳转到书签处(\" \"是1左边的键)","tags":"vim","loc":"http://sndnyang.github.io/vim_tips.html","title":"vim_tips"},{"text":"% 编写健壮的 shell 脚本 % 杨秀隆 % grep使用shell环境变量 grep -p \"$var\" 即可 只要在var里把形式定义好 整词匹配 -w","tags":"shell","loc":"http://sndnyang.github.io/grepji-qiao.html","title":"grep技巧"},{"text":"完整流程 流程步骤 client新建项目 开发环境编辑项目、文件后提交 server explorer 建立link 开发环境建label 上传编译环境、覆盖 编译环境打label firefly client 客户端新建项目 拷贝 模板文件夹 副本， 改名为 项目名-项目编号 将此文件夹放到 firefly 控制的主目录下， 示例: 下载分支 LB03_直付通项目， 在该分支中从模板文件夹建立新项目。 右键添加到firefly控制中。 firefly server explorer 建立link链接 选中项目（一般选主分支下的XXX_YYY项目 这个分支） 点创建链接，选择分支（选择相应REL分支） 例如 LB_03直付通系统——MainBranch——LB03_直付通_REL——LB03_直付通_DEV 或 LB03_直付通MIDRUN_DEV 如图： 选择源分支及目标分支的路径 源分支：选择到产品下一级的项目，如PAYFEE-EPAY 目标分支：选择到项目-程序（文档）-XX 一级。 如图： 点击中间的 >> 符号，即可链接过去。选中 Readonly后，下一步。 后续填写，完成。 如图: 开发环境 项目编辑常用命令 hff create 文件名/文件夹名/.(指当前全部) hff edit/unedit 文件名/文件夹名/.(指当前全部) hff submit 文件名/文件夹名/.(指当前全部) hff list-out 目录，查看是否有edit，但没有submit的文件 hff list-hijacked 目录，查看是否有强行非法修改的文件 hff list-nwf 目录，查看是否有没有添加到Firefly管理的文件 hff diffs 文件名，查看版本区别 开发环境建label 编辑文件列表 运行脚本 编辑文件列表 devfile.txt 要提交文件的相对路径，模板见 label工具/devfile.txt 格式: 项目名 - 项目编号\\ path \\文件 path由建立link链接时的路径加代码文件所在路径组合。 示例： 否认交易处理系统维护改进 - T1317341 \\程序\\服务器程序\\ EPAY \\ script \\ EPAY_CHL_90210_Script . cfg EPAY之前是目标分支的路径，从EPAY到之后是源分支中链接路径。 运行脚本 makelabel_dev.bat 修改 PRJ_NAME 项目 REL_BRANCH 编译分支名 LABEL_NAME 标签名 执行 编译环境 下载 登陆 99.1.76.245 midsrv/midsrv cd tmp downlaod_lbl.sh label名 覆盖相应项目的流程文件 或是 添加 hff create 文件名/文件夹名/.(指当前全部) hff edit 文件名/文件夹名/.(指当前全部) hff submit 文件名/文件夹名/.(指当前全部) 编译环境打label relfile.txt 要提交文件的相对路径，模板见 label工具/devfile.txt 格式: path\\文件 path为文件完整路径 示例： midsrv \\ node \\ PAYFEE \\ EPAY \\ script \\ EPAY_CHL_90210_Script . cfg makelable_rel.bat 修改 PRJ_NAME 项目 REL_BRANCH 编译分支名 LABEL_NAME 标签名 执行 运行实例label 进入到对应的项目下(如LB01总行中间业务->LB01通信前置网关) 右键,如右键LB01_通信前置网关_项目,选择Label 填写好Name,如T1210101_LB01(BLGW)_V01.00_L01(最好选择下面的Inherit...) 之后的一步选择所更新的文件 比较 右键 compare 放入ST环境 download_label.bat ftp_foler.bat st发布ftp ftp://99.8.43.86 devuser/devuser uat 发布 编译环境label 赋权 微机编译组","tags":"firefly","loc":"http://sndnyang.github.io/labelliu-cheng.html","title":"label流程"},{"text":"参数处理-Shell传入参数的处理 $# 传递到脚本的参数个数 $﹡ 以一个单字符串显示所有向脚本传递的参数。与位置变量不同，此选项参数可超过9个 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的进程ID号 $@ 与$#相同，但是使用时加引号，并在引号中返回每个参数 $- 显示shell使用的当前选项，与set命令功能相同 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 变量 含义 $0 脚本名字 $1 位置参数 #1 $2 - $9 位置参数 #2 - #9 ${10} 位置参数 #10 $# 位置参数的个数 \"$﹡\" 所有的位置参数(作为单个字符串) * \"$@\" 所有的位置参数(每个都作为独立的字符串) ${#﹡} 传递到脚本中的命令行参数的个数 ${#@} 传递到脚本中的命令行参数的个数 $? 返回值 $$ 脚本的进程ID(PID) $- 传递到脚本中的标志(使用set) $_ 之前命令的最后一个参数 $! 运行在后台的最后一个作业的进程ID(PID) 特殊处理语句或命令 shift 语句， 命令行参数左移排除。","tags":"shell","loc":"http://sndnyang.github.io/can-shu-chu-li.html","title":"参数处理"},{"text":"db2 特殊查询 查询库中所有表 db2 \" select * from sysibm.systables \" db2 list tables for schema cmb 查询表结构(字段数和名) db2 describe table xxxx 查询表索引 db2 describe indexes for table show detail 有些平台有的 showindex . sh tablename","tags":"db2","loc":"http://sndnyang.github.io/db2_te-shu-cha-xun.html","title":"db2_特殊查询"},{"text":"% DB2 错误码 % 杨秀隆 % 20140513 DB2常见错误及解决办法 DB2SQLMTKJDBCIDEA . 1、创建数据库的时候，报 42704 错误。如： Sql代码 1.=>create database test 2.=>SQL0204N \"SYSTEM_1386_US\" is an undefined name. SQLSTATE=42704 =>create database test =>SQL0204N \"SYSTEM_1386_US\" is an undefined name. SQLSTATE=42704解决办法： Sql代码 1.=>create database test using codeset gbk territory cn =>create database test using codeset gbk territory cn 2、在连接数据的时候，报57017错误。如： Sql代码 1.=>connect to test user test using test 2.=>SQL0332N Character conversion from the source code page \"1386\" to the target code page \"819\" is not supported. SQLSTATE=57017 =>connect to test user test using test =>SQL0332N Character conversion from the source code page \"1386\" to the target code page \"819\" is not supported. SQLSTATE=57017解决办法： Sql代码 1.=>db2set db2codepage=1386 =>db2set db2codepage=1386 3、在对数据库进行操作的时候，报55039错误。如： Sql代码 1.=>db2 drop table t_base_acc_manageacc 2.=>SQL0290N Table space access is not allowed. SQLSTATE=55039 3. 4.=>db2 list tablespaces show detail 5.Tablespace ID = 2 6.Name = USERSPACE1 7.Type = System managed space 8.Contents = Any data 9.State = 0x0020 10.Detailed explanation: 11. Backup pending =>db2 drop table t_base_acc_manageacc =>SQL0290N Table space access is not allowed. SQLSTATE=55039 =>db2 list tablespaces show detail Tablespace ID = 2 Name = USERSPACE1 Type = System managed space Contents = Any data State = 0x0020 Detailed explanation: Backup pending 原因：在归档的数据库做过load或者改了参数重新启动了db 解决办法： Sql代码 1.备份数据库 2.=>db2 backup db 备份数据库 =>db2 backup db 4、在对数据库进行备份的时候，报57019错误。如： Sql代码 1.=>db2 backup database dbname to /xx/xx compress 2.=>SQL1035N The database is currently in use. SQLSTATE=57019 =>db2 backup database dbname to /xx/xx compress =>SQL1035N The database is currently in use. SQLSTATE=57019解决办法： Sql代码 1.=>db2stop force 2.=>db2start =>db2stop force =>db2start 5、在对创建表空间的时候，报54047错误。如： Sql代码 1.=>create regular tablespace space1 pagesize 4 k managed by database using (device '/dev/dd' 25000000) prefetchsize automatic bufferpool bp1 2.=>SQL1139N The total size of the table space is too big. SQLSTATE=54047 =>create regular tablespace space1 pagesize 4 k managed by database using (device '/dev/dd' 25000000) prefetchsize automatic bufferpool bp1 =>SQL1139N The total size of the table space is too big. SQLSTATE=54047解决办法：把表空间的大小改小点或者把regular（64G）换成large就ok了。 6、DB2备份失败，报内存不足，增大了dbheap也没有用。SQL2009C，没有足够的可用内存来运行此实用程序。 原因：DB2 UTIL_HEAP_SZ 未设置得足够高以用于备份实用程序。 解决办法：db2 update db cfg for dbname using UTIL_HEAP_SZ 具体的数字（db2备份使用的内存是UTIL_HEAP_SZ，请使用以上命令调整）。 7、用JDBC往表批量插入数据时。报23502错误。如： Sql代码 1.Error for batch element #0: DB2 SQL error: SQLCODE: -407, SQLSTATE: 23502, SQLERRMC: TBSPACEID=2, TABLEID=15, COLNO=2 Error for batch element #0: DB2 SQL error: SQLCODE: -407, SQLSTATE: 23502, SQLERRMC: TBSPACEID=2, TABLEID=15, COLNO=2 原因：往表中有非空约束的字段，插入空值。 解决办法：查看表定义，去掉非空约束，或加入非空值。 8、用JDBC往表批量插入数据时。报22001错误。如： Sql代码 1.DB2 SQL Error: SQLCODE=-302, SQLSTATE=22001, SQLERRMC=null DB2 SQL Error: SQLCODE=-302, SQLSTATE=22001, SQLERRMC=null原因：表中某字段的长度不够，发生字符串截断。 解决办法：查看表定义，加大字段长度。 9、用JDBC往表批量插入数据时。报-4474 错误。如： Sql代码 1.非法转换：不能从\"java.lang.String\"转换到\"byte[]\" ERRORCODE=-4474, SQLSTATE=null 非法转换：不能从\"java.lang.String\"转换到\"byte[]\" ERRORCODE=-4474, SQLSTATE=null原因：表中某字段定义为‘ID CHAR(16) FOR BIT DATA NOT NULL'（这个是使用MTK从MS SQL迁移到DB2时，uniqueidentifier转换成的）。 解决办法：重新创建表，把字段属性改为VARCHAR类型。 000 00000 SQL语句成功完成 01xxx SQL语句成功完成，但是有警告 +012 01545 未限定的列名被解释为一个有相互关系的引用 +098 01568 动态SQL语句用分号结束 +100 02000 没有找到满足SQL语句的行 +110 01561 用DATA CAPTURE定义的表的更新操作不能发送到原来的子系统 +111 01590 为2型索引设置了SUBPAGES语句 +117 01525 要插入的值的个数不等于被插入表的列数 +162 01514 指定的表空间被置为检查挂起状态 +203 01552 使用非唯一的名字来解决命名的限定列 +204 01532 命名的对象未在DB2中定义 +206 01533 命名的列不在SQL语句中指定的任何表中存在 +218 01537 因为SQL语句引用一个远程对象，不能为该SQL语句执行EXPLAIN +219 01532 命名的PLAN TABLE不存在 +220 01546 不正确定义PLAN TABLE，检查命名列的定义 +236 01005 SQLDA中的SQLN的值至少应于所描述的列的个数一样大 +237 01594 至少有一个被描述的列应该是单值类型，因此扩展的SQLVAR条目需要另外的空间 +238 01005 至少应有一个被描述的列是一个LOB，因此扩展的SQLVAR条目需要另外的空间 +239 01005 至少应有一个被描述的列应是单值类型，因此扩展的SQLVAR条目需要另外的空间 +304 01515 该值不能被分配给宿主变量，因为该值不再数据类型的范围之内 +331 01520 不能被翻译的字符串，因此被设置为NULL +339 01569 由于与DB2 2.2版本的子系统连接，所以可能存在字符转换问题 +394 01629 使用优化提示来选择访问路径 +395 01628 设置了无效的优化提示，原因代码指定了为什么，忽略优化提示 +402 01521 未知的位置 +403 01522 本地不存在CREAT ALIAS对象 +434 01608 在DB2未来发布的版本中将不支持指定的特性，IBM建议你停止使用这些特性 +445 01004 值被CAST函数截取 +462 01Hxx 由用户定义的函数或存储过程发出的警告 +464 01609 命名的存储过程超出了它可能返回的查询结果集的个数限制 +466 01610 指定由命名的存储过程返回的查询结果集的个数。成功完成 +494 01614 由存储过程返回的结果集的个数超过了由ASSOCIATE LOCATORS语句指定的结果集定位器的个数 +495 01616 因为倒台SQL的成本估算超出了在ELST中指定的警告阀值，所以发出警告 +535 01591 请求一个主健的定位更新，或请求一个使用自我引出 约束的表的删除操作 +541 01543 命名外健是一个重复的引用约束 +551 01548 命名的授权ID缺少在命名的DB2对象上执行命名操作的权限 +552 01542 命名的授权ID缺少执行命名操作的权限 +558 01516 已经被授权该PUBLIC，因此WITH GRANT OPTION不可用 +561 01523 对ALTER REFERENCES INDEX 和TRIGGER特权，PUBLIC AT ALL LOCATION无效 +562 01560 因为GRANTEE已经拥有这些特权，所以一个或更多的特权被忽略 +585 01625 模式名指定了不止一次 +599 01596 没有为长字符数据类型（BLOB，CLOB和DBCLOB）建立比较函数 +610 01566 由于建立了一个指定为DEFER YES的索引，指定的对象处于PENDING状态，或者因为使用了ALTER INDEX改变关键值的范围，所以指定的对象处于PENDING状态 +625 01518 因为删除了主健索引，所以表定义被标注为不完整 +626 01529 删除了加强UNIQUE约束的索引，唯一性不在被加强 +645 01528 因为建立的索引中没有包含NULL，所以WHERE NOT NULL被忽略 +650 01538 不能更改或者建立已命名的表为从属表 +653 01551 在已指定的分区表空间中尚没有建立指定的分区索引，所以分区索引不可得 +655 01597 为CREATE或ALTER STOGROUP语句指定特定或者非特定的卷ID，在DB2较新发布的版本中（版本6以后）将不再支持他们 +658 01600 当建立目录索引时，不能指定SUBPAGES语句，SUBPAGES将被忽略，并缺省为1 +664 01540 分区索引的限制关键字超出了最大值 +738 01530 已命名的对象的更改可能像只读系统中对象的改变要求一样 +799 0157 SET语句中引用的特定寄存器不存在，将忽略 SET请求 +802 01519 数据溢出或者因除法异常而引起的数据异常错误 +806 01553 ISOLATION（RR）与LOCKSIZE PAGE 冲突 +807 01554 由于十进制乘法导致溢出 +863 01539 连接成功，但是只支持SBCS +2000 56094 SUBPAGES不等于1的1型索引不能成为数据共享环境中的缓冲池组依赖者 +2002 01624 因为指定的缓冲池不允许超高速缓存，GNPCACHE指定被忽略 +2007 01602 因为DB2子系统的参数禁用\"提示(hiats）\"所以不能指定优化提示 +30100 01558 分布式协议错误被检测到，提供原来的SQLCODE和SQLSTATE -007 42601 SQL语句中由非法字符 -010 42603 字符串常量非正常终止；检查到有遗漏的引号标志 -029 42601 需要INTO语句 -060 42815 某特定数据类型的长度或者标量规范无效 -084 42612 不能执行SQL语句，因为该语句对动态SQL无效或者对OS/390的DB2无效 -097 42601 在单位类型、用户自定义的函数以及过程中不能使用带有CAST的LONG VARCHAR或LONGVARGRAPHIC -101 54001 SQL语句超出了已确定的DB2限制：例如，表的数目太多，语句中的字节太多 -102 54002 字符串常量太长 -103 42604 无效数学文字 -104 42601 SQL语句中遇到非法符号 -105 42604 无效的字符串格式；通常引用一个格式不正确的图形字符串 -107 42622 对象名太长 -108 42601 RENAME语句中指定的名字有错误，不能使用限定词 -109 42601 指定了无效语句；例如CREATE VIEW不能包含ORDER BY 语句 -110 42606 遇到了无效的十六进制的文字 -111 42901 指定的列函数没有给出列名 -112 42607 无效的列函数语法；列函数不能运行与其他的列函数之上 -113 42602 遇到无效字符 -114 42961 该语句的位置名称必须与当前服务器匹配，但是却没有匹配 -115 42601 因为比较运算符没有伴着一个表达式或者列表，遇到了无效谓词 -117 42802 待插入的数值的个数于被插入的行中的列数不相等 -118 42902 数据修改语句(UPDATE或DELETE）和FROM语句中的表和视图命名不合法 -119 42803 HAVING语句中的列的列表与GROUP BY语句中的列列表不匹配 -120 42903 不允许WHERE语句、SET语句、VALUES语句或者SET ASSIGNMENT语句引用列函数 -121 42701 在INSERT或UPDATE语句中，某一列被非法引用了两次 -122 42803 非法使用了列函数。因为没有用于一个列函数的所有列不再GROUP BY语句中 -123 42601 特定位置的参数必须是一个常数或者一个关键词 -125 42805 ORDER BY语句中指定了无效数字，该数字要么小于1要么大于选定的列数 -126 42829 不能为一个UPDATE语句指定ORDER BY语句 -127 42905 在子选择中DISTINCT只能指定一次 -128 42601 SQL谓词中NULL使用不当 -129 54004 SQL语句中包含的表多于15个 -130 22019 ESCAPE语句必须为一个字符 22025 无效的ESCAPE模式 -131 42818 LIKE谓词只能用于字符数据 -132 42824 LIKE语句、ESCAPE语句、LOCATE函数或POSSTR函数中有无效运算对象 -133 42906 无效相关子查询引用 -134 42907 大于255字节的列被不正确使用 -136 54005 排序关键字的长度大于4000字节 -137 54006 被连接的字符串太大；字符的最大值为32767；图形的最大值为16382 -138 22011 SUBSTR列函数的第二个或第三个操作符无效 -142 42612 不支持的SQL语句。该语句可能在另外的RDBMS上有效，也有可能在其他的上下文中有效（例如，VALUES只能在触发器中出现） -144 58003 指定的段号无效 -147 42809 某一源函数不能更改。要改变源函数，必须删除该源函数并重新建立他 -148 42809 RENAME和ALTER无法执行。RENAME不能对视图或者活动RI.ST表重新命名。ALTER不能用于改变列的长度，因为该列参与了RI、一个用户退出程序、全局的临时表或打开DATACAPTURE CHANGES表的列 -150 42807 触发活动的INSERT，UPDATE或DELETE语句中指定了无效的视图更新或一个无效的转换表 -151 42808 试图更新一个不可更新的视图的列、一个DB2 CATALOG表的列或者一个ROWID列 -152 42809 DROP CHECK试图删除一个参照约束，或者DROP FOREIGN试图删除一个检查约束 -153 42908 无效的视图建立请求，必须为旋转列表中列出的列出的未命名的列或者重复的列提供一个名字 -154 42909 不能用UNION、UNION ALL或者一个远程表建立视图 -156 42809 在视图上建立索引是非法的，或者在ALTER TABLE，CREATE TRIGGER，DROP TABLE或LOCK TABLE语句上指定一个不是表的其他对象这是无效的 -157 42810 必须在FOREIGN KEY语句中指定一个表名 -158 42811 视图的列和选择列表中的列不相匹配 -159 42089 无效DROP或COMMENT ON语句 -160 42813 对该视图的WITH CHECK OPTION无效 -161 44000 正被更新的视图WITH CHECK OPTION语句使得这行不能被插入或更新 -164 42502 用户没有建立这个视图的权限 -170 42605 标量函数指定了无效的参数个数 -171 42815 标量函数指定了无效的数据类型长度或者无效数值 -173 42801 在非只读型的游标上不能指定隔离级别UR -180 22007 DATE、TIME、TIMESTAMP值的字符串表示法的语法不对 -181 22001 不是有效的DATE、TIME、TIMESTAMP值 -182 42816 在算术表达式中的日期/时间值无效 -183 22008 在算术表达式中返回的日期/时间值的结果不在有效值的范围内 -184 42610 没有正确使用日期/时间值的参数标记 -185 57008 没有定义本定的日期/时间出口 -186 22505 改变本定的日期/时间出口引发这个程序的长度无效 -187 22506 MVS返回无效的当前日期/时间 -188 22503 字符串表示无效 -189 22522 指定的编码字符集的ID无效或没有定义 -190 42837 不能象所设定的那样改变（ALTER）列。只能改变（ALTER）VARCHAR列的长度 -191 22504 字符串中包含了无效的混合数据 -197 42877 当两个或多个表被联合在一起排序时，限定的列名不能在ORDER BY语句中使用 -198 42617 试图对空的字符串发布一个PREPARE或EXECUTE IMMEDIATE语句 -199 42601 SQL语句中使用了非法关键词 -203 42702 模糊列引用 -204 42704 没有定义的对象名 -205 42703 指定的表的列名无效 -206 42703 列名没有在FROM语句所引用的任何表中，或者没有在定义触发器所在的表中 -208 42707 不能ORDER BY指定列，应为该列不在选择列表中 -212 42712 指定的表名在触发器中不允许多次使用，只能使用一次 -214 42822 DISTINCT、ORDER BY 引起的无效表达式 -219 42704 因为PLAN_TABLE不存在，EXPLAIN无法执行 -220 55002 遇到无效的PLAN_TABLE列 -221 55002 如果为PLAN_TABLE定义了可供选择的列，那么，必须定义所有的列 -229 42708 指定的现场找不到 -240 428B4 LOCK TABLE语句的PART子句无效 -250 42718 没有定义本地位置名 -251 42602 记号无效 -300 22024 宿主变量或参数中的字符串不是以NULL为终止 -301 42895 无效的宿主变量数据类型 -302 22001 输入的变量值对指定的列无效 22003 输入的变量值对指定的列而言太大 -303 42806 因为数据类型不兼容，不能分配数值 -304 22003 因为数据超出了范围，不能分配数值 -305 22002 没有NULL指示符变量 -309 22512 因为引用的宿主变量被设置成NULL，所以谓词无效 -310 22501 十进制的宿主变量或参数包含非十进制数据 -311 22501 输入的宿主变量长度无效，或者时负值或者太大 -312 42618 没有定义宿主变量或者宿主变量不可用 -313 07001 宿主变量的个数不等于参数标识的个数 -314 42714 模糊的宿主变量引用 -327 22525 在最后分区的关键字范围内，不能插入行 -330 22021 不能成功的翻译字符串 -331 22021 字符串不能分配到宿主变量，因为其不能成功的被翻译 -332 57017 不能为两个命名的编码字符集的ID定义翻译规则 -333 56010 子类型无效导致翻译失败 -338 42972 ON语句无效，必须引用连接的列 -339 56082 访问DB2 2.2版本的子系统被拒绝，原因时ASCII到EBCDIC翻译不能进行 -350 42962 无效的大对象规范 -351 56084 SELECT列表中有不支持的数据类型 -352 56084 输入列表中有不支持的数据类型 -355 42993 LOB列太大，以至不能被记录在日志中 -372 428C1 每个表只允许有一个ROWID列 -390 42887 在上下文中指定的函数无效 -392 42855 自从前一次FETCH以来，指定游标的SQLDA已被不恰当的改变 -396 38505 在最后的访问过程中，视图执行SQL语句 -397 428D3 在某一列上不恰当的指定了GENERATED因为该列不是ROWID数据类型 -398 428D2 为某一个宿主变量请求LOCATOR，但是该宿主变量不是一个LOB -399 22511 在INSERT语句中为ROWID列指定的值无效 -400 54027 在DB2编目中定义的用户自定义索引不能超过100个 -401 42818 算术操作符或比较操作符的操作对象不是兼容的 -402 42819 算术函数不能用于字符或日期时间数据 -404 22001 SQL语句指定的字符串太长 -405 42820 数值文字超出了范围 -406 22003 计算出的或者倒出的数值超出了范围 -407 23502 不能把NULL值插到定义为NOT NULL的列中 -408 42821 数值不能被更新或插入，因为他与列的数据类型不兼容 -409 42607 COUNT函数指定的运算对象无效 -410 42820 浮点文字笔30个字符的最大允许长度长 -411 56040 CURRENT SQLID使用无效 -412 42823 在子查询的选择列表中遇到了多个列 -413 22003 当转换为一个数字型数据类型时，数据溢出 -414 42824 LIKE谓词不能运行于用数字或日期时间类型定义的列 -415 42825 为UNION操作指定的选择列表不是联合兼容的 -416 42907 包含UNION操作符的SQL语句不允许有长的字符串列 -417 42609 两参数标识符作为运算对象被指定在同一谓词的两边 -418 42610 参数标识符使用无效 -419 42911 十进制除法无效 -420 22018 字符串自变量值不符合函数的要求 -421 42826 UNION操作的选择列表中没有提供相同数目的列 -423 0F001 为LOB或结果集定位器指定的值无效 -426 2D528 在不允许更新的应用服务器不允许执行COMMIT语句 -427 2D529 在不允许更新的应用服务器不允许执行ROLLBACK语句 -430 38503 在用户自定义的函数或存储过程中遇到了错误 -433 22001 指定的值太长 -435 428B3 无效的应用定义的SQLSTATE -438 xxxxx 使用了RAISE_ERROR函数的应用发出了一个错误 -440 42884 存储过程或用户自定义函数的参数列表参数个数于预期的个数不匹配 -441 42601 与标量函数一起使用DISTINCT或ALL是不正确的用法 -443 42601 指定的外部函数返回错误的SQLSTATE -444 42724 与被称为存储过程或用户自定义函数有关的程序不能找到 -449 42878 对存储过程或用户自定义的 函数，CREATE或ALTER语句不正确（缺失EXTERNAL NAME 子句) -450 39501 存储过程或用户自定义函数写入存储器的值超过了参数声明的长度 -451 42815 CREATE FUNCTION中指定了不正确的数据类型 -453 42880 用户自定义函数中的RETURNS语句无效 -454 42723 指定的函数识别标记与已存在的另一函数的识别标记冲突 -455 42882 模式名不比配 -456 42710 为用户自定义函数指定的函数名已经存在 -457 42939 用户自定义函数或用户自定义类型正试图使用系统中定义的函数或者类型所用的名称 -458 42883 没有找到函数 -463 39001 特定的外部例程返回无效的SQLSTATE -469 42886 参数定义为OUT或INOUT的CALL语句必须提供宿主变量 -470 39002 指定了NULL参数，但是该例程却不支持NULL -471 55023 存储过程或用户自定义函数失败：提供原因代码 -472 24517 外部的函数程序使游标处于打开状态 -473 42918 用户自定义数据类型命名不能和系统定义的数据类型一样 -475 42866 结果类型不能被转换成RETURNS类型 -476 42725 在其模式中该函数不是独一无二的 -478 42893 不能DROP或REVOKE特定的对象，因为其他对象依赖于该对象 -480 51030 直到存储过程已经被CALL后，DESCRIBE PROCEDURE和ASSOCIATE LOCATORS才能被发布 -482 51030 存储过程不返回到任何一个定位器 -483 42885 CREATE FUNCTION语句中的参数个数与源函数中的参数个数不匹配 -487 38001 选择了NO SQL选项建立指定的存储过程或用户自定义函数，但却视图发布SQL语句 -491 42601 CREATE FUNCTION语句无效，因为该语句没有RETURNS语句或者因为该语句没有指定有效的SOURCE或者EXTERNAL语句 -492 42879 指定函数的指定参数的个数有错误 -495 57051 语句的估计处理器成本超出了资源限制 -496 51033 语句无法执行，因为当前服务器与调用存储过程的服务器不同 -497 54041 指定的数据库超过了32767 OBID的上限，或者CREATE DATABASE语句使之达到了32511DBID的上限 -499 24516 指定的游标已被分配到结果集，该结果集来自已经指定的存储过程 -500 24501 因为连接被破坏，WITH HOLD游标被关闭 -501 24501 在试图获取数据或关闭一个游标前必须打开一个游标 -502 24502 在没有关闭游标前不能再次打开游标 -503 42912 因为列在游标的FOR UPDATE OF语句中没有被指定，该游标用于获取该列，所以不能更新该列 -504 34000 不能引用一个游标，因为他不是定义到程序里的 -507 24501 在试图更新或者删除WHERE CURRENT OF前，必须打开游标 -508 24504 因为被引用的游标当前不是处于数据行上，所以不能被更新或删除 -509 42827 除了在游标上指定的那个表（该表由WHERE CURRENT OF语句引用的）以外，再也不能从别的表上更新数据 -510 42828 表或视图不能被修改 -511 42829 对不可修改的表或视图，FOR UPDATE OF语句无效 -512 56023 对远程对象的无效引用 -513 42924 一个别名不能再被定义成另外的别名 -514 26501 游标尚没有被准备 -516 26501 试图描述未准备好的SQL语句 -517 07005 因为SQL语句尚没有准备好，游标无效 -518 07003 试图执行尚没有准备好的SQL语句 -519 24506 当为游标的SQL语句发布一个准备语句是，游标不能是打开的 -525 51015 不能在已指定的程序包中执行SQL语句，因为在绑定时间内该程序包无效 -526 42995 在给定的上下文中，不能使用全局的临时表 -530 23503 对特定的约束名指定了无效的外健值 -531 23504 从版本5开始，父关键字的多行更新将试图删除一个外关键字依赖的父关键字值，在版本5以前，当引用主关键值外健值当前存在时，试图更新该主健值 -532 23504 删除操作违反了已指定的参照约束 -533 21501 多行插入无效，试图将多行插到自我引用的表中 -534 21502 可改变主健列值的更新语句不能在同一时刻用于更新多行 -535 21502 当从自我引用表中删除数据或者更新主健列时，不能指定WHERE CURRENT OF。不是版本5的子系统才调用该代码 -536 42914 因为某一特定表的参照约束存在，所以删除语句无效 -537 42709 在外健语句或主健语句的规范中，每个列的出现不能多于一次 -538 42830 无效的外健；不符合引用的表没有主健 -539 42888 不能定义外健，因为被引用的表没有主健 -540 57001 表定义不完整，直到为主健建立了唯一索引或UNIQUE语句、或者包含GENERATED BYDEFAULT属性的ROWID列 -542 42831 可以为空的列不允许作为主健的一部分包含在内 -543 23511 因为该表是指定了SET NULL删除规则的参照约束的父表而且检查约束不允许NULL，所以DELETE不能发生 -544 23512 不能用ALTER添加检查约束，因为已存在的某行与该检查约束冲突 -545 23513 INSERT或者UPDATE导致检查约束冲突 -546 42621 在CREATE或ALTER TABLE中指定的检查约束无效 -548 42621 因为指定的列而引起的检查约束无效 -549 42509 DYNAMICRULES（BIND）计划或程序包的无效SQL语句 -551 42501 用户试图对不拥有权限的特定的对象进行操作，或者表不存在 -552 42502 用户试图执行未被授权的操作 -553 42503 不能指定CURRENT SQLID，因为用户尚没有被允许改变那个ID -554 42502 不能对你本身赋予一个权限 -555 42502 不能对你本身撤销一个权限 -556 42504 不能撤销用户没有拥有的权限 -557 42852 指定了不一致的授予或撤销关键词 -558 56025 为授予或撤销语句指定了无效的语句（一个或一组） -559 57002 DB2权限机制已经禁用，授予或者撤销不能被发布 -567 42501 指定的权限ID缺少对指定的程序包的绑定权限 -571 25000 不允许多点更新 -573 42890 不能定义参照约束，因为已指定的父表中在指定的列上没有唯一健 -574 42864 指定的缺省与列定义冲突 -577 38002 试图修改用户自定义函数中的数据或者存储过程中的数据，但这些对象的建立没有选择MODIFIES SQL DATA选项 -579 38004 试图修改用户自定义函数中的数据或者存储过程中的数据，但这些对象的建立没有选择READ SQL DATA选项，也没有选择MODIFIES SQL DATA选项 -580 42625 CASE表达式中的结果表达式不能都是空的 -581 42804 CASE表达式中的结果表达式为不兼容的数据类型 -582 42625 SEARCHED－WHEN－CLAUSE中的查找条件指定了一个限定的、IN或EXISTS谓词 -583 42845 指定的函数失败，因为他不是决定性的，或者可能有外部动作 -585 42732 在当前路径中模式名不止一次出现 -586 42907 CURRENT PATH专用寄存器在长度上不能超过254字符 -587 428C6 项目引用的列表必须是同一个家族 -590 42734 在命名的存储过程或用户自定义的函数中的参数必须是独一无二的 -592 42510 没有授权权限，让你在WLM环境中建立的存储过程或者用户自定义函数 -601 42710 试图创建（或重命名）已经存在的对象 -602 54008 CREATE INDEX语句中指定的列太多 -603 23515 因为发现有重复值，所以不能建立唯一的索引 -604 42611 在CREATE或ALTER TABLE语句中的为数据类型指定的长度、精度以及标度无效 -607 42832 指定的INSERT、UPDATE或DELETE语句不能被发布，应为这些语句对DB2 CATLOG表执行写操作 -611 53088 当LOCKSIZE是TABLE或者TABLESPACE时，LOCKMAX必须为0 -612 42711 在同一个表、索引或试图中不允许有重复列名 -613 54008 主健或UNIQUE约束太长或者包含了太多的列 -614 54008 已经超过了索引的内部健长度的最大长度（255）限制 -615 55006 不能删除这个程序包，因为该程序包目前正在执行 -616 42893 指定的对象不能被删除，因为其他对象依赖于该对象 -617 56089 对于DB2版本6，1型索引无效。对于以前的版本，1型索引不能用LOCKSIZE ROW或LARGE表空间定义 -618 42832 对DB2 CATALOG表的请求操作时不允许的 -619 55011 DSNDB07不能修改，除非他先被停止了 -620 53001 对在DSNDB07中的表空间不允许指定该关键词 -621 58001 遇到了重复的DBID，遇到了系统问题 -622 56031 不能指定FOR MIXED DATA因为没有安装混合数据选项 -623 55012 不能为单一的表定义多个族索引 -624 42889 不能为单一的表定义多个主健 -625 55014 用主健定义的表要求唯一索引 -626 55015 不能发布ALTER语句来改变PRIQTY SECQTY或ERASE，除非先停止了表空间 -627 55016 不能发布ALTER语句来改变PRIQTY SECQTY或ERASE，除非先把表空间定义为使用存储器组的表空间 -628 42613 指定语句时相互排斥的（例如，不能分区一个分段的表空间） -629 42834 因为该外健不能包含空值，所以SET NULL无效 -630 56089 不能为1型索引指定WHERE NOT NULL -631 54008 无效的外健；要么是比254个字节长，要么包含的列数多于40 -632 42915 指定的删除规则禁止把这个表定义为已制定表的从属表 -633 42915 无效删除规则；必须使用特定的强制删除规则 -634 42915 在这种情况下，DELETE CASCADE不允许 -635 42915 删除规则不能有差异或者不能为SET NULL -636 56016 在分区索引健的升序或降序规范中，分区所以必须与该规范一致 -637 42614 遇到重复的关键词 -638 42601 在CREATE TABLE语句中缺少列定义 -639 56027 带有SET NULL的删除规则的外健的可空列不能是分区索引的列 -640 56089 不能为这个表空间指定LOCKSIZE ROW，因为在该表空间中的表上定义了1型索引 -642 54021 唯一约束包含太多的列 -643 54024 检查约束超出了3800个字符的最大长度 -644 42615 在SQL语句中为关键词指定的值无效 -646 55017 在指定的分区表空间或者缺省表空间中不能创建表，因为指定的表空间已经包含了一个表 -647 57003 指定的缓冲池无效，因为他没有被激活 -650 56090 ALTER INDEX不能被执行；提供了原因代码 -651 54025 如果CREARE或ALTER TABLE被允许，表对象的描述词（object descriptor,OBD）将超过最大值（32KB） -652 23506 遇到了EDITRPROC或VALIDPROC冲突 -653 57004 在分区表空间中的表不可用，因为分区索引尚未被创建 -655 56036 在卷的列表中，STOGROUP不能指定为特定的或不特定（\"*\"）的卷 -658 42917 当试图删除指定的对象时，无法删除该对象，该对象的删除必须通过删除与之相关联的对象完成 -660 53035 不正确的分区索引规范，必须为族索引定义有限制的关键字 -661 53036 分区索引没有指定恰当的分区数目 -662 53037 试图在未分区的表空间（分段的或简单的）上建立分区索引 -663 53038 为分区索引指定的关键字限制值是一个无效数字 -665 53039 为ALTER TABLESOACE语句指定了无效的PART语句 -666 57005 SQL语句不能被处理，因为指定的函数当前正处于进行过程中 -667 42917 不能明确的删除分区表空间的族索引，必须除去分区表空间来去掉分区索引 -668 56018 不能向用EDITPROC定义的表中添加列 -669 42917 不能显式的删除分区表空间中的表，必须删除分区表空间来删除表 -670 54010 表的记录长度超过了页面的大小 -671 53040 不能更改指定的表空间的缓冲池，因为这将改变表空间的页面大小 -672 55035 在命名的表上不允许DROP -676 53041 只有4KB的缓冲池可被用于一个索引 -677 57011 缓冲池扩展失败，由于可用的虚拟内存的大小不足 -678 53045 为才分区索引中指定的限制健提供的值与数据类型不符 -679 57006 不能创建某一个特定对象，因为该对象的一个drop目前正在挂起 -680 54011 对DB2表不能超过750列 -681 23507 列违反了指定的FIELDPROC -682 57010 不能载入FIELDPROC -683 42842 列、单值类型、函数或者过程无效，因为不兼容语句。例如，指定的INTEGER具有FORBITDATA选项 -684 54012 指定的文字列表不能超过254个字节 -685 58002 FIELDPROC返回一个无效的域描述 -686 53043 用FIELDPROC定义的一个列不能与一个使用不同的FIELDPROC定义的列作比较 -687 53044 列不能与一个非兼容字段类型的列比较 -688 58002 返回不正确的数据 -689 54011 从属表定义了太多的列 -690 23508 数据定义的控制支持拒绝这个语句 -691 57018 命名的注册表不存在 -692 57018 命名的索引不存在，但命名的注册表需要该索引 -693 55003 命名的注册表/索引的命名列无效 -694 57023 DROP正在命名的注册表上挂起 -696 42898 由于相关的名字或者转换表的名字使用不正确，指定的触发器无效 -697 42899 FOR EACH语句被指定，因此与OLD合NEW相关的名字是不允许的，或者不能为一个BEFORE触发器指定OLD_TABLE和NEW_TABLE -713 42815 指定的专用寄存器是无效的 -715 56064 命名的程序不能被运行，因为他依赖与你所安装的DB2版本的部件，但是你的数据中心没有安装这个部件 -716 56065 命名的程序使用这个版本的不正确的发行版本做了预编译 -717 56066 BIND失败，因为他依赖与你所安装的DB2版本的部件，但是你的数据中心没有安装这个部件 -718 56067 REBIND失败，因为IBMREQD列无效 -719 42710 不能BIND ADD一个已经存在的程序包 -720 42710 不能BIND REPLACE一个已经存在的程序包版本 -721 42710 程序包的一致性记号必须是独一无二的 -722 42704 绑定错误，因为指定的程序包不存在 -723 09000 一个触发的SQL语句接受到一个错误 -724 54038 达到了（16）级联间接的SQL语句的最大项目 -725 42721 对专门指定的寄存器提供了一个无效值 -726 55030 因为SYSPKSYSTEM条目，不能绑定这个程序包 -728 56080 指定的数据类型不能与私有协议发布一起使用 -729 429B1 用COMMIT ON RETURN定义的存储过程不能用作嵌套的CALL过程的目标 -730 56053 在只读的共享数据库中为表定义的参照完整性无效 -731 56054 VSAM数据集必须用SHAREOPTION（1.3）定义 -732 56055 被定义为只读型数据库却拥有没有定义空间或者索引空间的DB2子系统 -733 56056 只读共享数据库的定义不一致 -734 56057 一旦一个数据库被定义为ROSHARE READ，他将不能被更改为其他不同的ROSHARE状态 -735 55004 用DBID名称标识的数据库不再是一个只读共享数据库 -736 53014 命名的DBID无效 -737 53056 在这种状况下，不能建立一个隐含的表空间 -739 56088 因为同时指定了ALLOW PARALLEL和MODIELES SQL DATA这两个语句，因此已设定的函数将不能再被更改 -740 51034 在这种方式下不能用MODIELES SQL DATA定义指定的函数 -741 55030 已经为命名的共享组成员的数据定义了工作文件数据库 -742 53004 DSNDB07是隐含的工作文件数据库 -746 57053 在特定的触发器、存储过程或函数中的SQL语句违反嵌套SQL限制 -747 57054 指定的表是不可用的除非为LOB数据列建立起必须的辅助表 -748 54042 在指定的辅助表上已经有一个索引 -750 42986 不能对已指定的表重新命名,因为他至少在一个现存的视图或触发器中被引用 -751 42987 存储过程或用户自定义的函数试图执行一个不允许执行的SQL语句。DB2的线程被置于MUST_ROLLBACK状态 -752 0A001 无效CONNECT语句 -763 560A1 无效的表空间名 -764 560A2 LOB表空间必须与其相关的基表空间同在一个数据库中 -765 560A3 表和数据库不兼容 -766 560A4 不能对辅助表进行请求的操作 -767 42626 CREATE INDEX失败，因为在辅助表中为索引指定了列，或者因为没有为非辅助表的索引指定列 -768 560A50 不能为指定的列或者指定的分区建立辅助表，因为其辅助表已经存在 -769 53096 CREATE AUX TABLE的规格与基表不匹配 -770 530A6 指定的表必须有一个ROWID列，那么该表才可以包含一个LOB列 -771 428C7 无效的ROWID列规范 -797 42987 CREATE TRIGGER包含不被支持的语法 -798 428C9 不能把一个值插入到用GENERATED ALWAYS定义的ROWID列 -802 22012 某一特定操作发生了异常错误。被零除 22003 某一特定操作发生了异常错误。但不是被零除 -803 23505 不能插入行，因为这将违反唯一索引的约束 -804 07002 SQLDA的调用参数列表有误 -805 51002 在计划中没有发现DBRM或程序包名 -807 23509 对已指定的环境和连接，该程序包不可用 -808 08001 CONECT语句与程序中的第一个CONNECT语句不一致 -811 21000 当多行作为一内嵌的选择语句的返回结果是，必须使用游标 -812 22508 在CURRENT PACKAGESET中的ID集合是空白的，语句不能被执行 -815 42920 在一个内置选择语句或者一个基本谓词的子查询中，显式的或隐含的指定了GROUP BY或HAVING语句 -817 25000 执行SQL语句将可能导致禁止更新用户数据或DB2编目 -818 5103 计划<－>载入组件的时间戳不匹配，在执行计划中没有从同一个预编译中建立DBRM，该预编译是作为组件载入的 -819 58004 视图不能重建，因为在DB2编目中存储的分析树长度为0 -820 58004 在这个DB2版本的DB2编目中遇到了无效值 -822 51004 在SQLDA中遇到了无效地址 -840 54004 在选择列表或插入列表中返回的项目太多 -842 08002 到指定位置的连接已经存在 -843 08003 SET CONNECTION或RELEASE语句无法执行，因为连接不存在 -870 58026 宿主变量描述符的个数不等于语句中宿主变量的个数 -872 51302 这个子系统已指定了有效的CCSID -873 53090 同一SQL语句中，不能同时引用EBCDIC表中的定义的列和ASCII表中定义的列 -874 53901 指定对象的编码方案与其表空间的编码方案不匹配 -875 42988 指定的操作符不能用于ASCII数据 -876 53092 不能为指定的原因创建对象：提供了原因代码 -877 53093 数据库或表空间不允许用ASCII，必须使用EBCDIC -878 53094 该PLAN——TABLE不能是ASCII，必须使用EBCDIC -879 53095 指定对象的CREATE或ALTER语句不能将列、单值类型，某个存储过程或用户自定义函数的参数定义为以下类型：MAXED DATA，GRAPHIC，VARGRAPHIC，LONGVARGRAPHIC，因为系统没有为指定的编码方案定义相应的CCSID -900 08003 应用处理没有连接到应用服务器，语句不能被执行 -901 58004 遇到时断时续的系统错误，该错误不能抑制后继的SQL语句的执行 -902 58005 内部控制块的指针错误，要求重新绑定 -904 57011 指定的资源不可用 -905 57014 超出了资源上限 -906 51005 因为重大错误，SQL语句无法执行 -908 23510 当前资源限制设施的规范或者自动重绑定的系统参数不允许BIND，REBIND，AUTOREBIND -909 57007 对象已被删除 -910 57007 因为在该对象上挂起DROP，所以不能访问该对象 -911 40001 当前工作单元已被回滚 -913 57033 因为死锁或超时导致不成功执行 -917 42969 绑定程序包已经失败 -918 51021 SQL语句不能被执行，因为连接丢失 -919 56045 需要一个ROLLBACK -922 42505 连接权限失败。试图从TSO、CICS或IMS访问DB2，同时相应的连接设施处于非活动的状态 -923 57015 因为DB2不可用，所以不能建立连接 -924 58006 遇到了DB2内部的连接错误：提供了原因代码 -925 2D521 SQL的COMMIT语句不能从CICS或IMS/TM发布 -926 2D521 SQL的ROLLBACK语句不能从CICS或IMS/TM发布 -927 51006 当正在连接的环境没有建立时，语言接口被调用。利用DSN命令激发该程序 -929 58002 数据获取退出已经失败（DPROP） -939 51021 由于远程服务器的未请求的回滚，要求一个回滚 -947 56038 SQL语句失败，因为更新不能被传播（DPROP） -948 56062 DDF没有启动，分布式操作无效 -950 42705 在SQL语句中指定的位置在SYSIBM.LOCATIONS中没有定义 -965 51021 存储过程非正常终止（在DB2 6之前的版本） -981 57015 当前不是处于允许SQL的状态时，试图在RRSAF中执行SQL -991 57015 调用连接不能建立一个到DB2的隐含或开放连接 -2001 53089 为储存过程指定的宿主变量参数的个数不等于预期的参数个数 -20003 560A7 不能为GRECP中的表空间或索引指定GBPCACHE NONE -20004 560A8 对于WORKFILE对象。8KB或16Kb的缓冲池页面大小无效 -20005 54035 指定的对象类型超出了内部的ID极限 -20006 53097 当没有指定WLM环境时，LOB不能被指定为参数 -20070 53098 不能非LOB列建立一个辅助表 -20071 53099 必须指定WLM环境名 -20072 56052 指定的权限ID不拥有在触发器程序包上执行BIND所需的权限 -20073 42927 不能按照指定的要求更改命名的函数，因为在现存的视图定义中引用了该函数 -20074 42939 不能建立指定的对象，因为\"SYS\"是一个保留的前缀 -20100 56059 在被触发的SQL语句中有BIND错误，指定了错误的SQLCODE和SQLSTATE -20101 56059 由于指定的原因代码，该函数失败 -20102 42849 在CREATE或ALTER FUNCTION语句中不能使用指定的选项 -20104 42856 更改一个CCSID失败 -20106 42945 不能改变表空间或数据库的CCSID，因为现存的试图引用 -30000 58008 DRDA分布协议错误；处理可以继续 -30002 57057 使用DRDA的分布式客户把OPEN语句连接到PREPARE，但PREPARE接受到一个SQLCODE为＋495的警告 -30020 58009 DRDA分布协议错误；对话被解除 -30021 58010 DRDA分布协议错误；处理不能继续 -30030 58013 违反分布协议：COMMIT不成功，对话被解除（AS） -30040 57012 因为不能得到资源，执行失败，处理可以继续（AS） -30041 57013 因为不能得到资源，执行失败，处理不能成功的继续（AS） -30050 58011 执行不成功，在BIND过程中不能执行语句 -30051 58012 特定的BIND过程不是处于活动状态（远程BIND），从而导致失败 -30052 42932 程序准备的假设错误 -30053 42506 程序包的拥有者遭遇授权失败 -30060 08004 RBD遭遇授权失败 -30061 08004 指定了无效或者没有存在的RDB -30070 58014 目标子系统不支持这个命令 -30071 58015 目标子系统不支持这个对象 -30072 58016 目标子系统不支持这个参数 -30073 58017 目标子系统不支持这个参数值 -30074 58018 应答信息不被支持 -30080 08001 SNA通信错误 -30081 58019 TCP/IP通信错误 -30082 08001 由于安全冲突、通信失败：提供了原因代码 -30090 25000 指定的操作对远程执行失败 -30104 56095 在绑定选项与绑定值中有错误 -30105 56096 指定的绑定选项不兼容 sqlcode sqlstate 说明 000 00000 SQL语句成功完成 01xxx SQL语句成功完成，但是有警告 +012 01545 未限定的列名被解释为一个有相互关系的引用 +098 01568 动态SQL语句用分号结束 +100 02000 没有找到满足SQL语句的行 +110 01561 用DATA CAPTURE定义的表的更新操作不能发送到原来的子系统 +111 01590 为2型索引设置了SUBPAGES语句 +117 01525 要插入的值的个数不等于被插入表的列数 +162 01514 指定的表空间被置为检查挂起状态 +203 01552 使用非唯一的名字来解决命名的限定列 +204 01532 命名的对象未在DB2中定义 +206 01533 命名的列不在SQL语句中指定的任何表中存在 +218 01537 因为SQL语句引用一个远程对象，不能为该SQL语句执行EXPLAIN +219 01532 命名的PLAN TABLE不存在 +220 01546 不正确定义PLAN TABLE，检查命名列的定义 +236 01005 SQLDA中的SQLN的值至少应于所描述的列的个数一样大 +237 01594 至少有一个被描述的列应该是单值类型，因此扩展的SQLVAR条目需要另外的空间 +238 01005 至少应有一个被描述的列是一个LOB，因此扩展的SQLVAR条目需要另外的空间 +239 01005 至少应有一个被描述的列应是单值类型，因此扩展的SQLVAR条目需要另外的空间 +304 01515 该值不能被分配给宿主变量，因为该值不再数据类型的范围之内 +331 01520 不能被翻译的字符串，因此被设置为NULL +339 01569 由于与DB2 2.2版本的子系统连接，所以可能存在字符转换问题 +394 01629 使用优化提示来选择访问路径 +395 01628 设置了无效的优化提示，原因代码指定了为什么，忽略优化提示 +402 01521 未知的位置 +403 01522 本地不存在CREAT ALIAS对象 +434 01608 在DB2未来发布的版本中将不支持指定的特性，IBM建议你停止使用这些特性 +445 01004 值被CAST函数截取 +462 01Hxx 由用户定义的函数或存储过程发出的警告 +464 01609 命名的存储过程超出了它可能返回的查询结果集的个数限制 +466 01610 指定由命名的存储过程返回的查询结果集的个数。成功完成 +494 01614 由存储过程返回的结果集的个数超过了由ASSOCIATE LOCATORS语句指定的结果集定 位器的个数 +495 01616 因为倒台SQL的成本估算超出了在ELST中指定的警告阀值，所以发出警告 +535 01591 请求一个主健的定位更新，或请求一个使用自我引出 约束的表的删除操作 +541 01543 命名外健是一个重复的引用约束 +551 01548 命名的授权ID缺少在命名的DB2对象上执行命名操作的权限 +552 01542 命名的授权ID缺少执行命名操作的权限 +558 01516 已经被授权该PUBLIC，因此WITH GRANT OPTION不可用 +561 01523 对ALTER REFERENCES INDEX 和TRIGGER特权，PUBLIC AT ALL LOCATION无效 +562 01560 因为GRANTEE已经拥有这些特权，所以一个或更多的特权被忽略 +585 01625 模式名指定了不止一次 +599 01596 没有为长字符数据类型（BLOB，CLOB和DBCLOB）建立比较函数 +610 01566 由于建立了一个指定为DEFER YES的索引，指定的对象处于PENDING状态，或者因为 使用了ALTER INDEX改变关键值的范围，所以指定的对象处于PENDING状态 +625 01518 因为删除了主健索引，所以表定义被标注为不完整 +626 01529 删除了加强UNIQUE约束的索引，唯一性不在被加强 +645 01528 因为建立的索引中没有包含NULL，所以WHERE NOT NULL被忽略 +650 01538 不能更改或者建立已命名的表为从属表 +653 01551 在已指定的分区表空间中尚没有建立指定的分区索引，所以分区索引不可得 +655 01597 为CREATE或ALTER STOGROUP语句指定特定或者非特定的卷ID，在DB2较新发布的 版本中（版本6以后）将不再支持他们 +658 01600 当建立目录索引时，不能指定SUBPAGES语句，SUBPAGES将被忽略，并缺省为1 +664 01540 分区索引的限制关键字超出了最大值 +738 01530 已命名的对象的更改可能像只读系统中对象的改变要求一样 +799 0157 SET语句中引用的特定寄存器不存在，将忽略 SET请求 +802 01519 数据溢出或者因除法异常而引起的数据异常错误 +806 01553 ISOLATION（RR）与LOCKSIZE PAGE 冲突 +807 01554 由于十进制乘法导致溢出 +863 01539 连接成功，但是只支持SBCS +2000 56094 SUBPAGES不等于1的1型索引不能成为数据共享环境中的缓冲池组依赖者 +2002 01624 因为指定的缓冲池不允许超高速缓存，GNPCACHE指定被忽略 +2007 01602 因为DB2子系统的参数禁用\"提示(hiats）\"所以不能指定优化提示 +30100 01558 分布式协议错误被检测到，提供原来的SQLCODE和SQLSTATE -007 42601 SQL语句中由非法字符 -010 42603 字符串常量非正常终止；检查到有遗漏的引号标志 -029 42601 需要ＩＮＴＯ语句 -060 42815 某特定数据类型的长度或者标量规范无效 -084 42612 不能执行ＳＱＬ语句，因为该语句对动态SQL无效或者对OS/390的DB2无效 -097 42601 在单位类型、用户自定义的函数以及过程中不能使用带有CAST的LONG VARCHAR或LONG VARGRAPHIC -101 54001 SQL语句超出了已确定的DB2限制：例如，表的数目太多，语句中的字节太多 -102 54002 字符串常量太长 -103 42604 无效数学文字 -104 42601 SQL语句中遇到非法符号 -105 42604 无效的字符串格式；通常引用一个格式不正确的图形字符串 -107 42622 对象名太长 -108 42601 RENAME语句中指定的名字有错误，不能使用限定词 -109 42601 指定了无效语句；例如CREATE VIEW不能包含ORDER BY 语句 -110 42606 遇到了无效的十六进制的文字 -111 42901 指定的列函数没有给出列名 -112 42607 无效的列函数语法；列函数不能运行与其他的列函数之上 -113 42602 遇到无效字符 -114 42961 该语句的位置名称必须与当前服务器匹配，但是却没有匹配 -115 42601 因为比较运算符没有伴着一个表达式或者列表，遇到了无效谓词 -117 42802 待插入的数值的个数于被插入的行中的列数不相等 -118 42902 数据修改语句(UPDATE或DELETE）和ＦＲＯＭ语句中的表和视图命名不合法 -119 42803 HAVING语句中的列的列表与GROUP BY语句中的列列表不匹配 -120 42903 不允许WHERE语句、SET语句、VALUES语句或者SET ASSIGNMENT语句引用列函数 -121 42701 在INSERT或UPDATE语句中，某一列被非法引用了两次 -122 42803 非法使用了列函数。因为没有用于一个列函数的所有列不再GROUP BY语句中 -123 42601 特定位置的参数必须是一个常数或者一个关键词 -125 42805 ＯＲＤＥＲ ＢＹ语句中指定了无效数字，该数字要么小于1要么大于选定的列数 -126 42829 不能为一个UPDATE语句指定ORDER BY语句 -127 42905 在子选择中DISTINCT只能指定一次 -128 42601 SQL谓词中NULL使用不当 -129 54004 SQL语句中包含的表多于15个 -130 22019 ESCAPE语句必须为一个字符 22025 无效的ESCAPE模式 -131 42818 LIKE谓词只能用于字符数据 -132 42824 LIKE语句、ESCAPE语句、LOCATE函数或POSSTR函数中有无效运算对象 -133 42906 无效相关子查询引用 -134 42907 大于255字节的列被不正确使用 -136 54005 排序关键字的长度大于4000字节 -137 54006 被连接的字符串太大；字符的最大值为32767；图形的最大值为16382 -138 22011 SUBSTR列函数的第二个或第三个操作符无效 -142 42612 不支持的SQL语句。该语句可能在另外的RDBMS上有效，也有可能在其他的上下文中有效 （例如，VALUES只能在触发器中出现） -144 58003 指定的段号无效 -147 42809 某一源函数不能更改。要改变源函数，必须删除该源函数并重新建立他 -148 42809 RENAME和ALTER无法执行。RENAME不能对视图或者活动RI.ST表重新命名。ALTER不能用 于改变列的长度，因为该列参与了RI、一个用户退出程序、全局的临时表或打开DATA CAPTURE CHANGES表的列 -150 42807 触发活动的INSERT，UPDATE或DELETE语句中指定了无效的视图更新或一个无效的转换表 -151 42808 试图更新一个不可更新的视图的列、一个DB2 CATALOG表的列或者一个ROWID列 -152 42809 DROP CHECK试图删除一个参照约束，或者DROP FOREIGN试图删除一个检查约束 -153 42908 无效的视图建立请求，必须为旋转列表中列出的列出的未命名的列或者重复的列提供一 个名字 -154 42909 不能用UNION、UNION ALL或者一个远程表建立视图 -156 42809 在视图上建立索引是非法的，或者在ALTER TABLE，CREATE TRIGGER，DROP TABLE或 LOCK TABLE语句上指定一个不是表的其他对象这是无效的 -157 42810 必须在FOREIGN KEY语句中指定一个表名 -158 42811 视图的列和选择列表中的列不相匹配 -159 42089 无效DROP或COMMENT ON语句 -160 42813 对该视图的WITH CHECK OPTION无效 -161 44000 正被更新的视图WITH CHECK OPTION语句使得这行不能被插入或更新 -164 42502 用户没有建立这个视图的权限 -170 42605 标量函数指定了无效的参数个数 -171 42815 标量函数指定了无效的数据类型长度或者无效数值 -173 42801 在非只读型的游标上不能指定隔离级别UR -180 22007 DATE、TIME、TIMESTAMP值的字符串表示法的语法不对 -181 22001 不是有效的DATE、TIME、TIMESTAMP值 -182 42816 在算术表达式中的日期/时间值无效 -183 22008 在算术表达式中返回的日期/时间值的结果不在有效值的范围内 -184 42610 没有正确使用日期/时间值的参数标记 -185 57008 没有定义本定的日期/时间出口 -186 22505 改变本定的日期/时间出口引发这个程序的长度无效 -187 22506 MVS返回无效的当前日期/时间 -188 22503 字符串表示无效 -189 22522 指定的编码字符集的ID无效或没有定义 -190 42837 不能象所设定的那样改变（ALTER）列。只能改变（ALTER）VARCHAR列的长度 -191 22504 字符串中包含了无效的混合数据 -197 42877 当两个或多个表被联合在一起排序时，限定的列名不能在ORDER BY语句中使用 -198 42617 试图对空的字符串发布一个PREPARE或EXECUTE IMMEDIATE语句 -199 42601 SQL语句中使用了非法关键词 -203 42702 模糊列引用 -204 42704 没有定义的对象名 -205 42703 指定的表的列名无效 -206 42703 列名没有在FROM语句所引用的任何表中，或者没有在定义触发器所在的表中 -208 42707 不能ORDER BY指定列，应为该列不在选择列表中 -212 42712 指定的表名在触发器中不允许多次使用，只能使用一次 -214 42822 DISTINCT、ORDER BY 引起的无效表达式 -219 42704 因为PLAN_TABLE不存在，EXPLAIN无法执行 -220 55002 遇到无效的PLAN_TABLE列 -221 55002 如果为PLAN_TABLE定义了可供选择的列，那么，必须定义所有的列 -229 42708 指定的现场找不到 -240 428B4 LOCK TABLE语句的PART子句无效 -250 42718 没有定义本地位置名 -251 42602 记号无效 -300 22024 宿主变量或参数中的字符串不是以NULL为终止 -301 42895 无效的宿主变量数据类型 -302 22001 输入的变量值对指定的列无效 22003 输入的变量值对指定的列而言太大 -303 42806 因为数据类型不兼容，不能分配数值 -304 22003 因为数据超出了范围，不能分配数值 -305 22002 没有NULL指示符变量 -309 22512 因为引用的宿主变量被设置成NULL，所以谓词无效 -310 22501 十进制的宿主变量或参数包含非十进制数据 -311 22501 输入的宿主变量长度无效，或者时负值或者太大 -312 42618 没有定义宿主变量或者宿主变量不可用 -313 07001 宿主变量的个数不等于参数标识的个数 -314 42714 模糊的宿主变量引用 -327 22525 在最后分区的关键字范围内，不能插入行 -330 22021 不能成功的翻译字符串 -331 22021 字符串不能分配到宿主变量，因为其不能成功的被翻译 -332 57017 不能为两个命名的编码字符集的ID定义翻译规则 -333 56010 子类型无效导致翻译失败 -338 42972 ON语句无效，必须引用连接的列 -339 56082 访问DB2 2.2版本的子系统被拒绝，原因时ASCII到EBCDIC翻译不能进行 -350 42962 无效的大对象规范 -351 56084 SELECT列表中有不支持的数据类型 -352 56084 输入列表中有不支持的数据类型 -355 42993 LOB列太大，以至不能被记录在日志中 -372 428C1 每个表只允许有一个ROWID列 -390 42887 在上下文中指定的函数无效 -392 42855 自从前一次FETCH以来，指定游标的SQLDA已被不恰当的改变 -396 38505 在最后的访问过程中，视图执行SQL语句 -397 428D3 在某一列上不恰当的指定了GENERATED因为该列不是ROWID数据类型 -398 428D2 为某一个宿主变量请求LOCATOR，但是该宿主变量不是一个LOB -399 22511 在INSERT语句中为ROWID列指定的值无效 -400 54027 在DB2编目中定义的用户自定义索引不能超过100个 -401 42818 算术操作符或比较操作符的操作对象不是兼容的 -402 42819 算术函数不能用于字符或日期时间数据 -404 22001 SQL语句指定的字符串太长 -405 42820 数值文字超出了范围 -406 22003 计算出的或者倒出的数值超出了范围 -407 23502 不能把NULL值插到定义为NOT NULL的列中 -408 42821 数值不能被更新或插入，因为他与列的数据类型不兼容 -409 42607 COUNT函数指定的运算对象无效 -410 42820 浮点文字笔30个字符的最大允许长度长 -411 56040 CURRENT SQLID使用无效 -412 42823 在子查询的选择列表中遇到了多个列 -413 22003 当转换为一个数字型数据类型时，数据溢出 -414 42824 LIKE谓词不能运行于用数字或日期时间类型定义的列 -415 42825 为UNION操作指定的选择列表不是联合兼容的 -416 42907 包含UNION操作符的SQL语句不允许有长的字符串列 -417 42609 两参数标识符作为运算对象被指定在同一谓词的两边 -418 42610 参数标识符使用无效 -419 42911 十进制除法无效 -420 22018 字符串自变量值不符合函数的要求 -421 42826 UNION操作的选择列表中没有提供相同数目的列 -423 0F001 为LOB或结果集定位器指定的值无效 -426 2D528 在不允许更新的应用服务器不允许执行COMMIT语句 -427 2D529 在不允许更新的应用服务器不允许执行ROLLBACK语句 -430 38503 在用户自定义的函数或存储过程中遇到了错误 -433 22001 指定的值太长 -435 428B3 无效的应用定义的SQLSTATE -438 xxxxx 使用了RAISE_ERROR函数的应用发出了一个错误 -440 42884 存储过程或用户自定义函数的参数列表参数个数于预期的个数不匹配 -441 42601 与标量函数一起使用DISTINCT或ALL是不正确的用法 -443 42601 指定的外部函数返回错误的SQLSTATE -444 42724 与被称为存储过程或用户自定义函数有关的程序不能找到 -449 42878 对存储过程或用户自定义的 函数，CREATE或ALTER语句不正确（缺失EXTERNAL NAME 子 句) -450 39501 存储过程或用户自定义函数写入存储器的值超过了参数声明的长度 -451 42815 CREATE FUNCTION中指定了不正确的数据类型 -453 42880 用户自定义函数中的RETURNS语句无效 -454 42723 指定的函数识别标记与已存在的另一函数的识别标记冲突 -455 42882 模式名不比配 -456 42710 为用户自定义函数指定的函数名已经存在 -457 42939 用户自定义函数或用户自定义类型正试图使用系统中定义的函数或者类型所用的名称 -458 42883 没有找到函数 -463 39001 特定的外部例程返回无效的SQLSTATE -469 42886 参数定义为OUT或INOUT的CALL语句必须提供宿主变量 -470 39002 指定了NULL参数，但是该例程却不支持NULL -471 55023 存储过程或用户自定义函数失败：提供原因代码 -472 24517 外部的函数程序使游标处于打开状态 -473 42918 用户自定义数据类型命名不能和系统定义的数据类型一样 -475 42866 结果类型不能被转换成RETURNS类型 -476 42725 在其模式中该函数不是独一无二的 -478 42893 不能DROP或REVOKE特定的对象，因为其他对象依赖于该对象 -480 51030 直到存储过程已经被CALL后，DESCRIBE PROCEDURE和ASSOCIATE LOCATORS才能被发布 -482 51030 存储过程不返回到任何一个定位器 -483 42885 CREATE FUNCTION语句中的参数个数与源函数中的参数个数不匹配 -487 38001 选择了NO SQL选项建立指定的存储过程或用户自定义函数，但却视图发布SQL语句 CREATE FUNCTION语句无效，因为该语句没有RETURNS语句或者因为该语句没有指定有效 -491 42601 的SOURCE或者EXTERNAL语句 -492 42879 指定函数的指定参数的个数有错误 -495 57051 语句的估计处理器成本超出了资源限制 -496 51033 语句无法执行，因为当前服务器与调用存储过程的服务器不同 指定的数据库超过了32767 OBID的上限，或者CREATE DATABASE语句使之达到了32511 -497 54041 DBID的上限 -499 24516 指定的游标已被分配到结果集，该结果集来自已经指定的存储过程 -500 24501 因为连接被破坏，WITH HOLD游标被关闭 -501 24501 在试图获取数据或关闭一个游标前必须打开一个游标 -502 24502 在没有关闭游标前不能再次打开游标 因为列在游标的FOR UPDATE OF语句中没有被指定，该游标用于获取该列，所以不能更 -503 42912 新该列 -504 34000 不能引用一个游标，因为他不是定义到程序里的 -507 24501 在试图更新或者删除WHERE CURRENT OF前，必须打开游标 -508 24504 因为被引用的游标当前不是处于数据行上，所以不能被更新或删除 除了在游标上指定的那个表（该表由WHERE CURRENT OF语句引用的）以外，再也不能从 -509 42827 别的表上更新数据 -510 42828 表或视图不能被修改 -511 42829 对不可修改的表或视图，FOR UPDATE OF语句无效 -512 56023 对远程对象的无效引用 -513 42924 一个别名不能再被定义成另外的别名 -514 26501 游标尚没有被准备 -516 26501 试图描述未准备好的SQL语句 -517 07005 因为SQL语句尚没有准备好，游标无效 -518 07003 试图执行尚没有准备好的SQL语句 -519 24506 当为游标的SQL语句发布一个准备语句是，游标不能是打开的 -525 51015 不能在已指定的程序包中执行SQL语句，因为在绑定时间内该程序包无效 -526 42995 在给定的上下文中，不能使用全局的临时表 -530 23503 对特定的约束名指定了无效的外健值 从版本5开始，父关键字的多行更新将试图删除一个外关键字依赖的父关键字值，在版 -531 23504 本5以前，当引用主关键值外健值当前存在时，试图更新该主健值 -532 23504 删除操作违反了已指定的参照约束 -533 21501 多行插入无效，试图将多行插到自我引用的表中 -534 21502 可改变主健列值的更新语句不能在同一时刻用于更新多行 当从自我引用表中删除数据或者更新主健列时，不能指定WHERE CURRENT OF。不是版本 -535 21502 5的子系统才调用该代码 -536 42914 因为某一特定表的参照约束存在，所以删除语句无效 -537 42709 在外健语句或主健语句的规范中，每个列的出现不能多于一次 -538 42830 无效的外健；不符合引用的表没有主健 -539 42888 不能定义外健，因为被引用的表没有主健 表定义不完整，直到为主健建立了唯一索引或UNIQUE语句、或者包含GENERATED BY -540 57001 DEFAULT属性的ROWID列 -542 42831 可以为空的列不允许作为主健的一部分包含在内 因为该表是指定了SET NULL删除规则的参照约束的父表而且检查约束不允许NULL，所以 -543 23511 DELETE不能发生 -544 23512 不能用ALTER添加检查约束，因为已存在的某行与该检查约束冲突 -545 23513 INSERT或者UPDATE导致检查约束冲突 -546 42621 在CREATE或ALTER TABLE中指定的检查约束无效 -548 42621 因为指定的列而引起的检查约束无效 -549 42509 DYNAMICRULES（BIND）计划或程序包的无效SQL语句 -551 42501 用户试图对不拥有权限的特定的对象进行操作，或者表不存在 -552 42502 用户试图执行未被授权的操作 -553 42503 不能指定CURRENT SQLID，因为用户尚没有被允许改变那个ID -554 42502 不能对你本身赋予一个权限 -555 42502 不能对你本身撤销一个权限 -556 42504 不能撤销用户没有拥有的权限 -557 42852 指定了不一致的授予或撤销关键词 -558 56025 为授予或撤销语句指定了无效的语句（一个或一组） -559 57002 DB2权限机制已经禁用，授予或者撤销不能被发布 -567 42501 指定的权限ID缺少对指定的程序包的绑定权限 -571 25000 不允许多点更新 -573 42890 不能定义参照约束，因为已指定的父表中在指定的列上没有唯一健 -574 42864 指定的缺省与列定义冲突 试图修改用户自定义函数中的数据或者存储过程中的数据，但这些对象的建立没有选择 -577 38002 MODIFIES SQL DATA选项 试图修改用户自定义函数中的数据或者存储过程中的数据，但这些对象的建立没有选择 -579 38004 READ SQL DATA选项，也没有选择MODIFIES SQL DATA选项 -580 42625 CASE表达式中的结果表达式不能都是空的 -581 42804 CASE表达式中的结果表达式为不兼容的数据类型 -582 42625 SEARCHED－WHEN－CLAUSE中的查找条件指定了一个限定的、IN或EXISTS谓词 -583 42845 指定的函数失败，因为他不是决定性的，或者可能有外部动作 -585 42732 在当前路径中模式名不止一次出现 -586 42907 CURRENT PATH专用寄存器在长度上不能超过254字符 -587 428C6 项目引用的列表必须是同一个家族 -590 42734 在命名的存储过程或用户自定义的函数中的参数必须是独一无二的 -592 42510 没有授权权限，让你在WLM环境中建立的存储过程或者用户自定义函数 -601 42710 试图创建（或重命名）已经存在的对象 -602 54008 CREATE INDEX语句中指定的列太多 -603 23515 因为发现有重复值，所以不能建立唯一的索引 -604 42611 在CREATE或ALTER TABLE语句中的为数据类型指定的长度、精度以及标度无效 指定的INSERT、UPDATE或DELETE语句不能被发布，应为这些语句对DB2 CATLOG表执行写 -607 42832 操作 -611 53088 当LOCKSIZE是TABLE或者TABLESPACE时，LOCKMAX必须为0 -612 42711 在同一个表、索引或试图中不允许有重复列名 -613 54008 主健或UNIQUE约束太长或者包含了太多的列 -614 54008 已经超过了索引的内部健长度的最大长度（255）限制 -615 55006 不能删除这个程序包，因为该程序包目前正在执行","tags":"db2","loc":"http://sndnyang.github.io/db2_sqlcode.html","title":"DB2_sqlcode"},{"text":"﻿% tar 命令说明 % 杨秀隆 % 2014年5月13日 修订 tar 命令 基本参数 -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 -z：有gzip属性的 -j：有bz2属性的 -Z：有compress属性的 -v：显示所有过程 -O：将文件解开到标准输出 下面的参数-f是必须的 -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 tar -cf all.tar *.jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 tar -rf all.tar *.gif 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思 tar -xf all.tar 这条命令是解出all.tar包中所有文件，-x是解开的意思 压缩 tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg tar –czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2 tar –cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 解压 tar –xvf file.tar //解压 tar包 tar -xzvf file.tar.gz //解压tar.gz tar -xjvf file.tar.bz2 //解压 tar.bz2 tar –xZvf file.tar.Z //解压tar.Z unrar e file.rar //解压rar unzip file.zip //解压zip 总结 1、*.tar 用 tar –xvf 解压 2、*.gz 用 gzip -d或者gunzip 解压 3、 .tar.gz和 .tgz 用 tar –xzf 解压 4、*.bz2 用 bzip2 -d或者用bunzip2 解压 5、*.tar.bz2用tar –xjf 解压 6、*.Z 用 uncompress 解压 7、*.tar.Z 用tar –xZf 解压 8、*.rar 用 unrar e解压 9、*.zip 用 unzip 解压","tags":"shell","loc":"http://sndnyang.github.io/tar_ya-suo.html","title":"tar_压缩"},{"text":"ksh 判断 一. 基础比较 运算符号代表意义 = 等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串 != 不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串 < 小于 应用于：整型比较 在[] 中，不能使用 表示字符串 > 大于应用于：整型比较 在[] 中，不能使用 表示字符串 -eq 等于 应用于：整型比较 -ne 不等于 应用于：整型比较 -lt 小于 应用于：整型比较 -gt 大于 应用于：整型比较 -le 小于或等于 应用于：整型比较 -ge 大于或等于 应用于：整型比较 -a 双方都成立（and） 逻辑表达式 –a 逻辑表达式 -o 单方成立（or） 逻辑表达式 –o 逻辑表达式 -z 空字符串 -n 非空字符串 逻辑的『和(and)』『或(or)』 && 逻辑的 AND 的意思 || 逻辑的 OR 的意思 二. 特殊比较 关于档案与目录的侦测逻辑卷标！ -f 常用！侦测『档案』是否存在 eg: if [ -f filename ] -d 常用！侦测『目录』是否存在 -b 侦测是否为一个『 block 档案』 -c 侦测是否为一个『 character 档案』 -S 侦测是否为一个『 socket 标签档案』 -L 侦测是否为一个『 symbolic link 的档案』 -e 侦测『某个东西』是否存在！ 关于程序的逻辑卷标！ -G 侦测是否由 GID 所执行的程序所拥有 -O 侦测是否由 UID 所执行的程序所拥有 -p 侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！） 关于档案的属性侦测！ -r 侦测是否为可读的属性 -w 侦测是否为可以写入的属性 -x 侦测是否为可执行的属性 -s 侦测是否为『非空白档案』 -u 侦测是否具有『 SUID 』的属性 -g 侦测是否具有『 SGID 』的属性 -k 侦测是否具有『 sticky bit 』的属性 两个档案之间的判断与比较；例如[ test file1 -nt file2 ] -nt 第一个档案比第二个档案新 -ot 第一个档案比第二个档案旧 -ef 第一个档案与第二个档案为同一个档案（ link 之类的档案）","tags":"shell","loc":"http://sndnyang.github.io/ksh_judge.html","title":"ksh_judge"},{"text":"﻿ 配合 tag 文件可以实现定义跳转。 :tags\" 命令显示你经过的标签列表： 下面的命令跳转到标签列表中最上面的标签： :tag 你可以在前面加上要向前跳转的标签个数。比如：\":3tag\"。 CTRL-T 同样可以加上一个 计数参数。 :stag tagname 使用下面的命令可以分割当前窗口并跳转到光标下的标签: CTRL-W ] 你现在可以跳转到同一个标签的其它匹配处： :tnext 重复执行这个命令可以找到更多的匹配。如果存在很多匹配，你可以选择要跳转到哪一 个： :tselect tagname 你现在可以输入要跳转到的匹配代号（在第一列）。其它列的信息可以让你知道匹配在何 处被定义。 可以用这些命令在各匹配的标签间移动： :tfirst 到第一个匹配 :[count]tprevious 向前 [count] 个匹配 :[count]tnext 向后 [count] 个匹配 :tlast 到最后一个匹配 如果没有指定，[count] 省缺为一。 猜 测 标 签 名 命令行补全是避免输入长标签名的好办法。只需输入开始的一部分然后按 ： :tag write_ 你会得到第一个匹配。如果这不是你想要的，重复输入 直到你找到正确的匹配。 有时你只知道一个函数名的一部分，或是你有很多以相同字符串开头而结尾不同的标 记。这时你可以告诉 Vim 使用一个模式来查找标签。 假设你要跳转到一个包含 \"block\" 的标签。首先输入： :tag /block 现在再利用命令行补全功能：输入 。Vim 会找到所有包含 \"block\" 的标签并使用 第一个匹配。 标签名前面的 \"/\" 告诉 Vim 这不是一个确定的标签名而是一个模式。你可以利用有 关查找模式的所有特性。举个列子，假设你要选择所有以 \"write_\" 开头的标签： :tselect /&#94;write_ \"&#94;\" 指定标签以 \"write_\" 开头，否则在中间含有 \"write_\" 的标签名也会被找到。类似 地，\" FCKpd 0quot; 指定标签名结尾处的匹配。 标 签 浏 览 器 CTRL-] 可以让你跳转到光标所在标识符的定义处，因此你可以利用标识符的列表来形成 一个目录。这里给出一个例子。 首先生成一个标识符列表（需要 Exuberant ctags)： ctags --c-types=f -f functions .c 现在打开 Vim 并在一个垂直分割窗口中编辑这个文件： vim :vsplit functions 窗口中包含一个所有函数的列表。其它的东西可以被忽略。用 \":setlocal ts=99\" 命令 使其显示得更清晰些。 在这个窗口中，定义一个 mapping： :nnoremap 0yew:tag \" 移动光标至要跳转到函数的所在行，输入 。Vim 会在另一个窗口中跳转到所选择 的函数定义处。 相 关 杂 项 你可以设定 'ignorecase' 选项来忽略标签名里的大小写。 'tagbsearch' 选项标明标签文件是否经过排序。省缺是假定为标签文件已排序，这样会 使查找更快，但如果文件没有被排序是无法工作的。 'taglength' 选项可用来告诉 Vim 一个标签的有效字符个数。 当你使用 SNiFF+ 程序时，你可以利用 Vim 的有关接口 |sniff| 。SNiFF+ 是一个商业 软件。 Cscope 是一个自由软件。它不仅可以找到一个标识符被声明的地方，还可以找到标识符 被使用的地方。 请参考 |cscope|。 29.2 预览窗口 当编辑含有函数调用的代码时，你需要使用正确的调用参数。要获知所要传递的值，你可以 查看这个函数是如何定义的。标签机制对此十分适用。如果定义可在另一个窗口内显示那 就更好了。对此我们可以利用预览窗口。 打开一个预览窗口来显示函数 \"write_char\"： :ptag write_char Vim 会打开一个窗口，跳转到 \"write_char\" 标签。然后它会回到原来的位置。这样你可 以继续输入而不必使用 CTRL-W 命令。 如果函数名出现在文本中，你可以用下面的命令在预览窗口中得到其定义： CTRL-W } 有一个脚本可以自动显示光标处的标签定义。请参考 |CursorHold-example| 。 用下面的命令关闭预览窗口： :pclose 要在预览窗口中编辑一个指定的文件，用 \":pedit\" 。这在编辑头文件时很有用，比如： :pedit defs.h 最后， \"psearch\" 可用来查找当前文件和任何包含文件中的单词并在预览窗口中显示匹 配。这在使用没有标签文件的库函数时十分有用。例如： :psearch popen 这会在预览窗口中显示含有 popen() 原型的 \"stdio.h\" 文件： FILE popen __P((const char , const char )); 你可以用 'previewheight' 选项指定预览窗口打开时的高度。 29.3 在代码间移动 因为程序代码是结构化的，Vim 可以识别其中的有关项目。一些特定的命令可用来完成相 关的移动。 C 程序中经常包含类似下面的代码： #ifdef USE_POPEN fd = popen(\"ls\", \"r\") #else fd = fopen(\"tmp\", \"w\") #endif 有时会更长，也许还有套嵌。将光标置于 \"#ifdef\" 处按 %。Vim 会跳转到\"#else\"。继 续按 % 会跳转到 \"#endif\"。再次按下 % 又回到原来的 \"#ifdef\"。 当代码套嵌时，Vim 会找到相匹配的项目。这是检查你是否忘记了一个 \"#endif\" 的 好办法。 当你在一个 \"#ifdef\" - \"#endif\" 块内的某个位置，你可以用下面的命令回到开始 处： [# 如果你的位置不是在 \"#if\" 或 \"#ifdef\" 之后, Vim 会鸣音。用下面命令可以跳转到下 一个 \"#else\" 或 \"#endif\"： ]# 这两个命令会跳过它所经过的 \"#if\" - \"#endif\" 块。 例如： #if defined(HAS_INC_H) a = a + inc(); # ifdef USE_THEME a += 3; # endif set_width(a); 如果光标在最后一行，\"[#\" 会移动到第一行。中间的 \"#ifdef\" - \"#endif\" 块被跳过。 在 代 码 块 内 移 动 C 代码块包含在 {} 中，有时一个代码会很长。要跳转到外部代码块的开始处，用 \"[[\" 命令。用 \"][\" 找到结尾处。（前提是 \"{\" 和 \"}\" 都在第一列。） \"[{\" 命令跳转到当前代码块的开始处。它会跳过同一级别的 {} 对。\"]}\" 跳转到结尾。 一点概述： function(int a) +-> { | if (a) | +-> { [[ | | for (;;) --+ | | +-> { | | [{ | | foo(32); | --+ | | [{ | if (bar(a)) --+ | ]} | +-- | +-- break; | ]} | | | } } | [] | int func2(void) | +-> { | [[ | if (flag) start +-- +-- return flag; | ][ | return 2; | +-> } ]] | | int func3(void) +----------> { return 3; } 不要忘了你还可以用 \"%\" 在匹配的 (), {} 和 [] 间移动。这在它们相距很多行时仍然 适用。 在 括 号 内 移 动 \"[(\" 和 \"])\" 命令\"[}\" 和 \"]}\" 类似，只不过它们适用于 () 对而不是 {} 对。 [( f)) && x > y) --------------> --------------------------------> ]) 在 注 释 间 移 动 移动到一个注释的开始用 \"[/\"；向前移动到注释的结尾用 \"]/\"。这只对 / - / 注释 有效。 +-> +-> / | [/ | * A comment about --+ [/ | +-- * wonderful life. | ]/ | / vim.h --> 文件 \"io.h\" 被当前文件包含但无法找到。\"vim.h\" 可以找到，这样 \":checkpath\" 跟进 这个文件并检查其中的包含文件。结果显示无法找到 \"vim.h\" 包含的 \"functions.h\" 和 \"clib/exec_protos.h\" 文件。 Note: Vim 不是一个编译器。它无法识别 \"#ifdef\" 语句。这就是说所有的 \"#include\" 语句都会被使用，即使它在 \"#if NEVER\" 之后。 给 'path' 选项增加一个目录可以修正无法找到文件的错误。一个好得参考是 Makefile。 注意那些包括 \"-I\" 的条目，比如 \"-I/usr/local/X11\"。要增加这个目录，用： :set path+=/usr/local/X11 如果有很多的子目录，你可以用 \" \" 通配符。例如： :set path+=/usr/ /include 这会找到 \"/usr/local/include\" 以及 \"/usr/X11/include\" 目录下的文件。 如果你的工程项目的包含文件都在一个套嵌的目录树下，\" \" 就非常有用。它会搜索所 有的子目录。例如： :set path+=/projects/invent/ /include 这会找到这些目录下的文件： /projects/invent/include /projects/invent/main/include /projects/invent/main/os/include etc. 还有其它的可能性。更多信息，请查看 'path' 选项。 如果你想查看找到的包含文件，用这个命令： :checkpath! 你会得到一个（很长）的包含文件列表。为使它更短些，Vim 会对已经找到的文件显示 \"(Already listed)\" 而不再重新显示一遍","tags":"vim","loc":"http://sndnyang.github.io/tag_tips.html","title":"tag_tips"},{"text":"% pandoc 使用 pandoc --latex-engine=pdflatex|lualatex|xelatex命令。","tags":"markdown","loc":"http://sndnyang.github.io/pandoc.html","title":"pandoc"},{"text":"﻿% JDBC连接DB2数据库 1. db2数据库驱动的安装 方法: 安装db2客户端 db2的jdbc驱动放到jdk，jre或者tomcat的common/lib目录下 db2的数据库驱动 COM.ibm.db2.jdbc.app.DB2Driver COM.ibm.db2.jdbc.net.DB2Driver 通用驱动程序 前两种在db2java.zip文件中，可以把他改名成db2java.jar文件使用。 第三种放在文件db2jcc.jar文件中 驱动的程序加载和连接建立方法： Class.forName(\"COM.ibm.db2.jdbc.app.DB2Driver\"); Class.forName(\"COM.ibm.db2.jdbc.net.DB2Driver\"); Class.forName(\"com.ibm.db2.jcc.DB2Driver\"); 连接例子可以相同，都是指定主机，端口和数据库名称 String dbUrl = \"jdbc:db2://localhost:6789/sample\" ; con = DriverManager . getConnection ( dbUrl , \"www\" , \"123456\" ); 示例 Class.forName ( \"COM.ibm.db2.jdbc.app.DB2Driver\" ); //注册驱动程序 //DriverManager.registerDriver(new COM.ibm.db2.jdbc.app.DB2Driver()); //用适当的驱动程序连接到数据库 //指定db2的url，注意格式，6789是端口，mytest是数据库名 String dbUrl = \"jdbc:db2://localhost:6789/sample\" ; con = DriverManager.getConnection ( dbUrl , \"www\" , \"123456\" ); //创建一个JDBC声明 stmt = con.createStatement (); //增加新记录 //stmt.executeUpdate(\"INSERT INTO books (id,name,title,price) VALUES ('999','Tom','Tomcat Bible',44.5)\"); //查询记录 rs = stmt.executeQuery ( \"select * from test\" ); //输出查询结果 out.println ( \"<table border=1 width=400>\" ); while ( rs.next ()) { String col1 = rs.getString ( 1 ); String col2 = rs.getString ( 2 ); String col3 = rs.getString ( 3 ); String col4 = rs.getString ( 4 ); //打印所显示的数据 out.println ( \"<tr><td>\" + col1 + \"</td><td>\" + col2 + \"</td><td>\" + col3 + \"</td><td>\" + col4 + \"</td></tr>\" ); } out.println ( \"</table>\" ); //关闭数据库连结 rs.close (); stmt.close (); con.close ();","tags":"db2","loc":"http://sndnyang.github.io/db2jdbc.html","title":"db2jdbc"},{"text":"﻿# vi 小技巧 vi +xx 文件名，可以直接跳到位置的， 和vim一样。xx代表行数 查找时， \\<xxx> 代表全词匹配——vim也一样，而且更先进的是，当光标在该单词上时，vim快捷键shift+8就是向下查找，shift+3就是向上查找。","tags":"vim","loc":"http://sndnyang.github.io/vi_tips.html","title":"vi_tips"},{"text":"% 共享文件夹加载 进入系统，安装增强功能，安装完关闭系统。 在E盘下创建一个共享文件夹 gongxiang。 设置->数据空间->固定分配，选择共享文件夹路径，注意此时不要勾选自动挂载，如下图所示。 重新启动系统 执行如下命令，就可以看到共享文件夹下面的文件。 huang@huang-VirtualBox:~$ sudo mount -t vboxsf gongxiang /mnt/shared/","tags":"vbox","loc":"http://sndnyang.github.io/share_folder.html","title":"share_folder"},{"text":"﻿# dot 入门 基本样式 digraph Name{ nodes_list; edge_list ; a -> b ; b -> c ; } 属性设置 label 节点的label属性支持类似于HTML语言中的TABLE形式的定义，通过行列的数目来定义节点的形状，从而使得节点的组成更加灵活。 bgcolor fontname fontsize rankdir // 这个是什么 定义顶点和边的样式 在digraph的花括号内，添加顶点和边的新定义： node [shape=\"record\", style=\"filled\", color=\"black\", fillcolor=\"chartreuse\"]; edge [style=\"dashed\", color=\"\"]; 可以针对特定结点和页进行设置。 子图绘制 subgraph cluster_name { } 复杂标签 st \\ _table [ label = \"{st\\_table|<type>type|num\\_bins|num\\_entries|<bins>bins}\" ] ; st\\_table:bins -> st\\_table\\_entry:head; label 使用{}, 将多个标签用|分隔开 <> 锚点，用于后期某个位置 指向某个位置 结点位置关系 使用rank {rank = same; node1; node2; nodes_list} 并排 使用隐藏线 node1 -> node2 [style = invis] 不可见的结点先后顺序","tags":"graphviz","loc":"http://sndnyang.github.io/dot.html","title":"dot"},{"text":"% windows下配置git bash 显示中文 显示中文文件名 1、C:\\Program Files\\Git\\etc\\git-completion.bash： alias ls='ls --show-control-chars --color=auto' 说明：使得在 Git Bash 中输入 ls 命令，可以正常显示中文文件名。 输入中文 2、C:\\Program Files\\Git\\etc\\inputrc： set output-meta on set convert-meta off 说明：使得在 Git Bash 中可以正常输入中文，比如中文的 commit log。 3、C:\\Program Files\\Git\\etc\\profile： export LESSCHARSET=utf-8 说明：$ git log 命令不像其它 vcs 一样，n 条 log 从头滚到底，它会恰当地停在第一页，按 space 键再往后翻页。这是通过将 log 送给 less 处理实现的。以上即是设置 less 的字符编码，使得 $ git log 可以正常显示中文。其实，它的值不一定要设置为 utf-8，比如 latin1 也可以……。还有个办法是 $ git –no-pager log，在选项里禁止分页，则无需设置上面的选项。 4、C:\\Program Files\\Git\\etc\\gitconfig： [gui] encoding = utf-8 说明：我们的代码库是统一用的 utf-8，这样设置可以在 git gui 中正常显示代码中的中文。 [i18n] commitencoding = GB2312 说明：如果没有这一条，虽然我们在本地用 $ git log 看自己的中文修订没问题，但，一、我们的 log 推到服务器后会变成乱码；二、别人在 Linux 下推的中文 log 我们 pull 过来之后看起来也是乱码。这是因为，我们的 commit log 会被先存放在项目的 .git/COMMIT_EDITMSG 文件中；在中文 Windows 里，新建文件用的是 GB2312 的编码；但是 Git 不知道，当成默认的 utf-8 的送出去了，所以就乱码了。有了这条之后，Git 会先将其转换成 utf-8，再发出去，于是就没问题了。","tags":"git","loc":"http://sndnyang.github.io/git_bash.html","title":"git_bash"},{"text":"配置远程数据库 1. 执行db2 catalog tcpip node 节点名 remote xx.xx.xx.xx server 50000 执行db2 list node directory show detail，显示可用的节点，确认NODECRM已加入成功 db2 catalog db xxxx as 别名 at node 节点名 执行InitDbKey,输入数据库用户名和密码（见上） 执行db2 connect to xxxx GetDbKey xxxx ,验证一下是否能正常连接数据库 进到sqldb2.bnd文件所在的目录(一般在~/bnd/ORCHID下,执行 db2 bind sqldb2.bnd","tags":"db2","loc":"http://sndnyang.github.io/db2pei-zhi-yuan-cheng-shu-ju-ku.html","title":"db2配置远程数据库"},{"text":"windows、linux、aix 查询端口号占用情况 一、windows 方法一 提升权限后 netstat - b 方法二 查询端口占用的进程ID netstat - a - n 各个端口占用 netstat - ano 各个端口占用和进程 PID 示例： netstat -aon | findstr \"80\" TCP 127.0.0.1 : 9080 0.0.0.0 : 0 LISTENING 4632 查看端口号所对应的应用程序 tasklist | findstr \" 4632\" 终止进程 1. taskkill / pid 4632 / F 2. taskkill / f / t / im GROOVE . exe 再次查询是否成功终止 tasklist | findstr \"4632\" 如果成功终止此次执行命令后应返回空.，则表示成功，终止 PID 为 4632 的进程。 二、Linux 方法一: 1.查询端口号占用，根据端口查看进程信息 [ root @ server2 ~ ] # lsof - i : 80 2.根据进程号查看进程对应的可执行程序 ps - f - p 进程号 方法二: 根据端口号得到其占用的进程的详细信息 netstat - tlnp | grep 80 根据端口号查询，查询其占用进程ID netstat -tlnp|grep 80|awk '{print $7}'|awk -F '/' '{print $1}' 或是用下面的命令 netstat - pan | grep 80 三、AIX 命令: netstat - Aan | grep 80 例如: 获得25号端口的PCB(protocol control block), 且查看协议为tcp. (输出信息中第一列即是PCB) netstat -Aan |grep 25 f100070000d373b0 tcp4 0 0 .25 . LISTEN f100070000d25600 udp 0 0 . . f100070000d25400 udp 0 0 . . f100070000d25000 udp 0 0 . . f100070000d25c00 udp 0 0 127.255.255.255.12 . f100070000d2d200 udp 0 0 10.10.10.255.123 . f100070000d25a00 udp4 0 0 .514 . f100070000d25200 udp4 0 0 .517 .* 如果是tcp连接,那么# rmsock tcpcb 如果是udp连接,那么# rmsock inpcb rmsock f100070000d373b0 tcpcb The socket 0xd37008 is being held by proccess 213096 (sendmail). 结果显示25号端口正在被sendmail进程使用，PID为213096.","tags":"shell","loc":"http://sndnyang.github.io/duan-kou-jian-ting.html","title":"端口监听"},{"text":"设置KSH的自动补全和历史命令功能 - 方法一： set - o vi 历史命令功能（esc -，esc +）自动补全文件名（esc \\）。 - 方法二： set - o emacs 历史命令功能（ctrl-n，ctrl-p），自动补全文件名(按两次esc)。 找不到自动补全命令的功能，还是bash比较人性化。","tags":"shell","loc":"http://sndnyang.github.io/kshzi-dong-bu-quan.html","title":"KSH自动补全"},{"text":"ksh profile常用配置 stty erase &#94;H 按Backspace键可以向后删除字符， 输入stty erase ctrl+v ctrl+h set -o vi 让输入行工作于vi模式,则可以使用vi专用指令了 可以使用 set -o emacs， 则是使用emacs指令 TERM=vt100 这样在异地登录的用户方可使用vi 各人各用， 这条不要用，除非我不用的环境…… PS1= /usr/ucb/whoami \"@\" hostname :${ORACLE_SID}\"$\";export PS1 包含登陆用户、主机名、数据库SID的提示符 EDITOR=vi;export EDITOR 不设置则无法crontab -e crontab HISTSIZE=200;export HISTSIZE 保存的历史命令数 LANG=zh_CN.GBK;export LANG; 让系统显示中文信息, 已有 stty -istrip cs8 将所有的输入截取成8bits的资料，因为中文的资料都是8bits的 未使用过 LC_CTYPE=zh_CN.GBK;export LC_CTYPE 让系统可以使用中文 未使用过 alias history='fc -l' 显示历史命令 可能还是原命令短一点，但是history好记 alias r='fc -e -' 重复执行最后一条命令, 慎用","tags":"shell","loc":"http://sndnyang.github.io/profileshe-zhi.html","title":"profile设置"},{"text":"shell文件 文件存在 if [[ -e $filename ]]","tags":"shell","loc":"http://sndnyang.github.io/shell_file.html","title":"shell_file"},{"text":"shell 字符串变量中的空格 示例： x = \" dokjd \" 保留全部空格： echo \"$x\" 去除头尾空格: echo $ x","tags":"shell","loc":"http://sndnyang.github.io/shellbian-liang-kong-ge.html","title":"shell变量空格"},{"text":"﻿ if else elif shell 或者说 ksh 的else if 使用 elif 写法， 简洁易用的写法 示例: if [[ x - eq \"3456\" ]] then echo \"3456\" elif [[ x - eq \"4567\" ]] then echo \"4567\" elif [[ x - eq \"1234\" ]] then echo \"1234\" else echo \"none\" fi","tags":"shell","loc":"http://sndnyang.github.io/if_else_elif.html","title":"if_else_elif"},{"text":"﻿ DB2 统计行号, 行数 ROWNUMBER () OVER () as ROW 不能用之作为group 的条件。","tags":"db2","loc":"http://sndnyang.github.io/tong-ji-xing-hao.html","title":"统计行号"},{"text":"﻿ db2 查询本机数据库（本地及远程） db2 \"list db directory\" 显示本机数据库列表 db2 list node directory show detail 查询该节点的详细信息 引用内容: db2 Catalog 2012 - 10 - 19 13 : 57 : 49 | 分类： DB2 | 标签： | 字号大中小 订阅 . 在 DB2 中从客户端访问服务器端的数据库时，不能直接用 connect 命令，而必须先建立通信 node ，再在 node 的基础上建立数据库连接。在命令行的具体操作如下： -> db2 catalog tcpip node $ { nodeName } remote $ { serverName } server $ { portNumber } -> db2 catalog db $ { dbName } as $ { dbAlias } at node $ { nodeName } -> db2 connect to $ { dbAlias } user $ { userName } using $ { passWord } -> db2 terminate 说明 : $ { nodeName } ：任意起的一个结点名 , 注意长度限制 $ { serverName } ：远程数据库所在服务器名称或 IP 地址 $ { portNumber } ：远程数据库端口号 $ { dbName } ：远程数据库的名字 $ { dbAlias } ：编目到本地后的数据库别名 $ { userName } ：连接数据库用户名 $ { passWord } ：连接数据库密码 其他相关一些重要的 DB2 命令 1 . 查看本地节点目录 命令窗口中输入： db2 list node directory 2 . 编目一个 TCP / IP 节点 命令窗口： db2 catalog tcpip node < node_name > remote < hostname | ip_address > server < svcname | port_number > ostype < OS2 | AIX | WIN95 | NT | HPUX | SUN | MVS | OS400 | VM | VSE | SCO | SGI | LINUX | DYNIX > 3 . 取消节点编目 db2 uncatalog node < node_name > 4 . 查看系统数据库目录 db2 list database directory 5 . 查看本地数据库目录 db2 list database directory on < 盘符 > 在本地数据库目录中有而系统数据库目录中没有的数据库不能访问，可以在控制中心中选中 < 数据库 > 右键单击选择添加，然后输入需要添加的数据库名称或者点击刷新按钮选择数据库，加入数据库后即可以访问。 6 . 编目数据库 db2 catalog database < db_name > as < db_alias > at node < node_name > 7 . 取消数据库编目 db2 uncatalog database < db_name > 8 . 测试远程数据库的连接 db2 connect to < db_alias > user < user_id > using < password >","tags":"db2","loc":"http://sndnyang.github.io/db2cha-xun-ben-ji-shu-ju-ku.html","title":"db2查询本机数据库"},{"text":"db2 导出数据 基本形式: export to filename of del select * from table_name 配置选项 of del 后添加 modified by coldel$ coldel表示字段之间的间隔符，默认情况为逗号 chardel'' chardel表示字符串字段用什 么符号引用，默认情况下为一对双引号括起来， 不使用即为 nochardel decplusblank decplusblank表示对于十进制数据类型，用空格代替最前面的加号 codepa A delimiter is not valid or is used more than once. ge=1208 如果coldel使用 | 或出现 A delimiter is not valid or is used more than once时使用","tags":"db2","loc":"http://sndnyang.github.io/db2_export.html","title":"db2_export"},{"text":"﻿ java 乱码简要总结","tags":"java","loc":"http://sndnyang.github.io/java_luan-ma.html","title":"java_乱码"},{"text":"MarkDown 笔记 小细节记录 非MarkDown的部分，可直接写HTML < div >, < table>, < pre>, < p> 前后要加空行，不能使用空格等来缩进 HTML区块（block)标签内的MarkDown不做语法处理。 区段（inline)标签则随意，比如 < span>, < cite>, < del> 一、 区块元素 1. 段落和换行 段落前后有一个以上空行（一般自然就是前后各空一行），不能用空格或制表符来缩进。 2. 标题 类Setext 底线形式，只有＝（最高阶标题）和－（第二阶标题） 类Atx 形式，使用＃，1至6个，对应1阶到6阶 可以使用闭合式标题，即前后配对，出于美观考虑 3. 区块引用 类似EMAIL中的 > 形式，即使用 > 作为缩进的符号，根据层次使用不同的个数。 小窍门 在段落的第一行上加 > 号 可以嵌套，根据层次加上不同数量的 > 引用的区块内也可以使用其他的 Markdown 语法 4. 列表 无序列表，使用﹡，＋，－。 有序列表即数字加英文句点。与数字顺序是否正确无关。 列表项目可以包含多个段落，缩进要一致 比如这样就不好看了， 比如这样就还不错，字体显得行间距不太好看。 列表项目里可以使用 > 缩进。 要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符 5. 代码区块 缩进4个空格或1个制表符即可。 6. 分隔线 一行中三个以上的星号、减号和底线，还可以在中间插入空格。 二、 区段元素 1. 链接 行内式和参考式两种形式 链接文字都是用 [方括号] 来标记 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来 如： [ an example ] 、 ( http : //example.com/ \"Title\") 相对路径则是 ？？？ 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 如：[ an example ][ id] [ id ] 、 : http : //example.com/ \"Optional Title Here\" 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加 上一个空的方括号 强调 Markdown 使用星号（ ﹡）和底线（ _）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 < em> 标签包围，用两个 * 或 _ 包起来的话，则会被转成 < strong> 唯一的限制是，你用什么符号开启标签，就要用什么符号结束 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（ `） 图片 Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 详细叙述如下： 一个惊叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。 例 : ![替代文字](路径文件) 效果图： 自动链接 Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接","tags":"markdown","loc":"http://sndnyang.github.io/markdown_syntax.html","title":"markdown_syntax"},{"text":"shell string总结 空串判断 if [ -z \"$line\" ] 在awk使用时，全部是数字的外部string变量需要前后加双引号，不然会当作数值，打印时会出bug for循环遍历文件时，使用 for line in cat $filename 缺点: 当行内有空格时，一行会被划分成两行 上一条的替代方法 while read line do done < filename 缺点：过程中需要 命令行交互时， 无法输入命令。","tags":"shell","loc":"http://sndnyang.github.io/shell_string.html","title":"shell_string"},{"text":"ksh 里的数学运算 ksh 里的数学运算不同于 bash，且资料不多，难以查询 实际使用的是 (( 运算式 )) 示例 : (( bch_id += 1 )) 不支持 ++ (( next = pre + 1 )) 不能用 next=((pre+1))","tags":"shell","loc":"http://sndnyang.github.io/ksh_shu-xue-yun-suan.html","title":"ksh_数学运算"},{"text":"date命令的使用 不带任何参数的使用，结果: Tue Jan 7 07:25:17 CST 2014 时间显示格式 date +%Y%m%D%H%M%S, 即加号后%字母%字母2...... 常用格式参数 %Y year %m month %d 当月几号 %D 等价于 %m/%d/%y %H 24小时制 %h 月份的英文缩写 %M 分钟 %S 秒 %s January 1, 1970至今多少秒，UNIGW系统的标准方式","tags":"shell","loc":"http://sndnyang.github.io/date.html","title":"date"},{"text":"jquery travel •parent() •parents() •parentsUntil() •children() •find() •siblings() •next() •nextAll() •nextUntil() •prev() •prevAll() •prevUntil() jQuery first() 方法 first() 方法返回被选元素的首个元素。 jQuery last() 方法 last() 方法返回被选元素的最后一个元素。 jQuery eq() 方法 eq() 方法返回被选元素中带有指定索引号的元素 jQuery filter() 方法 filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。 jQuery not() 方法 not() 方法返回不匹配标准的所有元素。 提示：not() 方法与 filter() 相反。","tags":"jquery","loc":"http://sndnyang.github.io/parent.html","title":"parent"},{"text":"jquery 尺寸 jQuery width() 和 height() 方法 width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。 height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。 jQuery innerWidth() 和 innerHeight() 方法 innerWidth() 方法返回元素的宽度（包括内边距）。 innerHeight() 方法返回元素的高度（包括内边距）。 jQuery outerWidth() 和 outerHeight() 方法 outerWidth() 方法返回元素的宽度（包括内边距和边框）。 outerHeight() 方法返回元素的高度（包括内边距和边框）。 文档（HTML 文档）和窗口（浏览器视口）的宽度和高度 $(document) $(window) css() 中带参数即为设置","tags":"jquery","loc":"http://sndnyang.github.io/size.html","title":"size"},{"text":"操作css •addClass() - 向被选元素添加一个或多个类 •removeClass() - 从被选元素删除一个或多个类 •toggleClass() - 对被选元素进行添加/删除类的切换操作 •css() - 设置或返回样式属性 向不同的元素添加 class 属性 CSS函数 返回 CSS 属性 如需返回指定的 CSS 属性的值，请使用如下语法： css(\"propertyname\"); 下面的例子将返回首个匹配元素的 background-color 值： 设置 CSS 属性 如需设置指定的 CSS 属性，请使用如下语法： css(\"propertyname\",\"value\"); 下面的例子将为所有匹配元素设置 background-color 值： 设置多个 CSS 属性 如需设置多个 CSS 属性，请使用如下语法： css({\"propertyname\":\"value\",\"propertyname\":\"value\",...});","tags":"jquery","loc":"http://sndnyang.github.io/opr_css.html","title":"opr_css"},{"text":"删除元素 •remove() - 删除被选元素（及其子元素） •empty() - 从被选元素中删除子元素 过滤被删除的元素 jQuery remove() 方法也可接受一个参数，允许您对被删元素进行过滤。 该参数可以是任何 jQuery 选择器的语法。 下面的例子删除 class=\"italic\" 的所有 元素： 实例 $(\"p\").remove(\".italic\");","tags":"jquery","loc":"http://sndnyang.github.io/del_element.html","title":"del_element"},{"text":"添加新元素 •append() - 在被选元素的结尾插入内容 •prepend() - 在被选元素的开头插入内容 •after() - 在被选元素之后插入内容 •before() - 在被选元素之前插入内容","tags":"jquery","loc":"http://sndnyang.github.io/add_new_element.html","title":"add_new_element"},{"text":"获取，设置内容及属性 获得内容 - text()、html() 以及 val() 三个简单实用的用于 DOM 操作的 jQuery 方法： •text() - 设置或返回所选元素的文本内容 •html() - 设置或返回所选元素的内容（包括 HTML 标记） •val() - 设置或返回表单字段的值 获取属性 - attr(); 说明，不带参数为获取，带参数为设置。 上述四个回调函数写法： 拥有回调函数。回调函数由两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值。然后以函数新值返回您希望使用的字符串。 $(\"#btn1\").click(function(){ $(\"#test1\").text(function(i,origText){ return \"Old text: \" + origText + \" New text: Hello world! (index: \" + i + \")\"; }); });","tags":"jquery","loc":"http://sndnyang.github.io/content_attr.html","title":"content_attr"},{"text":"jquery 常用函数 隐藏 show hide toggle 图形渐消失 fadein fadeout fadetoggle fadeto 指定透明度 滑动 slideDown slideUp slideToggle 动画 animate 使用animate来操作CSS属性， animate （{}) 当使用 animate() 时，必须使用 Camel 标记法书写所有的属性名 stop callback 在动画函数中， 增加最后一个参数 function 如 x.hide(\"slow\", function() {xxxx}) 方法链接 css().hide().slideDown()","tags":"jquery","loc":"http://sndnyang.github.io/jquery_function.html","title":"jquery_function"},{"text":"jquery 语法 jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。 基础语法是：$(selector).action() 美元符号定义 jQuery 选择符（selector）\"查询\"和\"查找\" HTML 元素 jQuery 的 action() 执行对元素的操作 示例 $(this).hide() - 隐藏当前元素 $ ( \"p\" ). hide () - 隐藏所有段落 $ ( \".test\" ). hide () - 隐藏所有 class = \"test\" 的所有元素 $ ( \"#test\" ). hide () - 隐藏所有 id = \"test\" 的元素 jquery 选择器 jQuery 元素选择器 jQuery 使用 CSS 选择器来选取 HTML 元素。 $ ( \"p\" ) 选取 < p > 元素。 $ ( \"p.intro\" ) 选取所有 class = \"intro\" 的 < p > 元素。 $ ( \"p#demo\" ) 选取所有 id = \"demo\" 的 < p > 元素。 jQuery 属性选择器 jQuery 使用 XPath 表达式来选择带有给定属性的元素。 $ ( \"[href]\" ) 选取所有带有 href 属性的元素。 $ ( \"[href='#']\" ) 选取所有带有 href 值等于 \"#\" 的元素。 $ ( \"[href!='#']\" ) 选取所有带有 href 值不等于 \"#\" 的元素。 $ ( \"[href$='.jpg']\" ) 选取所有 href 值以 \".jpg\" 结尾的元素。 jQuery CSS 选择器 jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。 下面的例子把所有 p 元素的背景颜色更改为红色： 实例 $(\"p\").css(\"background-color\",\"red\"); 语法 描述 $(this) 当前 HTML 元素 $(\"p\") 所有 元素 $(\"p.intro\") 所有 class=\"intro\" 的 元素 $(\".intro\") 所有 class=\"intro\" 的元素 $(\"#intro\") id=\"intro\" 的元素 $(\"ul li:first\") 每个 的第一个 元素 $(\"[href$='.jpg']\") 所有带有以 \".jpg\" 结尾的属性值的 href 属性 $(\"div#intro .head\") id=\"intro\" 的 元素中的所有 class=\"head\" 的元素","tags":"jquery","loc":"http://sndnyang.github.io/jquery_grammar.html","title":"jquery_grammar"},{"text":"jquery 文档就绪函数 所有 jQuery 函数位于一个 document ready 函数中： $(document).ready(function(){ --- jQuery functions go here ---- }); 这是为了防止文档在完全加载（就绪）之前运行 jQuery 代码。","tags":"jquery","loc":"http://sndnyang.github.io/jquery_ready_func.html","title":"jquery_ready_func"},{"text":"添加 jQuery 库 <head> <script type= \"text/javascript\" src= \"jquery.js\" ></script> </head> <script> 标签应该位于页面的 <head> 部分","tags":"jquery","loc":"http://sndnyang.github.io/import_jquery.html","title":"import_jQuery"},{"text":"个人笔记 这里记录了我不同技术、项目的总结 杨秀隆 2013-12-26","tags":"到 note 的链接","loc":"http://sndnyang.github.io/ge-ren-bi-ji.html","title":"个人笔记"},{"text":"sys.path 永久路径 具体是在site-packages文件夹中添加一个.pth文件，将你需要python搜索的文件路径添加进去","tags":"grammar","loc":"http://sndnyang.github.io/syspath.html","title":"sys.path"},{"text":"python package使用总结 1、 文件夹下使用__init__.py文件。 2、 各文件需要import的包，仍要import,__init__只是节省依赖包的导入。","tags":"grammar","loc":"http://sndnyang.github.io/package.html","title":"package"},{"text":"python package中__init__.py 的使用总结 1、 需要将目录中的文件都import一遍， 不然在dir()时不会显示出来。 2、 各文件需要import的包，仍要import,__init__只是节省依赖包的导入。","tags":"grammar","loc":"http://sndnyang.github.io/pac_init.html","title":"pac_init"}]}