{"pages":[{"url":"http://sndnyang.github.io/2016-09-27-diary.html","text":"星期二 天气：阴 标题： 猜得很准， 很失败 GRE成绩出来了， 作文确实是2分， 基本可以肯定要重考了。 怎么准备， 真是~~~没办法， 还是找个工作蹭点工资吧。 今天常规 单词 8：55 中文阅读朗读 23：22 《假如今天是我生命中的最后一天》， 这种文章略鸡汤。 《匆匆》，多年后的再次阅读 英文阅读朗读 22：36 13题对9，之前做过一遍，NOT GIVEN类错最多。 学到一个是非题的顺序原则~~~也对。照顺序，在上下题间找同义句，完全没提到是not given，另外是同义和反义判断。 数学 20：22 热身 机器学习 今天没有学习， 为了工作， 得赶紧学机器学习和深度学习， 练代码了。 音乐 23：31 音乐导聆 李叔同 送别—— 原作曲哪位现在就忘了。 还是 一壶浊酒尽余欢， 壶字比瓢字好听，又比觚字好用， 虽然喝一壶酒确实太多了。 zhimind 17:21 尝试了下html来搞android，继续卡在样式上了。 健身 20：40 书包当哑铃， 另外深蹲","tags":"日记","title":"2016.09.27日记"},{"url":"http://sndnyang.github.io/20160926ri-ji.html","text":"星期一 天气：晴 标题： 千里之行 今天8点出门， 直到17点才到， 足足9个小时。 8点10分出门， 路上有点堵， 9点10几到， 花了一个小时。 提前了一个半小时到机场， 本来应该10点50起飞的， 拖了10几20分钟， 飞行时间2小时， 下午1点出头到贵阳， 3点的班车， 再有2个小时， 终于在5点到家了。 1个小时的公交车， 2个小时的候机时间， 2个小时的飞行时间，2个小时的班车等待时间， 2个小时班车行驶+县城公交步行时间。 其实已经很便捷了， 但我还是嫌麻烦， 比如候机有点久，没带大件行李，直接自助取票就可以安检，时间上再精确点就能节约点。另外，如果不是住在小县城、班车太少，就不用等2个小时了。 今天常规 英文听力 21:18 单词 10:15 日记总结 23:13","tags":"日记","title":"2016.09.26日记"},{"url":"http://sndnyang.github.io/20160925ri-ji.html","text":"星期天 天气：晴 标题： 千里之行，始于足下 今天常规 英文听力 完成 17:23 音乐 23:42 音乐导聆第一章第一节，古琴与士, 了解古琴的发展历史 练字 执行中 单词 20:43 完成 健身 21:00 完成， 腹肌锻炼，仰卧起坐、卷腹 日记总结 23:43 图书馆借了本薄书， 学堂在线出毛病了， PC上很难打开， 翻墙反而能打开。","tags":"日记","title":"2016.09.25日记"},{"url":"http://sndnyang.github.io/liu-xue-ying-yu-kao-shi-gan-xiang.html","text":"昨天上午12点， 雅思笔试结束。 出来，主要感想： 终于考完了！ 考得太差了！ 准备太不充分了！ 估计要二战了！ 钱啊！ 钱啊！ GRE和雅思成绩结果及预测： GRE V:149, Q: 168, 总分:317, AW(预测):2.5或3 雅思预测 口语:5或5.5， 听力：6,6.5，阅读：6.5,7， 写作：5.5,6。 但需要 6.5的均分 不知道在网站上写的 153, 155, 4.0 和 6.5雅思 是不是固定死的， 不然我两个都是一定要重新考了。一般来说应该留有余地， 那GRE我的aw如果有3， 估计也不用再考了。雅思仍然不清楚，没有估分经验， 万一总分才5.5那肯定不行， 但6分不知道可不可以。 备考感想 以下才是正文。 在8月中旬差不多8月20号，突然发现尽快考出成绩，也许还能申请春季入学。于是一开始是报了9月4号的GRE 和 准备报9月10号的雅思。纠结几天后，发现不可能， 把GRE推迟到9月17号， 雅思定到9月24号。 总之， GRE的准备时间大概1个月， 雅思多一周。 然而现实给了自己狠狠一耳光——终究没有认真学习的习惯，仍然在经常在无所事事中浪费时间。 GRE备考状态： 刷单词 前期用 再要你命三千 刷词， 同时也在看托福词汇。刷词就是纯粹地看一下，记一下，速度估计是1分钟1个list 10个单词， 10分钟就1个单元100个单词， 一个小时多看500、600单词， 当然这是巅峰速度。 记忆质量毫无疑问的差，但估计也能对不少词混个眼熟。 但还是有不少日子没有背单词或看得极少，严格来说，我只刷了两遍 3000，后来因为对部分单词（六分之一左右）了解已够， 不想多看， 在收藏夹 和 正常刷词间徘徊，几乎停止刷单词。 后期因为记忆效率和质量问题，改采用联想记忆法，一度效果不错，但剩余时间不多， 联想不易， 又试图从 词根、词缀（比如看了英语词根与单词的说文解字）协助记忆， 这番纠结下来， 没时间了。 总结： 3000+magoosh 已经很精简了， 背GRE 有点忽略了相对基础的词汇， 在GRE考试中选择短语有点模糊而错误， 背的效果也不好。 有时间准备， 一定是基于词根词缀（未来扩展性强） 辅以 联想记忆法， 比如词根及非派生词， 只能用联想记忆法了。 所以，其实也计划把 3000 和 magoosh 用词根词缀和联想编写好后，做个APP。一直想做个背单词的应用， 主要是受限于素材（例句等）。 verbal 基本上只是做点模考，熟悉了下题型， 没有做超过8套题。没有看过任何技巧总结，因为我觉得看懂就是看懂，单词、短语知道是什么意思，选词填空题就基本没问题，这部分最主要的还是单词和短语看不懂，句子意思因结构和语法不理解的在少数。 当然， 填空和阅读都涉及阅读速度、理解速度。习惯性回跳重读、精力不集中， 非常影响速度。 但这个平时积累、练习就好， 并不需要刻意针对考试。 而阅读的考试技巧不能说是无稽之谈，但我真得读得又快又好的话，不需要技巧这种套路，临时分析都行。能自己从分析中显式地总结技巧、 套路是最有效果、最出类拔萃的。 数学 虽然从来没满分过， 但也从来不觉得有什么问题， 除了看花眼， 以及不想检查。 作文 作文有题库。 但我从头到尾， 一篇都没写过， 提纲也没看过， 等于是裸考。 实际考试中，遇到的issue题目正好在一本书上看到。不过书上是强调学生对题目分析上的错误（群众对官方、当局的质疑，能提高福利），应该没有附范文。 就算有范文，我也没背，不能抄， 还是裸考。 几乎没有看过题库， 提纲一篇都没写过， 完整作文更是没有写。 说到底就是浪费了太多时间。 雅思备考感想 雅思考试就是GRE考试的下一周， 挺紧张的。 本来差点计划9月10号考的， 但一开始计划是回家呆着，然后到时间去广州考GRE，然后回厦门就等着雅思， 所以推到24号。结果又不回家了~~~成绩出来太晚了，因为国庆，要到10月21号才出。 早知道， 我就10号考了， 早一点就早一点练习而已，也没有多出多少练习时间。 听力 托福都是选择题，没听到都可以逻辑或蒙个选项。 雅思的填单词类的题目就不要指望了， 没听到就放弃吧。 所以我第一次模考 听力4.0分， 阅读7.0。 训练大概就是在网上（比如考满分）去听写。 考满分网有好的地方，完整剑雅的素材（沪江听写就比较乱）， 速度可调， 在1.0凑合的情况下，我直接听 1.5 倍速。反正他一旦略读太多， 0.8我也听不出来， 各种that和介词听不到。缺点就是，比如一句话有多少个词， 他就摆好多少个框，而且一填完就知道正确与否，就容易拿词试框， 忽略整体。 另外它上面的语料库——主要是练习听力单词——很有意义， 也方便使用， 但有些单词发音不准，另外没有上下文单纯听单词发音，会多犯很多错误。 阅读 同GRE，没怎么准备， 模考而已，第一次模考，听力4分，阅读7分， 后面两次也都没涨分，倒是看了下所谓head题， 并不是我以为的段落总结、中心思想， 只是找到段落里同义句而已。 写作 也是基本没准备， 简单地看了下其他范文，了解下结构而已。 实际考试里， 小作文还行， 大作文字数好像不够。 口语 简单地练了下语音， 口语话题也有题库， 做好准备的话，也应该在考前把所有话题做个提纲甚至打个底稿。 然而我也没有准备， 只是考前（考场外面等待的一两个小时）看了下高频话题， 发现 有趣的公共场所、 首次尝试的某种食物、 运动等都不会~~~ 实际口语考试中， 各种错误百出就不说了， part1还问到了 celebrity，可是我没听出来，不确认是不是名人。 等我出来一看题库， 还真有celebrity， 本来我准备了part2 被问到 peole I admire的。 总结 没有好好准备， 前一个月一边烦躁，一边在浪费时间， 估计躲不了二战再花3000多——加路费更高。 之后的练习计划： 口语： 走遍美国 听力： 考满分，每天先做一个section的题，再听写。再加上听点英文课程。 作文： 每天就一个话题，限时写作。写完修改。 阅读： 只能平时看点英文文章，注意速度。也许看完多回忆就好了，不需要找专门有阅读题的书籍来做练习。","tags":"日记","title":"留学英语考试感想"},{"url":"http://sndnyang.github.io/20160924ri-ji.html","text":"星期六 天气：晴 标题： 终于摆脱火急火燎的状态了！！！ 今天完成的事 雅思笔试，从8月中突然意识到，要赶紧考GRE和托福后， 今天终于结束了首战， 虽然很有可能要二战，但最起码心里有底了。 剑雅10 - Test4 - 第3部分， 模考， 没有听写 magoosh 1000 补充中文释义 完毕--可能有更完善版，但我没找，其他的释义不全也没有说明词性。 学堂在线-MIT概率导论第一单元的第一小块作业题--有一个有点疑问，好吧， 刚才脑子不正常，搞错了， 没有问题。","tags":"日记","title":"2016.09.24日记"},{"url":"http://sndnyang.github.io/ying-yu-ci-gen-yu-dan-ci-du-shu-bi-ji.html","text":"构词形态变化 字母增加 重读闭音节的词根 添加后缀时， 尾辅音字母需要重写， 因而增加一个辅音字母。 例如： hap+-en-> happen v.发生 refer+-al-> referral a.参考的 古典语词根与后缀或另一词根构成一级派生词时， 增加连接字母。 如希腊词根之后多添加-o-，拉丁词根后多添加-i- helic+ o + pter -> helicopter anthrop+ o + logy -> anthropology sent+ i + ment -> sentiment cert+ i + fy -> certify 为保持位于某些位于词尾的重读词根中元音字母读长音， 在词根后添加无语义的构词后缀-e， 使之成为 开音节。 例如： in + clud + e -> include pro + mot + e -> promote 字母的脱落 主要是词素尾字母的脱落： 在添加后缀时， 某些词根的尾字母 -e脱落， 以保持词根原本的音值。 write+er=write create+ive=creative 有些以辅音字母结尾的前缀与以相同的辅音字母开头的词根结合时， 前缀尾字母脱落。常见的脱落字母是 -s。 trans+spir+e = transpire trans + ship = tranship 字母的变更 指在构词过程中， 字母或字母组合变成另外的字母或组合： 零级派生情况下， 词根内部元音字母变化， 使单词的词类发生转化。 full -> fill gold -> gild food -> feed 一级派生时， 某些前缀的尾辅音字母受词根首字母的同化， 变得与词根首字母相同： ad + fect = affect com + rect = co.rrect dis + fer = dif.fer ex + fect = ef.fect 二级派生时， 某些原始派生词的词根尾字母在添加 ion, ive, ible等后缀时会发生变化： absorb + ion = absorption produce + ive = production respond + ible = resonsible 二级派生时， 以辅音字母+y 结尾的单词在添加派生后缀时， 字母y变为i： dry + ly = drily happy + ness = happiness 连字符的使用 太明显， 略 用在派生前缀后， 避免该二次派生词与同形的外来借词（原生词）相混淆： re-cover - recover re-create - recreate re-sort - resort 词义及派生词义 隐性派生词： 字面含义与实用意义之间有一定距离， 但可以通过领会造词意图， 理解词义。 派生词本义发生了变化， 扩大、缩小、扬升、 贬降、 比喻或引申 不但包含含义， 还需要一些背景知识——其实举的例子也简单， 真正怕的还是一词多义， 形容词和动词。 词性 粘附词根来自 古典语基本单词的 词干 部分 古典语基本单词的词性 是粘附词根属性的依据 与之等义的英语或汉语单词的词性则可作为判断这种属性的标志。 源及形 同源异形根 拉丁动词词根， 数量多是两个， 往往分别来自不定式词干和动名词词干。 语音形体变化： 尾辅音向 t 过渡 t,d 变成 s 必要的添音与语音同化 词根尾辅音字母 b->pt p -> pt g -> ct c -> ct v -> (u)t m -> mpt x, sc -> (c)t 其他尾辅音字母 -> t t, d -> s 异源同形根","tags":"其他","title":"英语词根与单词 读书笔记"},{"url":"http://sndnyang.github.io/Locally-weighted-regression.html","text":"说明 本文参考以下文献： Andrew Ng在斯坦福的cs229视频和讲义， cs229 在下文笔较烂， 恐贻笑大方。 不过因为是markdown 写的， 有不足， 改进比较方便， 所以欢迎提出意见及建议，找出问题， 谢谢。 导读 经过了： 1. 基础 2. 标准方程 3. 概率解释 三篇教程（以后补练习）， 希望能对线性回归有个还算深入的认识。 假设样本空间确实是线性的， 那线性回归自然当仁不让， 大展身手。但我们也知道， 现实中，很多模型是非线性的。那要么发展出非线性模型（比如svm的核和神经网络），要么想办法把它看成是线性的。 人工神经网络整体可表达非线性的，但单个神经元用sigmoid函数一般还是线性的。 比如这张图, 我随机弄的点， 实际是啥模型不知道： 怎么把它看成线性的呢？ 分段线性函数 太明显了 submit 局部线性 大概就是这样的 这是理想情况， 如果是一个高斯曲线、 二次曲线肯定没那么漂亮的拟合效果。 接下来， 看这小节的题目——局部线性， 线性肯定熟悉了， 关键是怎么局部？ 拿上图来说， 人眼在这图上可以看出三段直线， 计算机怎么知道是三段， 然后每段用上哪些数据点， 就是我们试图解决的问题。 要有局部性， 最显然的， 你要预测某个点x的值， 就找x 附近的点， 把它们找出来， 然后做线性回归， 这肯定是一种方法。 速度上也可以用一些结构来优化效率——Ng在视频里提到的 KD树的局部线性方法 我猜应该就是这个方向。 但这种方法有问题。 x附近这个范围难定 不在范围内的点完全无用 x附近可能没点 x附近点也不线性 submit 局部的强调 那我们就说， 既要抓重点（局部）， 又不能把次要的（远点）全部忽略点。那怎么办？ submit 加权重 加权 这种思想、 方法应该也是经常用的。 别的不说， 线性回归方程的系数就是不同特征 \\(x_i\\) 的一个权重。 还有老师为了让学生能及格、不挂科， 会在期末考、 期中考、 平时作业、 考勤等项目上调整权重。 那很明显了， 要给 每个点 一个权重， M个点， 就是一个M的权重向量， 一般用w(weight)表示, 但我这里为了不写 \\(\\theta\\) (theta), 线性模型里就用过w了。我们这里用 p 代表权重。 那我们的损失函数 J(w)就可以写成： $$ J(w) = \\sum&#94;m_{i=1}p&#94;i(h(x&#94;i) - y&#94;i)&#94;2 $$ 这个式子不容易表达成纯矩阵、向量乘法~~~ 那怎么求 p 呢？ 用什么方法把 p 和 w 一起求出来？也许有， 但不是本文研究的。 本文里的p 是先行计算出来， 而不是w这种给定模型后，用数据拟合出来。 想想 p 有什么特点， 我们要预测 x 的值，所以离x越近的值的权重就会越大， 越远就越小， 但这里我们认为始终大于0. 也就是x点或0点值最高， 然后往两边递减， 这样的特点你能想到什么相似的东西吗？ 钟型曲线 是的， 像正态分布或钟型曲线。 我们也知道正态分布的概率密度函数为： 平均值 \\(\\mu\\) 是什么？ 就是我们要预测的 x 。 方差 \\(\\sigma\\) 是什么？ 没说， 简单点的话就是1， 也可以根据实际估计一个值。 用字母t来表示。 最后还有前面的这个系数， 不需要了， 一个指数已经够了。 这样我们就得到一个权重的表达式： $$ 点 i 的权重 p&#94;{(i)} = \\exp \\large(-\\frac{(x&#94;i - x)&#94;2}{2t&#94;2}\\large) $$ 最后的最后要说的是： 这是一种权重的计算方式， 有其他的也可以用。 虽然我是从正态分布转过来的， 但 Ng 特意强调这个跟正态分布没有关系， 就是长得像。 特点 局部加权回归每次预测时， 因为要先知道预测的中心点，才能有附近、权重， 所以每次预测新的x值时， 都要重新计算。 有其他方法解决这个问题， 但不是本文讲解内容了。 总结 复杂的非线性模型可能可以考虑采用局部线性回归来拟合， 让相近点权重大，远点权重小。就是把每一个局部数据都看作是线性的。 再用， 用钟型曲线的函数来生成所有点相对x的权重。 恭喜 局部加权线性回归的主要内容就是这些， 谢谢您的阅读。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"机器学习","title":"局部加权回归"},{"url":"http://sndnyang.github.io/probabilistic-Community-Role-model.html","text":"摘要 再来一遍， 不权威定义：社区发现大概就是发现高密度的点群， 群内互连较多；连到群外的较少 之前社区发现和role detection（作用检测）两个领域各玩各的， 本篇论文就是把这两个结合起来， 以一种统一的模型结合，来同时处理这两个任务， 并且要做到更好的效果。 基本观点 节点可能属于多个社区，一个点有没有边连到另一个点要视它所属的社区而定。each node has a distribution over the communities. 节点的属性可以把节点分成多类，可视为节点所承担的角色。each node has a distribution over roles。 每个点会有一些动作， 跟所属社区和角色有关。 所以我们必须考虑the distributions that the node has over both communities and roles. 主要贡献 写了三个 incorporate various elements of a social network into a unified probabilistic generative framework. then design a method to estimate the parameters of the model. use our model to generate a synthetic network with the learned parameters, and verify the superiority of our model, 这也能算？做实验不算创新就算贡献了？ apply the model to two problems|behavior prediction and community detection|verifying its versatility and effectiveness 这条和第二条不都是做实验吗？ 正文 定义 社区community： Each community has a multinomial distribution over all pairs (v, u), denoted as \\(\\zeta\\) 社区上的点分布node distribution over communities？: Each node has a multinomial distribution over communities, which is denoted as \\(\\phi\\) 角色role: 每个点可能有多个角色设定。 每个角色都有一组分布的参数。 我们这里用 高斯分布。 角色上的点分布 nodes distribution over Roles: Each node has a multinomial distribution over roles, which is denoted as \\(\\theta\\) 动作action 动作多种，比如转发和关注。 y 表示 action 社区角色对 community-role pair the distribution of community-role pairs over actions, denoted as \\(\\rho\\) 因为actioin y只有两种结果，所以，使用伯努利分布。 模型描述 regard a node as a random mixture over communities 网络中边的生成过程描述 如下： define each role as a distribution over attributes and each node is a random mixture over roles The generative process of all nodes ： The generative process of the actions: 时间复杂度略 推断及参数估计 看不懂。 使用 Gibbs 采样和 EM 算法，两个都不认识。 一大堆公式也不知道是什么意思。 得去补补课再回来补完报告了。 总结 这篇A和之后的一篇B挺像的（B引用了A），B的作者里有没有A 呢？ 总结不出来什么内容。 这里一个分布， 那里一个分布， 我就没思考为什么用这个、那个分布。推断部分的两个算法都不认识。 最后的实验也没看。还是要看实验才行， 实验看多了， 才能估计模型、方法有没有效果吧。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"研究","title":"社交网络的概率社区角色模型"},{"url":"http://sndnyang.github.io/linear-regression-probability.html","text":"说明 本文参考以下内容： Andrew Ng在斯坦福的cs229， cs229 在下文笔较烂， 恐贻笑大方。 不过因为是markdown 写的， 有不足， 改进比较方便， 所以欢迎提出意见及建议，找出问题， 谢谢。 导读 线性回归基础 介绍了线性回归基础的三大要素： 模型， y=h(x)=w*x+b， 为求方便， \\(b=w_0*x_0\\) 策略。 损失函数 \\(J(w) = (h(x) - y)&#94;2\\) 算法。 梯度下降法（批量和随机）， 对w向量的各个分量求偏导，迭代。 这篇文章内容会比较少， 毕竟整体风格就是碎片化阅读， 想认真看书、文章的话，有很多经典的书， 我还差远了。 回归正题。 这里我们要严格地分析所采用的策略，解释为什么用最小二乘法，也就是 损失函数 \\(J(w) = (h(x) - y)&#94;2\\) 为什么是可行有效的。 本文将介绍一种概率的解释方法， 存在其他解释（比如几何的）。 引入误差 首先， 假设确实是线性模型， \\(y=w*x\\) 。 在理想的实验环境下，这个模型也许就是完美的。但我们知道，理想和现实是有差距的， 也就是我们还要加上一个误差项error。所以得： $$ y = w*x + \\varepsilon $$ 这里的误差有几种可能来源 没有考虑到的特征 随机噪声random noise 就像子女身高跟父母身高关系一样， 难免有误差， 这里不难理解。 那我们也知道，误差也是有规律的，比如预测身高应该是1米8，实际身高可能是1米79，1米8，1米81，但低于1米6的概率和高于2米的概率就很小。 那直觉上， 你觉得误差满足什么分布吗？不满足请填\"不满足\"， 否则请写是什么什么分布，比如均匀分布。 答： submit 误差的分布 没错， 就是正态分布，这主要涉及到一个概率统计上的概念， 你觉得是哪个？ 中心极限定理 大数定律 方差分析 期望和方差 submit 数学表达 所以数学式子有： $$ \\varepsilon \\sim \\mathcal{N}(0, \\sigma&#94;2) \\\\ 概率密度 P(\\varepsilon) = \\frac{1}{\\sqrt{2}\\pi\\sigma}exp(-\\frac{\\varepsilon&#94;2}{2\\sigma&#94;2}) $$ 因为 \\(\\varepsilon = y-w*x\\) , 而数据集方差不变。 请回答： $$y|x;w \\sim \\mathcal{N}(?, \\sigma&#94;2)$$ N( ,...)? submit 似然值 已知 \\(y|x;w \\sim \\mathcal{N}(w*x, \\sigma&#94;2)\\) ，则单个数据 \\((x&#94;i,y&#94;i)\\) 的概率表达式为： $$ P(y&#94;i|x&#94;i;w) = \\frac{1}{\\sqrt{2}\\pi\\sigma}exp(-\\frac{(y&#94;i - x&#94;iw)&#94;2}{2\\sigma&#94;2}) $$ 不要在意乘号、矩阵向量相乘这些细节, 有时候是 \\(w*x\\) , 有时候 \\(Xw\\) , 有时候 \\(x&#94;iw\\) ， 我也很乱的。 那所有数据(X, y)的似然值（概率）呢？ 跟单个概率什么关系？ 所有概率之和 所有概率之积 submit 表达式 所以， 完整的w似然值(likelihood)为： $$ \\begin{aligned} L(w) & = P(\\vec{y} | X; w) \\\\ & = \\prod&#94;m_{i=1} P(y&#94;i| X&#94;i; w) \\\\ & = \\prod&#94;m_{i=1}\\frac{1}{\\sqrt{2}\\pi\\sigma}exp(-\\frac{(y&#94;i - X&#94;iw)&#94;2}{2\\sigma&#94;2}) \\end{aligned} $$ 其实已经可以看到曙光了， 似然值自然是越大越好， 但看这个式子， 求积太复杂了， 肯定要化简。 怎么化简? submit 对数化 概率的值本来就很小， 再相乘就太小了。 所以， 遇到概率时， 经常使用到 取对数 的方法。 所以就有： $$ \\begin{aligned} \\mathcal{l}(w) & = log L(w) \\\\ 化积为和： \\\\ &= \\sum&#94;m_{i=1}log(\\frac{1}{\\sqrt{2}\\pi\\sigma}exp(-\\frac{(y&#94;i - X&#94;iw)&#94;2}{2\\sigma&#94;2})) \\\\ 展开 \\\\ & = m*log \\frac{1}{\\sqrt{2}\\pi\\sigma} + \\sum&#94;m_{i=1}-\\frac{(y&#94;i - X&#94;iw)&#94;2}{2\\sigma&#94;2} \\end{aligned} $$ 因为 \\(\\sigma\\) 跟数据样本有关，跟 \\(w\\) 无关，所以第一项常数可忽略， 后一项的分母也是常数忽略。 所以对 l(w)求最大化似然值就等价于最小二乘法的最小化。 $$ \\max_w \\sum&#94;m_{i=1}-(y&#94;i - X&#94;iw)&#94;2 = \\min_w \\space (y-Xw)&#94;2 $$ 至此，我们给出了最小二乘法的一个概率解释。 总结 希望通过本文的介绍， 你能了解如何通过对误差的概率分析，得到似然值的表达式，再取对数化简，最终得到和最小二乘法一样的最优化目标。 恭喜 恭喜你看完本文， 完结撒花！！！ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"机器学习","title":"线性回归概率解释"},{"url":"http://sndnyang.github.io/logistic-regression-foundation.html","text":"说明 本文参考以下内容： Andrew Ng在斯坦福的cs229， cs229 在下文笔较烂， 恐贻笑大方。 不过因为是markdown 写的， 有不足， 改进比较方便， 所以欢迎提出意见及建议，找出问题， 谢谢。 导读 线性回归基础 介绍了线性回归基础的三大要素： 模型， y=h(x)=w*x+b， 为求方便， \\(b=w_0*x_0\\) 策略。 损失函数 \\(J(w) = (h(x) - y)&#94;2\\) 算法。 梯度下降法（批量和随机）， 对w向量的各个分量求偏导，迭代。 这篇文章会基于线性回归的基础， 介绍第一个分类方程--逻辑回归 logistic regression. 之前说回归和分类是两类问题， 而现在要讲的逻辑回归却主要用于解决分类问题， 虽然它确实是回归方法，输出值是连续非离散的。 模型 关于线性回归为什么不能用于分类--这个问题我就不讨论了。 分类问题，特别是二元分类问题--只有两类--是很明显的。如图： 首先， 我们要明确一点，虽然不再是线性回归了，但线性这个还是没跑的。也就是说我们要用一条 直线 来划分两类数据，更复杂的非线性分类方法以后会有。 还是老问题，现实中的数据用线性来拟合最简单， 而且也不知道它实际上会符合什么样的数学模型， 所以线性模型大概也够了， 不要自己给自己找不痛快了。 深度学习是深度学习，不一样。 建模时， 比如上图， 决定用直线 \\(y=w*x\\) 来划分。 那接下来就是用数学来表示这条直线了。 分类定义 先对分类问题进行定义。 分类， y值肯定是离散的， 这例子里就两类，那就可以写成 \\(y \\in [0, 1] 或 [-1, 1]\\) ， 习惯上取前者[0,1]。 这例子， x的参数有几个呢？ 1 2 3 n 不知道 submit 分类超平面 肯定是2个， x轴和y轴啊， y已经有定义？ 那就 \\(x_1轴和x_2轴\\) 。 2维平面上的分类， 所以用1维的直线来分类， 如果是3维空间中的分类，则用2维平面来划分。 如果是维度为n的高维空间， 就要用n-1维的超平面来分类， 这就是 分类超平面 。 这里的直线假设是 \\(w_1x_1 + w_2x_2 + w_0 = wx = 0\\) 。 因为，y值跟我们习惯上的 y(即 \\(x_2\\) )轴没什么关系。真要画图表示的话， y值要画成第三条轴，而且只有0、1两个值。 那这条直线跟y值 怎么关联的？ 很明显， 直线左边和右边对应两个类别。 换数学一点就是： $$ y&#94;i = \\left\\{ \\begin{aligned} 0 & & w&#94;Tx&#94;i < 0 \\\\ 1 & & w&#94;Tx&#94;i \\ge 0 \\end{aligned} \\right. $$ 所以我们要从 \\(w&#94;Tx&#94;i\\) 的实数值映射到 \\(\\{0, 1\\}\\) 上， 也就是加个函数变换， 就是 $$g(w&#94;Tx&#94;i)$$ 毫无疑问， 上面那个<0,>=0可以作为一个g函数。如果基于这个， 那就是 感知器模型算法(Perceptron)。 它和逻辑回归非常像， 策略和算法部分也一致， 虽然还没讲到。现在继续讲逻辑回归。 但用这个作为g函数有什么问题？ 一视同仁，无视远近 太暴力 不知道，哪有那么多问题 没法解释 submit g函数 我们要把点到分类直线的远近考虑到，可以认为是类似权重之类的。那起码有两种方案： 与0比较大小之外，再添加距离作权重——这个算是svm的方式， 请看 svm基础 g函数映射时，把值分开。 第2种方案是本文的重点。因为y取0或1，所以就要满足： x=0时居中， 比如标准0.5。 负无穷时趋近于0 正无穷时趋近于1。 大概这意思， 而且趋近不能太慢，刚从0值变化时，要有个比较剧烈的变化。 可选函数应该有很多， 比较常用的是 sigmoid函数： $$g(z)=\\frac{1}{1+e&#94;{-z}}$$ 曲线如图： 模型总结 综上所述， 我们得到了我们的模型： $$h(x) = g(w&#94;Tx) = \\frac{1}{1+e&#94;{w&#94;Tx}}$$ 策略 基于模型， 我们来考虑策略、损失函数了。 用最小二乘法的 \\((h(x) - y)&#94;2\\) 怎么样呢？很少有讨论--PASS。 这里直接上概率式子（具体推导请用误差正态分布代入h(x)自行推导）： $$ \\begin{aligned} &P(y=1|x;w) = h(x)\\\\ &P(y=0|x;w) = 1-h(x) \\\\ &所以：\\\\ &P(y|x;w) = h(x)&#94;y (1-h(x))&#94;{(1-y)} \\end{aligned} $$ 又看到了复杂的乘法及指数，所以求个对数得： $$ \\begin{aligned} \\mathcal{l}(w) & = \\sum y&#94;i \\log{h(x&#94;i)} + (1-y&#94;i)\\log{(1-h(x&#94;i))} \\\\ & = y&#94;T log(h(Xw)) + (1-y&#94;T)log(1-h(Xw)) \\end{aligned} $$ 简单粗暴 算法 继续求最优化的算法， 这里是求似然值的最大值， 不是之前的最小。 梯度下降法通用，所以是： $$ w = w + \\alpha \\nabla_w l(w) $$ 因为求最大， 所以梯度方向是求最大，使用+加法，反方向是求最小，才用减法。 这个求导过程也请自行尝试。结果为（希望没有写错）： $$ \\nabla l(w) = y&#94;T (y - h(x)) $$ 总结 本篇从线性回归的线性模型开始，一步步介绍 分类超平面的引入( \\(w&#94;Tx=0\\) ) 根据点和超平面的关系，需要对 \\(w&#94;Tx\\) 进行转换。 引入 sigmoid函数 （分类问题经常用到，非常常用） 逻辑回归的策略--似然值表达式 使用梯度下降处理 恭喜 恭喜您读完本节内容， 完结撒花！！！ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"机器学习","title":"逻辑回归基础"},{"url":"http://sndnyang.github.io/linear-regression-normal-equation.html","text":"说明 本文参考以下内容： Andrew Ng在斯坦福的cs229， cs229 Berkeley分校在Edx的Scalable Machine Learning，原课已关闭，改头换面重出江湖。 在下文笔较烂， 恐贻笑大方。 不过因为是markdown 写的， 有不足， 改进比较方便， 所以欢迎提出意见及建议，找出问题， 谢谢。 导读 上一篇文章 介绍了线性回归基础的三大要素： 模型， y=h(x)=w*x+b， 为求方便， \\(b=w_0*x_0\\) 策略。 损失函数 \\(J(w) = (h(x) - y)&#94;2\\) 算法。 梯度下降法（批量和随机）， 对w向量的各个分量求偏导，迭代。 这篇文章内容会比较少， 毕竟整体风格就是碎片化阅读， 想认真看书、文章的话，有很多经典的书， 我还差远了。 回归正题。 这里我们讲的还是算法部分（起算法作用），所以模型和策略还是原样。 还记得这题不？ 你觉得应该怎么做? 不知道 从非常小到非常大全部试 从一个随机位置开始 公式变换找最小位置 submit 标准方程 之前，在讲梯度下降法时， 强行PASS公式变换。但我们都知道，在高中初学抛物线方程时，叫配项还是配方，把式子转成 \\(y=a(x-t)&#94;2+b\\) 的形式，最低点就在x=t处。 我们现在要给J(w)进行配方吗？已经是这个形式了， 搞不定。那怎么办？想想最低点有什么特点、 性质？（用填空更好，但这判断正误太难了） 最低点最小 一阶导数为0 二阶导数为常数 不知道 submit 求导 高中学导数或大学学微分会知道，二次函数的极值点的一阶导数为0，这是已知条件， 看来可以用了。 不过， 和一元二次方程就只有一个最小值不一样的是， 现在是矩阵、 向量的求导， 是否有多个一阶导数为0的极小值呢？ 应该没有吧~~~我也不知道 矩阵和向量 直接对 \\(J(w) = (h(x) - y)&#94;2\\) 求导吗？我写的是简化版函数式，求和和上下标都省了。 已知， 训练集 X是个 \\(m*n\\) 维的矩阵， 或者 \\(m*(n+1)\\) 的矩阵(把b看作0项的话）。 y 是 \\(m*1\\) 维的向量。 $$h(x)=\\sum \\limits&#94;n_{i=1}w_i*x_i$$ 所以, J(w)要写得更漂亮点，使用一些先进的符号，不要用求和、 上下标之类的，档次太低。 使用哪方面的符号来改写J(w)? 微积分 数学分析 矩阵 概率论 不知道 submit h(x)的矩阵化 先定义， 使用小写的w 直接代表参数向量， 大写的X 代表数据集X， y还是y, &#94;T代表矩阵转置。 从内到外， 先改h(x), 就是 w 这个 \\(n*1\\) 维的系数向量 和 X 这个 \\(m*n\\) 维的矩阵相乘得到一个 \\(m*1\\) 维的预测向量？ 所以h(x)改写成 ？ submit 平方和的矩阵化 -y好说， J(w)求平方后再求和呢？ 已知 h(x)-y 是个向量。 一个向量v的平方和就是？ v和v的叉乘 v和v的内积 我也编不出来了 submit 矩阵化结果 当然， 内积是个符号， 还要再换个形式。 \\(n*1\\) 维的向量v和v的内积， 就等于 \\(1*n\\) 维的 \\(v&#94;T\\) 和v的乘积 \\(v&#94;Tv\\) 。 请代入之前的结果， 写出完整表达式 submit 简化版求解 Ng的视频和讲义用到了矩阵的迹及一堆定理， 太复杂。 Bekeley里呢， 就非常简单了。 先从简单的讲起。 已知 \\(J(w) = (Xw - y)&#94;2\\) 还是复合函数求导： $$ \\frac{df}{dw}(w) = 2*(Xw-y)*\\frac{df}{dw}(Xw-y) $$ 关键就是后面一部分的结果， 虽然也简单，但我觉得这种显性地思考过比潜意识觉得对好一点。 先来个问题， \\(\\frac{df}{dw}(w)\\) 这个应该是什么结果？ w是个 \\(n*1\\) 维向量。 一个实数 n*n维矩阵 n*1维向量 submit 对向量求导 某函数对向量求导、偏导（表达没错吧？）就是这个函数对每个分量都求一下， 结果也就是一个向量。 现在， 1. \\(\\frac{df}{dw}(w)\\) 的结果会是 \\(n*1\\) 的向量。 2. Xw-y 是 \\(m*1\\) 维的向量， 因为是m行的数据 \\(\\frac{df}{dw}(Xw - y)\\) 中， y对w来说是常数，微分就没了， Xw是个 \\(m*1\\) 维向量，对 \\(n*1\\) 维的w求导，那对w的n个分量,都有m个结果， 所以是 \\(n*m\\) 维。 那 \\(\\frac{df}{dw}(Xw - y)\\) 的结果应该是什么？ submit 求导的结果 \\(\\frac{df}{dw}(Xw - y)\\) 是 \\(n*m\\) 维的，又加上Xw是w的一次函数，所以，符合 \\(X&#94;T\\) 的特征，那结果没跑了吧。 维数上好理解，但正好是 \\(X&#94;T\\) 还是蛮神奇的，我也不知道怎么解释。线性代数就没学好，这部分已经到矩阵论了吧。 三个部分都有了， 根据矩阵乘法要求， 调一下顺序得： $$ \\begin{aligned} \\frac{df}{dw}(w) & = 2X&#94;T(Xw-y) \\\\ & = 2(X&#94;TXw - X&#94;Ty) \\end{aligned} $$ 下一步呢？ 继续化简 令结果=0 submit 求w 请写出最终结果， 求逆请写&#94;(-1), 转置 仍是&#94;T, 仍然不要用乘号* w= submit 总结 简化版我也写得很啰嗦， 实际上不解释矩阵求导、向量求导的话， 从 \\(J(w)=(Xw-y)&#94;2\\) 到结果只要三五步而已。 严谨版证明 从 \\(J(w)=(Xw-y)&#94;2=(Xw-y)&#94;T(Xw-y)\\) 开始，展开得 $$J(w) = w&#94;T X&#94;T Xw - w&#94;T X&#94;T y - y&#94;T Xw + y&#94;T y$$ Ng在这里直接引入迹 tr(A)的概念及一堆结论。 如果函数 \\(f:\\mathbb{R}&#94;{m \\times n} \\mapsto \\mathbb{R}\\) , 也就是 \\(m*n\\) 维矩阵求成一个实数， 定义： $$ \\nabla_Af(A) = \\left[ \\begin{matrix} \\frac{\\partial{f}}{\\partial{A_{11}}} & \\cdots & \\frac{\\partial{f}}{\\partial{A_{1n}}} \\\\ \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial{f}}{\\partial{A_{m1}}} & \\cdots & \\frac{\\partial{f}}{\\partial{A_{mn}}} \\\\ \\end{matrix} \\right] $$ 迹trace的定义: 前提： \\(A \\in \\mathbb{R}&#94;{n \\times n}\\) , 即A是方阵， 则 $$tr A = \\sum&#94;n_{i=1}A_{ii}$$ 因为要求比较丰富的线性代数、矩阵论知识， 不可能在这里补充， 就想到哪里讲哪里了。 所以， J(w)的结果是个什么东西？ 一个实数 一个向量 一个矩阵 一个方阵 submit 对方阵求导 接下来的证明， 涉及几个定理： 实数的迹 等于实数本身, \\(tr \\alpha = \\alpha\\) 。可以对J(w)求迹， 进而再使用迹的其他定理 \\(tr AB = tr BA\\) 和 \\(tr ABC = tr CAB = tr BCA\\) , 给矩阵相乘顺序作调整。 \\(tr A = tr A&#94;T\\) 最重要的是： 如果 \\(f:\\mathbb{R}&#94;{m \\times n} \\mapsto \\mathbb{R}, 且 f(A) = tr AB\\) ， 则有： \\(\\nabla_A tr AB = B&#94;T\\) \\(\\nabla_A tr ABA&#94;T C = CAB + C&#94;T A B&#94;T\\) 这几个定理的证明我不太清楚哪里有， 好像不是线性代数里的内容。 接下来， 就是对展开式的进一步变换了。 $$J(w) = w&#94;T X&#94;T Xw - w&#94;T X&#94;T y - y&#94;T Xw + y&#94;T y \\\\ = tr (w&#94;T X&#94;T Xw - w&#94;T X&#94;T y - y&#94;T Xw + y&#94;T y)$$ 第四项 \\(y&#94;T y\\) 求导肯定为0。 第2、3项互为转置，求导结果相等，只看其中的 \\(y&#94;T Xw\\) ，把 \\(y&#94;T X\\) 看作是B, 所以这两项求导结果就是 \\(2*(y&#94;T X)&#94;T = 2 X&#94;T y\\) 第一项最复杂， 跟 \\(tr ABA&#94;TC\\) 最相似，有 \\(A和A&#94;T\\) 。来问题了, 我们把 \\(X&#94;T X\\) 看作是B呢还是C呢？ B C submit 迹求导 把 \\(X&#94;T X\\) 看成C， 那现在的顺序是 \\(tr w&#94;T C w\\) , 要把顺序从ABC改成CAB， 变成 \\(tr(w w&#94;T X&#94;T X)\\) 所以 \\(A, A&#94;T\\) 之间的B 就可以用 单位矩阵来表示。 这又是个种技巧，也许就叫 单位元 技巧。 然后代入结果， 就得到： $$ \\nabla_w tr(w&#94;T X&#94;T X w) = X&#94;T Xw + (X&#94;T X)&#94;T w \\\\ = 2 X&#94;T Xw $$ \\((X&#94;T X)&#94;T=X&#94;T X\\) 是叫什么来着？ 所以综合一下得到： $$ \\nabla_w J(w) = 2X&#94;T Xw - 2 X&#94;T y $$ 令上式等于0， 求得： $$w = (X&#94;T X)&#94;{-1} X&#94;T y$$ 恭喜 线性回归的标准方程 Normal Equations 内容就是这么多， 又叫 closed form 什么的。 其实就是二次函数只有极小（大）值点的导数为0。所以对J(w)求个导， 令结果=0， 就得到极值点了。 这是个理论吧， 实践中用这个的应该比较少。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"机器学习","title":"线性回归标准方程"},{"url":"http://sndnyang.github.io/linear-regression-foundation.html","text":"说明 本文参考以下文献： Andrew Ng在斯坦福的cs229 讲义， cs229 在下文笔较烂， 恐贻笑大方。 不过因为是markdown 写的， 有不足， 改进比较方便， 所以欢迎提出意见及建议，找出问题， 谢谢。 导读 关于机器学习的概念、定义，我写不明白。 监督学习、无监督学习的区别， 分类问题和回归问题的区别也写不好，所以这里假设读者对这些概念都有一定了解。 本节要讲的内容就是线性回归及其求解。 一言不合就问问题。 同学你知道什么是线性回归吗？ 知道 不知道 submit 是什么？ 线性回归是什么？ 线性简单，代表模型、理论函数是 y=w*x+b, 这里的x可以是一个变量，也可以是向量。 回归是什么？建议找本统计学的书来看看， 比如陈希孺《概率论与数理统计》第258页开始， 介绍回归分析的基本概念。 我们假设了模型，但模型的参数未知， 回归分析就是去分析、求出参数的值， 并达到某个效果。 和分类问题相比， 分类是输出\"类别\"，离散的值， 回归输出的是连续的值。 为什么？ 为什么是线性回归， 首先线性肯定比非线性简单， 其次跟线性代数、 统计课程能连上。 但为什么线性模型足够有效，超过我的知识水平了。 总览 机器学习有三要素（李航《统计学习方法》统计学习方法的三要素）： 模型 策略 算法 所以，本文内容相应的就是： 模型--线性模型， y=w*x+b 策略--确定模型（参数）选择的准则（评价方法），即损失\\误差函数。用策略一词，是有点不习惯。 算法--求解最优模型的过程。 模型 前面说过多回了， 线性回归， 线性方程 y=h(x)= \\(\\sum \\limits_{i=0} w_i*x_i\\) , 这里把b看作是 \\(w_0 * x_0\\) 这里采用这种标记法，另有一种常用的是 \\(Y=\\theta&#94;TX\\) 。只是符号问题。 接下来， 我们就要考虑求最优模型（参数）。 策略 为了求解最优模型， 需要采取一定的策略。机器学习里的策略大概就是指模型选择的准则。 对线性回归来说，我们考虑让预测值和实际值之间误差最小作为标准，选取损失函数。 篇幅限制及原课程的安排， 所以， 推导具体的损失函数请看 概率解释 是否已看过概率解释部分？ 看了 没有 submit 损失函数 上结论， 我们选择评估误差的标准为 \\((h(x) - y)&#94;2\\) , h(x)=w*x是预测值，y是实际值。平方强调了误差越大，影响越大。 这是单个数据点的误差， 所以整个数据集的误差就是： $$ J(w)=\\sum&#94;m_{i=1}(h(x&#94;i) - y&#94;i)&#94;2 $$ 于是， 任务就变成了对上式求最小化（误差最小），并求出最小是h(x)的参数w。 $$ \\min\\limits_w\\sum&#94;m_{i=1}(h(x&#94;i) - y&#94;i)&#94;2 $$ 算法 如果了解、熟悉梯度下降法的同学已经可以不用看了。直接点下一段到结束吧！ \\(x&#94;2\\) 平方函数有什么特点呢？一个开口向上的抛物线， 对吧？所以它确实存在最小值。而损失函数也会存在最小值， 这个我也不会证，但应该没有疑义吧？ 在训练集数据x,y都已知的情况， 损失函数的自变量是否只有一个w了？损失函数的值会随着w的变化而变化。 我们假设一个一维w对应的损失函数如图： 人眼能估计最小值在哪个位置对吧， 先说明下，我写的函数是 \\(y=3*x&#94;2-2*x+5\\) 。所以最小值不是在x=0。 你觉得应该怎么做? 不知道 从非常小到非常大全部试 从一个随机位置开始 公式变换找最小位置 submit 从随机状态开始 暴力搜索地从非常小到非常大地尝试肯定是不可取的，又慢又试不完。PASS。 公式变换是可行的， 但它是标准方程或闭型部分的内容， 请看 下一篇 。PASS。 只能从某个随机值开始，以前学的算法多数是确定性算法， 貌似只有快速排序里可选地提及随机选择。 而现实中， 类似的搜索性问题多半是从随机初始状态开始的。这可能算是个很重要的 随机化 思路。 我们现在随机选择了x=5这一点（实际可能喜欢用0向量）， 在上图的红点有个X。这里是个坡，我们放个小球，会自然地顺着坡滚下去。那计算机程序怎么办呢？一维的w在图上还只有左右两个方向，二维的w加上y值形成3D图，每个点都是360度连续空间 怎么选？ 随机选 采样求平均 求坡度 求最小 不知道 求反函数 submit 坡度和梯度 坡度是什么呢？ 极值 导数 反函数 指数 对数 二阶导数 submit 导数 很明显了， 我们要求导！！！ 一维的w，也就是只有一个变量， 求导肯定对的，非左即右。 那2维、多维的w呢？拿2维来说，就相当于x轴和y轴，要同时在两个变量上求导~~~所以， 分别对两个变量求偏导。并可以类推到更高维。 高数、线代没学好，这里强词夺理、囫囵吞枣。 求偏导 终于， 绕过来了， 需要要对J（w）函数求偏导，找出当前点的\"滚动\"方向。写作 \\( \\frac{\\partial}{\\partial w}J(w)\\) 。 其中,忽略求和符号后， \\(J(w)=(h(x) - y)&#94;2\\) 。一个简单的复合函数。 本以为，终于可以有填空题了。结果发现失败了。 复合函数求导h(x)=f(g(x)),则h'(x)= ?不需要*符号 submit 继续求导 复合函数的求导法则知道了， 来推导本例子。 $$ \\begin{aligned} \\frac{\\partial}{\\partial w_i}J(w) & = \\frac{\\partial}{\\partial w}(h(x) - y)&#94;2 \\\\ & = 2*(h(x)-y) * \\frac{\\partial}{\\partial w_i}(h(x) - y) \\\\ \\end{aligned} $$ 想实现读者自行推导过程， 辅助提醒， 但公式判断怎么做？搜都不知道搜什么。强行中断一下。 已知 h(x) = w*x, 等于向量w和x的内积 那 \\(\\frac{\\partial}{\\partial w_i}(h(x) - y)\\) 化简结果是？ w向量的i分量 x的i分量 x的和 w的和 submit 求导结果 所以结果为： $$ \\frac{\\partial}{\\partial w_i}J(w) = 2*(h(x)-y)*x_i $$ 求偏导给出了方向， 所以， 要沿着方向。那么， 把w看作点的位置，怎么滚？ w-偏导值 偏导值替换w 二者相乘 二者相加 submit 滚多远？ 所以 w是当前坐标， 要减掉偏导得到的结果（沿着梯度方向滚）， 才能使得J(w)变小。 我们能沿着这个方向没没完没了地滚下去吗？ 要知道哪怕只滚动一厘米、 一毫米， 新的位置的偏导值（向量）都有可能发生变化。 所以要怎么样？ 给偏导值向量乘上个小系数 无聊 乘上个大系数 偏导值改成倒数 submit 什么时候结束 \\(\\alpha\\) 的取值太大太小都有问题，这是工程实践上的问题，跳过。 综上所述， 我们有 \\(w=w-\\alpha \\frac{\\partial}{\\partial w}J(w)\\) ， 作为每次迭代对w的更新。 迭代总要有个停。大概可能有以下这些方案： 迭代指定次数 两次迭代的J(w)值之差足够小——这个好像比较常用。 偏导值奇迹般地等于0 算法部分总结 以上就是线性回归求解的算法，即梯度下降法 大致步骤为： 已知一个待求最优（最小或最大）的一元、多元函数 给自变量选取一个随机的起始值 对自变量的各个分量求偏导 根据偏导的方向（值）来适当更新自变量 迭代3、4步直到满足你设定的收敛或其他条件 梯度下降实践 梯度下降法在更新w上可以采取不同的策略。 从之前的公式， 我们得到完整用于整个训练集的公式为（原先的2是常数，跟alpha合并即可）： $$ w_i = w_i - \\alpha \\sum&#94;m_{j=1}(h(x&#94;j)-y&#94;j)*x&#94;j_i $$ 这个式子每次都要把整个训练集X求个和， 所以叫 批量梯度下降 Batch Gradient Descent 在数据量比较大的时候就会很慢。 那相应的就是不批量策略。比如stochastic随机梯度下降也叫增量梯度下降。 简单来说， 就是不求和，不停扫描。 Repeat { for j=1 to m { \\(w_i = w_i - alpha * (h(x&#94;j) - y&#94;j) * x&#94;j_i\\) (for all i) } } 恭喜 线性回归的主要部分就是这些， 谢谢您的参与。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"机器学习","title":"线性回归基础"},{"url":"http://sndnyang.github.io/multilayer-edge-mixture-model.html","text":"摘要 本文针对多层的网络数据--可能主要是对它进行社区发现--做了以下工作： 提出多层边混合模型(multilayer edge mixture model MEMM)，从边组合的视角（观点），探索一种通用的社区结构评估器 展示了从MEMM可以推导出多层颗粒度(multilayer modularity)和随机块模型(stochastic blockmodel) 探索以MMEM的形式，对特定形式的社区结构评估器进行分解。这样可以发现评估器的新的解释。 社区发现的说明： 多层图（多层图）的说明： 本文使用的是柱式多层图， 各层点相同。 导论 MEMM(multiply edge mixture model)： 是基于边（的贡献）的线性组合。 超模型(hyper model)，能为现存的多层社区结构评估器提供新的解释。 帮助推导出新的质量函数。 正文 基础 Reichardt and Bornholdt提出的 边反馈方案(rewarding scheme of edges), 应用于单层网络 奖励社区内存在的边 惩罚社区内不存在的边 惩罚社区间存在的边 奖励社区间不存在的边 Reichardt and White 提出的 role model， 假设只允许一些社区对之间存在边，这些社区定义为\"亲密社区 intimate communities\" 奖励亲密社区间的边 奖励非亲密社区间不存在的边 以上两种方案的相同点： 引入超参数，根据社区定义确定参数值，得到社区结构评估器。 该评估器代表了被发现社区结构的质量，进而得到最优社区分配。 这样的模型命名为 超模型（hyper model） MEMM 在边反馈方案的基础上： 添加层间边的情况 添加边的概率 如图： s和r代表层, node is代表i点在s层 A, C, v 矩阵分别表示 层内邻接、 层间邻接和社区标签 abcdefgh是超参数，混合系数 P是两点同属一社区的概率， 支持模糊划分 fuzzy partition. lambda(w)函数， 大于w，返回1， 否则 -1 hyper parameter的设定 策略： 固定值 网络结构的某个特定函数？什么意思 可行做法： 根据边的贡献比例， 选择固定值（贡献比例怎么求？） 网络变更后，重算参数 推导 之后的工作是从MEMM来推导： 模块性(Modularity) SBM stochastic blockmodel 随机块模型 这部分可以理解成拟合、 泰勒展示、 逼近、 近似什么的。 通过设定超参数 hyper parameters 的值就可以做到， 所以MEMM是个更加通用的模型 具体表达涉及 模块性、SBM的定义， 就不在这里展开了。（也还没看） 分解评估器 不太理解这块和上一块推导有多少区别。 模块性和随机块模型是否也算是评估器。 看起来没太多区别。 意义在于： decomposition of an evaluator reveals the preference of the evaluator 但evaluator是什么和如何decompose 都没讲好的感觉 实验部分 内容很多~~~ 总结 复杂，长 语言也比较复杂~~~介绍部分大段文本看着眼花缭乱 吐槽下举了个电话网络例子，感觉这个例子一点都不好","tags":"CS","title":"多层边混合模型"},{"url":"http://sndnyang.github.io/Generative-Feature-Selection.html","text":"摘要 现在的网络数据（社交网络或信息网络），不仅有链接信息， 还会有一些或噪声或重要的高维内容，比如点的属性。 也就是说，不单纯是个图数据，每个点还有若干个特性、属性。 那些对网络数据进行机器学习的任务，比如社区发现和链接预测，如果能够利用上这些附加的、额外的信息，想必会有一定的效果。 但这些点的属性或特征往往是高维度数据，对效率上影响比较大。 所以， 本文的目标就两个zhi： 降维 就是对点的特征进行选取 (feature selection) 再根据前人工作中的两个问题， 选取特征时没考虑数据的网络、图特性（存在边、连接）。 网络数据没有标准的标签（label)，一般不适合监督学习的方法。但却用聚类等方法强行给标签，强行使用监督学习，准确性很差。 所以本文提出的 特征选取方法 ： 非监督的 用生成模型（generative model)来整合连接和内容信息（即边和属性） 导论 和摘要差不多， 重复不提。 主要思想： 从点的所有特征中，选取重要的、关键的特征，记为 预特征 （oracle features，叫圣特征、神谕特征都不好吧） 对于边来说 边不是边~~~而是两个点在预特征上的亲密度（就相似度）来决定两个点是不是该相连。 首先，非预特征对边没有影响。就像自然语言处理里肯定要把停用词过滤掉， 这种数据没有作用。 其次， 想说什么来着？忘了 对于点的属性特征来说 首先， 很多属性也是没用、没影响的，只占空间不干活。 其次， 还有很多的属性或特征 本质上是重复的。就像线性方程组消元，发现一些方程可能是另外方程的线性组合。 所以，原本比较大的点属性集合就可以用比较小的 预特征 集合来代替（还可以存在映射关系） 结论 就可以用点的预特征集合 来同时表示连接和内容信息。 这样，就得到了一个模型， 类似于线性回归的那个线性方程的模型， 后面会写模型具体的形式 然后，再去定义这个模型对应的： 策略。 即损失函数，要优化的目标。 算法。 如何进行优化。 *模型、策略、算法，机器学习三要素，《统计学习方法》的描述方法 题外话 生成图模型，generative graph model， 比如AGM 都是先定义模型、模型表达式，再定义策略、损失函数，最后才用算法来求出模型解空间里 最优的每个参数 正文 定义 Attributed Network 属性网络： G = (V; E; X)， X是n个点的D维属性、特征向量 s 是D维01向量， 1代表该位置是预特征， 0则否 diag(s) 则是把s 拉成对角矩阵， 后面计算用得到--光点积不够用 目标是求出 预特征 集合 对连接信息建模 如之前所说： probability of a link is determined by the oracle affinity between two nodes 所以要定义 Oracle Affinity Oracle Affinity dot product of oracle features of two nodes $$ a_{ij}=x&#94;T_i diag(s) x_j $$ 边生成概率定义 用某个转换函数（比如sigmoid）将上面的 \\(a_ij\\) 转成个概率值 概率值再用伯努利分布来决定边是生成还是不生成， 如下： $$ p_{ij}=F_g(a_{ij}) \\\\ E_{ij} \\sim Bernoulli(p_{ij}) $$ 整个图的概率 从定义上， 在给定 预特征 oracle features时， 整个网络的概率为： $$ P(G|s) = \\prod_{(i,j)\\in E}p_{ij}\\cdot \\prod_{(i,j)\\notin E}(1-p_{ij}) $$ 最终式 把 \\(a_{ij},F_g\\) 代入上式， 求个-log, 化简得： \\(\\cal{L_G}=xxxx\\) 省略~~~ 对内容建模 关键就是得到一个 预特征向量 和 原特征向量的映射关系。 所以可以是：（也可以使用和边相似的建模） $$ \\mu_i = F_c(diag(s)x_i) \\\\ x_i \\sim \\cal{N}(\\mu_i, \\sigma&#94;2\\bf{I}_D) $$ 为简便， Fc就等于左乘个 D行D列的投影矩阵 \\(\\bf{W}\\) 使用以上模型的话， 那对内容的最大似然值优化 其实也就等效于 最小化误差平方和， 再加个控制项得： $$ \\cal{L}_C=||X&#94;Tdiag(s)W - X&#94;T||&#94;2_F + \\beta||W||&#94;2_F $$ 二者结合 就是 $$ \\min \\limits_{s,b,W} \\cal{L}_G + \\cal{L}_C $$ 限制条件有， s向量里取值0或1，长度D，向量和=d 对齐还没掌握~~~ 优化 出于优化难度，改写优化式： $$ \\begin{eqnarray} & \\min \\limits_{s,b,W} & \\cal{L}_G + \\cal{L}_C + \\lambda||s||_1 \\\\ & s.t. & 0 \\leq s_p \\leq 1, \\forall p=1,...,D \\end{eqnarray} $$ 优化过程并不特殊， 貌似和SVM的优化过程SMO是一样的。 先固定W， 优化方程的s和b 再固定s和b， 优化方程的W 偏导方程就不写了。 总结 本文定义、 概念描述准确，逻辑清晰，没有太复杂的东西。 总结不太会写， 还不敢评价论文质量。 不过本文的实验部分写得比较简略~~~别的很多论文都3、5页的。本文将将一页出头。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"CS","title":"Unsupervised Feature Selection on Networks: A Generative View"},{"url":"http://sndnyang.github.io/Community-Role-Detection.html","text":"摘要 再来一遍， 不权威定义：社区发现大概就是发现高密度的点群， 群内互连较多；连到群外的较少 之前社区发现和role detection（作用检测）两个领域各玩各的， 本篇论文就是把这两个结合起来， 以一种统一的模型结合，来同时处理这两个任务， 并且要做到更好的效果。 基本观点 正确地划分出社区， 能促进对点的功能、角色的检测。 正确地识别点的功能，可以得到更好的网络模型，社区发现也就更好。 例子 如图： 两个群、 3种角色 主要贡献 写了三个 Studying a novel problem of integrating community and role detection in information networks. 这也能算 :( Proposing a unified probabilistic generative model that defines the link generation probability based on both community and role labels of nodes, and a Gibbs sampling based inference algorithm is proposed. 在三个人工数据和两个真实数据上实验， 证明了方法对社区/功能检测 和 链接预测上的有效性-- 这也能算？ 应该就第二条， 结合了社区、功能检测思想，提出了一个统一（通用）概率生成模型来定义链接生成概率， 并使用Gibbs采样算法（别人的）。 正文 除掉实验和公式， 内容不多。 没看过概率图模型的内容， 我估计以下步骤是概率图模型的内容 就像MMDS(Mining Massive Datasets)课程或书里写的， 社区发现分两步： 定义一个生成网络的生成概率模型 generative model 再根据某种统计推断方法， 确定生成模型里的各个参数 因为本文使用的统计推断算法几乎就是别人原版吧， 所以也就是在生成模型上有点新意——可能也就各种凑合。 定义生成模型 原模型 基于 Mixed Membership Stochastic Blockmodel (MMSB) 4 MMSB的连接生成过程（边生成）如下： For each node i: - Draw a group membership distribution vector πi ～ Dirichlet(α) For each node pair (i, j): - Draw node i's latent group Zij ～ Multinomial(πi) - Draw node j's latent group Zji ～ Multinomial(πj) - Draw the link Eij ～ Bernoulli(SZij ;Zji) S: group-group interaction probability matrix 改进 Mixed Membership Community and Role (MMCR) Model 大概就是给点多加一个role功能的向量 总结 本篇或许是比较新颖地把原本不相关的社区发现和功能检测进行了关联--假设他们是第一个吧。 但给我感觉比较水， 重复地讲那简单的思想原理——不过其他论文也经常重复当强调 对整个过程用了种理所当然的描述——the collapsed Gibbs sampling algorithm is straightforward。不得不去看Gibbs这个算法的论文。 伪代码也没有 实验数据非常小。 百来个点， 效果好了， 性能没实验， 复杂度说是平方 感觉英文写作水平不是很好，不知道是真的， 还是我英文差。","tags":"研究","title":"社区及角色发现"},{"url":"http://sndnyang.github.io/Communities-Ground-Truth.html","text":"摘要 社区发现的挑战 社区定义的多样性、不确定性 a plethora of definitions of a community 算法困难， NP-hard intractability of algorithms 评估困难，缺少可靠的参考 lack of a reliable gold-standard ground-truth 本文工作 定义 ground-truth 根据230个大规模的实际网络数据， 包括社交、协作、信息网络 这些数据里的点有明确的归属关系，属于 进而可以用这些信息来定义参考（ground-truth） 社区的可靠、可信的标记标签 量化评估 量化评估网络社区的不同结构化定义， 评估敏感度、 稳定性和性能 导论 贡献 A possible solution would be to find a reliable definition of explicitly labeled gold-standard ground-truth communities 贡献： 对230个大规模的社交、信息网络，用一种可靠的方法，定义了参考（ground-truth）社区 基于ground-truth，量化评估了网络社区的13种常用的结构化定义， 并检验了它们的稳定性和敏感性 扩展了局部谱聚类算法， 得到一种无参社区发现方法， 可支持百万点级别的网络检测 数据集评估 社区参考标准 社交网络的社区， 基于特定主题的分组 购物网络， 基于层次化组织的货物分类 科研合作网络， 基于相同的出版组织（会议等） 好处 与社区发现工作的隐含前提一致： 社区内的成员会有相同的功能或性质 这是网络的组织原则 其他方案 用成员点对点的相似度， 以属性来评估社区 来源：Y.-Y. Ahn, J. P. Bagrow, and S. Lehmann Link communities reveal multi-scale complexity in networks 文章链接 数据预处理 无权重无向静态图。 组里成员可能无外连， 视作独立的社区 参考社区可内嵌、 可重叠 社区评分函数 思想： 给定一个社区评分函数， 把它发现的高分点集视作社区 社区内点的连通度高， 社区间连通度低。 分类 基于内部连通性 内部边密度 内部边数 平均度数 度数中位数上比例 三角参与比例 基于外部连通性 扩展 割比例 cut ratio 内外部连通性结合 传导性 conductance 标准割 normalized cut 最大出度分数 平均出度分数 Flake出度分数 基于网络模型 模块性 因公式麻烦， 请看图片 实验结果 计算每个标准社区的的这13种分数 计算一个相关矩阵 correlation matrix 设定相关阈值， 比如 0.6 分成四组 评估社区评分函数 to develop an evaluation methodology for network community detection 社区效果度量 采用一种公理化方法（然而只有第一步）： 定义四个社区效果（goodness)度量 对\"好\"社区的直观定义进行规范形式化(formalize) 区别 社区评分函数量化了一个集合的\"社区相似度\" 效果试题量化社区的满意度(desirable property) 分类 对点集S 的效果度量g(S)有： 可分度Separability： g(S) = 内边数/外边数 密度Density: g(S) = 边数/（2点组合数） 凝聚度Cohesiveness: S诱导（生成）子图的最大导率(conductance) 聚类协同系数Clustering coefficient：没有准确描述，得看其他论文 实验设置 步骤： 有很多标准社区Si 对每个评分函数， 把标准社区按该方法的分数降序排列 计算前k个标准社区的效果度量值， 并计算累积平均 直观思路： 好的社区评分函数与效果度量完美相关（正或负） 则效果度量的平均值 应该 随k 单调 假设社区评分函数乱排序， 效果度量平均值将是k的固定函数 constant function 实验结果 社区评分函数稳定性 Robustness Community perturbation strategies 点交换： 随机选择一条边(u, v), \\(u \\in S, v \\notin S\\) ， 对S 删除u，加上v 随机： 随机选择 \\(u \\in S, v \\notin S\\) ， 对S 删除u，加上v 扩展: 随机选择 \\(u \\in S, v \\notin S\\) ， 对S 加上v 收缩： 随机选择 \\(u \\in S, v \\notin S\\) ， 对S 删除u 量化差别 h(S, p)代表干扰后， 则 Z-score: E是期望， Var 是方差 高Z-score意味着什么？ 标准社区的期望分数比扰动后的低， 所以对f评估函数来说， 标准社区比扰动后好。 实验 基于种子点的社区发现 基本算法 给定： 图G、 种子节点s、 评分函数f 步骤： 用PageRank-Nibble， 从点s开始计算随机游走分数 \\(r_u\\) 根据 \\(r_u\\) /d(u)，对点进行排序， d(u)是点u的度 对前k个点， 计算社区评分函数 f(Sk) 检测f(Sk)的极小值，发现一到多个社区 if 要发现一个社区 找到第一个局部最优的fk else 找到全部的局部最优 英文版描述： 个人总结 本文定义标准社区思想非常简洁。 新提出的社区发现方法， 里面极小值的使用不知道是什么原理。 实验部分长， 但真正做研究也确实应该这样认真地做实验分析， 不同的评估函数、衡量标准、 干扰等等。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"CS","title":"Defining and Evaluating Network Communities based on Ground-truth"},{"url":"http://sndnyang.github.io/machine-learning-define.html","text":"什么是机器学习 定义： 从数据中获取到的经验，使某方面的表现更好(如更高的准确率、识别速率) 为什么使用机器学习 规则难定义或未知 程序编写复杂 从数据中学习中相对容易 使用情形示例： 无法人工编写出全部规则 (规则未可尽知) 无法准确定义 (规则难以言表) 快速决策 面向大量用户 所以 机器学习是编写复杂规则系统的一种替代方法","tags":"机器学习","title":"机器学习定义"},{"url":"http://sndnyang.github.io/other.html","text":"数据库 db2 db2 变更alter db2 导出 db2 特殊查询 db2-jdbc db2 配置远程数据库 系统工具 端口监听 grep技巧 find_grep 命令行工具 tar压缩 date makefile vbox共享文件夹 awk-sed ctags+vim tag技巧 cscope技巧 shell shell文件.html shell技巧.html shell时间.html shell_string.html shell变量控制.html shell替换与插入-ru.html ksh ksh_auto_complete.html ksh判断.html ksh手册.html ksh数学运算.html ksh数组.html ksh语法.html ksh参数处理.html ksh自动补全.html profile设置 论文 FOCS总结 FOCS notebook 基于进化算法的社区发现综述 社区重叠综述 进化多目标方法在动态网络聚落检测中的应用-总结 MOOC 数据分析与统计推断项目翻译 生物信息学算法课程概述 编程语言 python python web框架html模板 java java乱码.html java-Comparator.html java错误.html java-Generic-Iterator.html","tags":"other","title":"其他"},{"url":"http://sndnyang.github.io/slides_set.html","text":"人工智能 alphago 数据挖掘 多层网络社区检测综述 快速重叠社区发现","tags":"研究","title":"幻灯片集合"},{"url":"http://sndnyang.github.io/sml-linear-regression.html","text":"什么是机器学习 定义： 从数据中获取到的经验，使某方面的表现更好(如更高的准确率、识别速率) 为什么使用机器学习 规则难定义或未知 程序编写复杂 从数据中学习中相对容易 使用情形示例： 无法人工编写出全部规则 (规则未可尽知) 无法准确定义 (规则难以言表) 快速决策 面向大量用户 所以 机器学习是编写复杂规则系统的一种替代方法","tags":"机器学习","title":"可扩展机器学习第三周-线性回归"},{"url":"http://sndnyang.github.io/union-find-optimize.html","text":"方法 1 带权重快速合并 好处: 优化 快速合并 ，避免树的层次过多 随时记录每棵树（子树）的大小 通过将较小子树的根挂在较大树的根下，来获得平衡 数据结构 比快速合并算法，增加一个大小为N的整型数组sz。 sz[i]代表以i为根的对象个数。 查找 与快速合并相同， return root(p) == root(q) 合并 将较小子树的根结点连接到较大子树的根结点 更新sz数组 public void union(int p, int q) { int i = root(p); int j = root(q); if (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i];} else { id[j] = i; sz[i] += sz[i]; } } 算法分析 运行时间: 查找: 与p和q的深度成正比 即 lg N 合并: 对给定的根，只花费常数时间 lg N 结点x的尝试最多为 lg N. 路径压缩 方法: 计算出p的根结点后， 将每个被检测到的结点都指向这个根结点 实现: 两次遍历: 循环中再增加一次处理， 将每个被检测到的结点的id指向上一层的根结点。 private int root(int i) { while (i != id[i]) { id[i] = id[id[i]]; i = id[i]; } return i; } 命题: 从空集开始，N个对象的任意M次操作，对数组的访问次数萍踪: <= c (N + M lg* N) lg N 其实就是 lg N 的再次求对数的样子。 In computer science, the iterated logarithm of n, written log n (usually read \"log star\"), is the number of times the logarithm function must be iteratively applied before the result is less than or equal to 1. 本算法理论上非线性复杂度， 实际上可以看作线性。","tags":"算法","title":"并查集优化"},{"url":"http://sndnyang.github.io/word2vec-2-mindmap.html","text":"译自： 原文链接 (没有找过作者， 随手就翻译了) 思维导图这一工具因其长于组织大量任务、材料信息，在头脑风暴、 计划和问题解决等领域得到广泛使用、一致好评。 对思路的可视整理有助于整个思考的过程， 并且模拟了我们人类思考时获取脑中知识的方式。 现今有很多工具可以帮助我们画出思维导图， 但还没有一个能自行生成的， \"生成\"是指从文本（语音）内容中提成。 为了做到这一点， 我花了最长的时间（至今快8个月了）， 研究如何结合文本挖掘和图论做成一个框架来生成思维导图（给定一段文本）。 当然， 第一个问题就是， 任意一段文字都不会只有那么一种可行的思维导图。 只是， 如果你要构建自己的思维导图， 有这么一个自动工具， 可能会给你更多的思路和洞见， 特别是头脑风暴时， 或帮你查缺补漏。 那我们先来看看一个思维导图的样式—— 两个关键点： 思维导图并不简单地是一棵树， 不只是递归地将主题划分成子主题。 它本质上更像图， 连接项在语义上是相关的。 正如‘夜晚'可能会让你想到‘白天'， 思维导图中， 意义相反的两个概念之间也很可能存在连接。 还有诸如使用图片强化概念等其他点。但这些并不是本文的主旨（我的设计师风格创造力糟透了）。 有备无患 ， Heres 这篇文章能帮助你熟悉构建和使用思维导图的过程。 在我上一篇博文 链接 中， 我描述了一种从文本生成Word2Vec模型的方法（使用维基的文章作为示例）。 在这里， 我将描述我使用的从 Word2Vec模型生成基本思维导图的方法。 第一步： 从文章中找出前n项 （就像我上一篇博文所说， 我只使用stemmed unigrams（一个词干的n-gram), 你可以自行采用更高阶的ngrams, 想来会更棘手（准确来说， 是当你生成n-gram的算法有效时） 这里的 n 是指思维导图中的节点数， 在我多次尝试之后， 50是个比较好的数字， 太小则信息少， 太大则噪音多。 欢迎尝试其他数字。 我使用了本文 链接 中写的 co-occurrence 方法， 列出文本的前 n 项词。 代码如下： def _get_param_matrices(vocabulary, sentence_terms): \"\"\" Returns ======= 1. Top 300(or lesser, if vocab is short) most frequent terms(list) 2. co-occurence matrix wrt the most frequent terms(dict) 3. Dict containing Pg of most-frequent terms(dict) 4. nw(no of terms affected) of each term(dict) \"\"\" #Figure out top n terms with respect to mere occurences n = min(300, len(vocabulary)) topterms = list(vocabulary.keys()) topterms.sort(key = lambda x: vocabulary[x], reverse = True) topterms = topterms[:n] #nw maps term to the number of terms it 'affects' #(sum of number of terms in all sentences it #appears in) nw = {} #Co-occurence values are wrt top terms only co_occur = {} #Initially, co-occurence matrix is empty for x in vocabulary: co_occur[x] = [0 for i in range(len(topterms))] #Iterate over list of all sentences' vocabulary dictionaries #Build the co-occurence matrix for sentence in sentence_terms: total_terms = sum(list(sentence.values())) #This list contains the indices of all terms from topterms, #that are present in this sentence top_indices = [] #Populate top_indices top_indices = [topterms.index(x) for x in sentence if x in topterms] #Update nw dict, and co-occurence matrix for term in sentence: nw[term] = nw.get(term, 0) + total_terms for index in top_indices: co_occur[term][index] += (sentence[term] * sentence[topterms[index]]) #Pg is just nw[term]/total vocabulary of text Pg = {} N = sum(list(vocabulary.values())) for x in topterms: Pg[x] = float(nw[x])/N return topterms, co_occur, Pg, nw def get_top_n_terms(vocabulary, sentence_terms, n=50): \"\"\" Returns the top 'n' terms from a block of text, in the form of a list, from most important to least. 'vocabulary' should be a dict mapping each term to the number of its occurences in the entire text. 'sentence_terms' should be an iterable of dicts, each denoting the vocabulary of the corresponding sentence. \"\"\" #First compute the matrices topterms, co_occur, Pg, nw = _get_param_matrices(vocabulary, sentence_terms) #This dict will map each term to its weightage with respect to the #document result = {} N = sum(list(vocabulary.values())) #Iterates over all terms in vocabulary for term in co_occur: term = str(term) org_term = str(term) for x in Pg: #expected_cooccur is the expected cooccurence of term with this #term, based on nw value of this and Pg value of the other expected_cooccur = nw[term] * Pg[x] #Result measures the difference(in no of terms) of expected #cooccurence and actual cooccurence result[org_term] = ((co_occur[term][topterms.index(x)] - expected_cooccur)**2/ float(expected_cooccur)) terms = list(result.keys()) terms.sort(key=lambda x: result[x], reverse=True) return terms[:n] get_top_n_terms 函数实现了这个功能， 我希望我写的 docstring 和 注释很好地解释了整个过程（结合起那篇论文）。 如果你有时间， 足够耐心， 你可以看到你Word2Vec模型里的整个词库（entire vocabulary）， 并找到你想加入到你的思维导图里的那些项。 这样做大概能得到最好的结果（就是太辛苦）。 第二步： 选定根节点 根结点是最能表达思维导图中心思想的。 相比起整个词库entire vocabulary， 选中的结点个数小上许多， 所以， 也许最好就是 手工选定根结点的项。 或者， 使用出现频率最高的（has the highest occurrence）。这一步也需要很多尝试（但数学科学能起什么作用吗） 第三步： 生成导图 这是至关重要的一步， 也是我花了最多时间的。 首先， 我需要定义一个项（term）的 情境向量（contextual vector） 假设， 本导图的根是‘电脑'， 连到另一个项‘硬件'， ‘硬件'再连‘键盘'， 那么， ‘键盘'的Word2Vec向量以 model[keyboard]的方式在Python/Gensim中获得。 定义这个向量为 $ v_{keyboard} $ 现在考虑构建过程。 因为你目前已经有了一些东西， 你再想到'键盘' 时， 其实已经处于'电脑'和 '硬件' 的情境（上下文）中。 所以你很难把 '键盘‘ 跟 '音乐‘ 联系起来（最起码不直接相关）。 可见， '键盘' 的contextual vector情境向量（定义为 $ v&#94;{'}_{keyboard} $ ) 一定会将方向偏向到 $ v 和 v_{hardware} $ (be biased in its direction towards). ---- 我们要计算 Word2Vec 模型的 cosine 相似度， 当然只跟方向有关。 从直觉上说， $ v_{hardware} 和 v&#94;{'}_{keyboard} $ 的影响应该大于的影响应该大于 v ， 也就是距离越远， 父节点的影响会越小。 为了考虑这个因素， 我再加入了一个 参数 情境递减因子 αα 。 数学表达如下： $$ v&#94;{'}_{computer} = v $$ $$ v&#94;{'}{hardware} = (1-\\alpha)v + \\alpha v&#94;{'} $$ $$ v&#94;{'} = (1-\\alpha)v_{keyboard} + \\alpha v&#94;{'}_{hardware} $$ 最后， 可以生成实际的导图了， 以下是我使用的算法（我希望行内注释能帮你理解我的工作） from scipy.spatial.distance import cosine from networkx import Graph def build_mind_map ( model , stemmer , root , nodes , alpha = 0.2 ): \"\"\" Returns the Mind-Map in the form of a NetworkX Graph instance. 'model' should be an instance of gensim.models.Word2Vec 'nodes' should be a list of terms, included in the vocabulary of 'model'. 'root' should be the node that is to be used as the root of the Mind Map graph. 'stemmer' should be an instance of StemmingHelper. \"\"\" #This will be the Mind-Map g = Graph () #Ensure that the every node is in the vocabulary of the Word2Vec #model, and that the root itself is included in the given nodes for node in nodes : if node not in model . vocab : raise ValueError ( node + \" not in model's vocabulary\" ) if root not in nodes : raise ValueError ( \"root not in nodes\" ) ##Containers for algorithm run #Initially, all nodes are unvisited unvisited_nodes = set ( nodes ) #Initially, no nodes are visited visited_nodes = set ([]) #The following will map visited node to its contextual vector visited_node_vectors = {} #Thw following will map unvisited nodes to (closest_distance, parent) #parent will obviously be a visited node node_distances = {} #Initialization with respect to root current_node = root visited_node_vectors [ root ] = model [ root ] unvisited_nodes . remove ( root ) visited_nodes . add ( root ) #Build the Mind-Map in n-1 iterations for i in range ( 1 , len ( nodes )): #For every unvisited node 'x' for x in unvisited_nodes : #Compute contextual distance between current node and x dist_from_current = cosine ( visited_node_vectors [ current_node ], model [ x ]) #Get the least contextual distance to x found until now distance = node_distances . get ( x , ( 100 , '' )) #If current node provides a shorter path to x, update x's #distance and parent information if distance [ 0 ] > dist_from_current : node_distances [ x ] = ( dist_from_current , current_node ) #Choose next 'current' as that unvisited node, which has the #lowest contextual distance from any of the visited nodes next_node = min ( unvisited_nodes , key = lambda x : node_distances [ x ][ 0 ]) ##Update all containers parent = node_distances [ next_node ][ 1 ] del node_distances [ next_node ] next_node_vect = (( 1 - alpha ) * model [ next_node ] + alpha * visited_node_vectors [ parent ]) visited_node_vectors [ next_node ] = next_node_vect unvisited_nodes . remove ( next_node ) visited_nodes . add ( next_node ) #Add the link between newly selected node and its parent(from the #visited nodes) to the NetworkX Graph instance g . add_edge ( stemmer . original_form ( parent ) . capitalize (), stemmer . original_form ( next_node ) . capitalize ()) #The new node becomes the current node for the next iteration current_node = next_node return g 备注： 我使用了 NetworkX 的简易图构建架构来完成了思维导图生成的核心任务（使之更易用于可视化）。 要计算 余弦距离， 我使用了 SciPy. 另外注意74和75行， 我使用了上篇博文所写的 StemmingHelper 类， 所以在思维导图中显示的是词干原始形式， 而不是词干。可以将StemmingHelper类直接当做参数 stemmer 传入。 所以， 如果你不需要词干处理， 那就把第4,74,75三行的代码干掉吧。 如果你仔细看过代码， 你会发现， 这看着很像 迪杰斯特拉的单点最短路径， 只是情境不同。 示例输出 原文链接 看着不错， 和我人工画的也挺像的。 其他 还有一些可尝试的东西。 比如加入 bi-grams 和 trigrams。 我相信能让 Word2Vec 模型更强大， 能对文本做出更好的释义。 导图中仍存在多余项， 但它给出了文本的（最？）短长度（相对其他文本挖掘任务来说）， 这种关键词提取算法（我在上文提到过的论文）似乎相当不错。 这段翻译有点不确认（There are some unnecessary terms in the Mind Maps, but given the short length of the texts (compared to most text mining tasks), the Keyword extraction algorithm in the paper I mentioned before, seems really good.） 此方法可用于头脑风暴， 从你选择的一点出发， 这代码框架会给出建议的可连项， 你再做出选择， 然后又可以得到新的推荐——就有点像思维导图助手。 无论怎样， 这都是篇长博文了， 谢谢你坚持着读完全文！（翻译也一样感谢您的阅读）。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"自然语言处理","title":"基于Word2Vec生成基本的思维导图"},{"url":"http://sndnyang.github.io/zhimind-datastruct.html","text":"数据结构可视化 DataStructVis.js--基于vis.js制作的基本数据结构可视化库（散点图基于 echarts.js） 使用说明 全局变量满足， 见下面全局变量说明 选择div容器 -- var container = document.getElementById('datastruct'); 选择数据结构类型 -- 见后面列表 创建 variable = type(container, size) 如structure = LinkedList(container, 10); 全局变量说明 一开始没有进行分析设计， 还在使用多个全局变量， 没有设置成内部变量， 全局变量分别是： nodes nodeSet edges edgeSet data network 支持数据结构 示例见（不建议在这个网页上改大的数值--起码有向图挺卡的）： demo 链表 栈 队列 森林 -- 允许多棵树 树 -- 单棵树，分支不限 二叉树 -- 分支限制不超过2 左右子树目前不能确定， 只能用 空结点（无标签）来设定。 无向图 有向图 -- 目前暂不支持在自动生成图时 设定密度 矩阵 散列表 散点图（2D） 高级数据结构基本可显示成以上结构， 所以感觉不需要。 功能列表 随机初始化 -- 都有简单版本 解析数据 -- 都可解析对应格式数据， 并重新绘制 链表： 列表数据， 如 [1,2,3] 栈： 列表数据 队列： 列表数据 森林： json数据， 不能有环， 如 {1: [2,3,4], 2: [5], 3: [6], 7} 树： json数据， 只能有一个根。 二叉树： json数据， 子结点不能超过2个。 有向图： json数据 无向图： json数据 矩阵： 二维数组数据 散列表: json数据 散点图：二维点列表， 如： [点1, 点2, 点3]， 点格式： [[x], y, class], [x]本来是为了支持3维--TODO：改掉 更新数据 -- 少量有实现自己的更新数据接口： 链表: add 标签， swap 交换标签， remove 值， removeID 移除ID 栈： pop, push 队列： enqueue, dequeue 点标记 -- markNodes([id1, id2, id3, idn]), 将相应id的点修改成红色。 交换标签 -- 待全部实现 setData -- 数据重绘， 数据格式自定义","tags":"zhimind","title":"zhimind-数据结构可视化"},{"url":"http://sndnyang.github.io/zhimind-practice-manual.html","text":"练习使用说明 文本部分同 教程说明 zhimind教程 需要在和文本文件同一路径下有一个 answer.js 文件 answer.js定义 定义函数 initData(): 自定义界面样式， 并为某div 创建可视数据结构， 见 datastructvis 定义 procedure(v): v 是数据， 定义算法过程生成的 stepLog 列表。","tags":"zhimind","title":"zhimind练习开发"},{"url":"http://sndnyang.github.io/zhimind-manual.html","text":"思维导图使用步骤 注册登录 个人主页点创建新思维导图 或 首页直接点新导图 编辑导图（存在bug， 未解决） 鼠标在点上悬停时， 会显示四个小图标（有bug,可能被另一个tooltip挡住）， 分别为： 插入子结点 删除当前结点 修改结点名称 添加新属性（即外链） 快捷键方法。 鼠标选中一点后 快捷键insert插入子结点 enter 插入同级结点（根结点不能enter） delete 删除该结点 存档。 未注册不能保存云上， 仍可以导出 json 格式文件。 查找他人的导图。 点击导航栏上的 列表。 在思维导图列表下点击一个打开导图（目前只有几个）， 点击存档可直接保存。可到个人主页查看。 教程和练习使用说明 在列表页， 查找目前存在的教程和练习。可直接打开。 关联到导图。 给导图结点添加新属性。 属性名填写练习或教程。 链接输入原页面的链接。 新建教程和练习 在个人主页点击， 输入 文本文件的链接（暂不支持平台新建，全部从外部读）， 后缀必须是 .mkd 或 .md 或在导图上添加属性时， 属性名填写 练习或教程， 链接输入文本文件的链接， 后缀必须是 .mkd 或 .md。 文件格式 主体部分与markdown 一致 新加题目格式(写成一行)： {%type |可填题干 &a&b&c 选择题的选项 @a@b答案，多选题和多空格的答案用@分开 #提示1#提示2] %} 示例 {%radio|请选择&a&b&c&d@d#随便%} 单选 {%checkbox|请选择&a&b&c&d@d#随便%} 多选 {%text|请填空:_是有意义的,_也是有意义的@教育@数学#随便写点什么#不想写也可以%} 填空 {%formula|请填空:公式_@(1+6*x&#94;3*x&#94;2)/(2+5*x&#94;4)+9#随便%} 公式填空 其他说明 填空和公式题 题干必填 ， 用 _ 代表一个空 填空使用关键字查找方式， 多关键字用普通空格（非全角）隔开——其他符号中文输入法和英文经常不一样。 示例： {%text|请填空:_是有意义的,_也是有意义的@教育 科学@数学 物理 化学#随便写点什么#不想写也可以%} 水平有限， 关键字顺序不论 感想 目标是能智能地批改 数学、 物理等客观题作业， 并智能地给以思路提示。 但还没有想法。 选择题简单， 但提示不智能——选择题还算好了。 填空题难准确。提示也很死。 公式比较都比较困难， sympy 的 simplify_logic 凑合用， 但只认普通函数， 线性代数或方程, 如 $ w&#94;Tx+b=0 $， 带 = 号， 线性代数转置 &#94;T 都不对。 理想境界 就是对多步的计算题 和 证明题进行智能批改、 提示。","tags":"zhimind","title":"zhimind使用说明"},{"url":"http://sndnyang.github.io/total-probability.html","text":"问题引入 已知色盲基因由X染色体携带，且若男性的X染色体有此基因则 男性患色盲，女性则要两个X染色体均有此基因才患 色盲，而两个X是否有色盲基因是独立的。 若色盲基因出现概率为0.08。又设男女婴出生比为110:100。问一新生儿有色盲的概率是多少？ 我们来分析这个问题。 设：\"新生儿有色盲\"为事件A，","tags":"数学","title":"全概率公式"},{"url":"http://sndnyang.github.io/svm-1-max-margin.html","text":"免责说明 本文参考以下文献： pluskid支持向量机系列博文，特别是图片引用 pluskid-svm Andrew Ng在斯坦福的cs229讲义， cs229 在下文笔较烂， 恐贻笑大方。 不过因为是markdown 写的， 有不足， 改进比较方便， 所以欢迎提出意见及建议，找出问题， 谢谢。 导读 支持向量机support vector machine(SVM)有着很长很长的故事， 然而我并不熟悉~~~略过 默认读者已经了解机器学习领域里的分类 和 回归 的概念， 若不懂， 请参考 敬请期待 和 请看下回 先下结论， SVM是效果最好、 现成可用的分类算法之一， 虽然也有被用来做回归的。 所以， 让我们从二元线性分类问题开始， 慢慢引出SVM。 分类器 分类问题定义 默认读者已经了解 分类问题， 但定义还是要写写 定义： 数据集 \\(X = [x_1,...,x_m], 其中 x_i\\) 一般是一个n维列向量， 代表一个数据点，写程序时貌似更喜欢一行代表一个点 对应类别 \\(y\\) , 用 1，-1 或 0，1 代表不同的分类。 分类问题就是要在 n维的数据空间中找出一个超平面, 希望通过这个超平面可以把两类数据完全分隔开来， 设函数 \\(f(x)\\) , 该超平面方程为 f(x) = 0, 那么定义： 超平面上的点都有 f(x) = 0 对 f(x) < 0的点， 就令 y = -1 对 f(x) > 0的点， 就令 y = 1 用于提神的第一个问题(没水平， 连问题都编不出来), 线性分类器 我们先从简单的线性分类器开始。 先来个前提， 假设数据确实线性可分。 假设该超平面的权重系数为 n维向量 w， bias偏置项为 b， x为n维列向量的点。 用于醒脑的第二个问题 分类结果-超平面 所以超平面方程可表示为： \\(w&#94;Tx + b = 0， 即 f(x) = w&#94;Tx + b\\) 我们知道， 超平面在二维空间中的例子就是一条直线, 如图所示(直接从pluskid博客上引用过来,需要自己另行制作吗？)： 多个超平面 以上图为例， 我们知道，除了已有的这条啥颜色直线， 还有无数条直线， 都可以把红蓝点正确地分成两块。 比如， 用逻辑回归， 不同的初始值就可能得到不同的直线。 既然有无数种可能， 那我们应该如何选择？我承认问题和选项有点别扭~~~还好不是关键步骤。 随机选一条 多条取平均 放弃 找出最好的一个 submit 评估方法 既然有无数种可能， 那么只要条件允许（时间、 金钱等）， 我们就要精益求精， 做到最好！ 完美！ 言归正传， 哪个超平面是最好的呢？ 那就是个新的问题——怎么评估， 评估标准是什么。 你觉得评估标准应该是什么？ w范数值最小 超平面到所有点的距离之和最大 超平面到最近点的距离最大 w范数最大 submit 评估超平面-距离 范数没用， theta 乘上个常数， 范数就变了， 但超平面不变——不进行数学推导了。 所有点距离之和 与 最近点距离 有点像， 但可能就是求所有点的距离 计算量可能大了点， 或者 数学推导出来效果不好 所以 只要找出 到相应最近点距离最大的超平面就好。（或许以后有人能找出其他方法~~~） 就是缓冲地带最大 定义 那我们说距离、 或者间隔最大， 这里距离是指什么？ f(x)的绝对值 点到超平面的垂线距离 不知道 编不出来选项了 submit 几何距离 所以， 点到超平面的垂线距离 定义为 几何距离。 关于 \\(f(x) = w&#94;Tx+b=0\\) 的超平面P 和 点z 的几何距离的计算或者说通用式， 建议不熟悉、 没印象的读者动手推导一下。 推导过程。 见 后续补充 先上结论： 点到超平面的几何距离(可能有误， 所以说要动手推导一下) $$ \\gamma = \\frac{w&#94;Tx+b}{\\|w\\|}=\\frac{f(x)}{\\|w\\|} $$ 本式有个问题， 不能做为距离使用， 请指出 ||w||未定义 ||w||是范数，范数有很多种 结果可能为负 跟类别y无关 太简单 推导太复杂 不知道 submit 标准定义 上式存在负值的可能， 距离是不可能用负值的， 所以再取个绝对值， 等效于乘以 y, 因为 f(x)小于0时, y = -1. 仍使用 gamma 记号 $$ 几何距离: \\gamma = |\\gamma| = y\\gamma = y*\\frac{w&#94;Tx+b}{\\|w\\|}=\\frac{y*f(x)}{\\|w\\|} $$ 所以， 单点到超平面距离知道怎么求了， 下一步呢？ 随机找一点的几何距离 求全部点的距离之和 找最远点 找最近点 求平均值 求平均值后找最接近平均值的一个点 submit 几何间隔 已知某个点到超平面的几何距离（几何间隔） $$ \\gamma = y*\\frac{w&#94;Tx+b}{\\|w\\|}=\\frac{y*f(x)}{\\|w\\|} $$ 我们知道， 要找的是超平面的最近点。 定义 最近点到其超平面的几何距离， 就是所有点到该超平面的几何距离的最小值， 定义为该平面的几何间隔geometrical margin （当然我这个概念理解 可能有问题， 但大体上不影响理解） 所以有 几何间隔: $$ \\tilde{\\gamma} = \\min_{i=1,...,m} \\gamma&#94;{(i)} $$ 函数间隔 一般的教程 会同时介绍个 函数间隔 functional margin。 但咱们秉承从直观分析开始， 需要时再合理推导的精神， 先不讨论这个玩意(貌似后面就没讨论过， 真可以不要）， 虽然二者等价， 但我们现在只要一个就够。 直接上定义（单点 函数距离 求最小为间隔， 公式里写的是函数距离， 省略求最小） $$\\hat{\\gamma}=y(w&#94;Tx+b)=yf(x)$$ 已知几何间隔， 那下一步呢? 不知道 梯度下降法 求最大化 蒙特卡罗模拟 酱油 submit 最大间隔 还记得我们要做什么吧？ 找出到相应最近点距离最大的超平面， 也就是几何间隔最大的 超平面。 如下： $$ \\begin{align} &\\max_{w,b} \\tilde{\\gamma} \\\\ & \\begin{array} &s.t. &y&#94;{(i)}(w&#94;Tx&#94;{(i)} + b) ≥ \\tilde{\\gamma}, &i=1,\\ldots,m\\\\ \\end{array} \\end{align} $$ 即： $$ \\begin{align} &\\max_{w,b} \\min_{i=1,...,m} \\frac{y&#94;{(i)}(w&#94;Tx&#94;{(i)}+b)}{\\|w\\|} \\end{align} $$ 为美观着想， 忽略求最近点，即求最小的min符号及i标号 $$ \\begin{align} &\\max_{w,b} \\frac{y(w&#94;Tx+b)}{\\|w\\|} \\\\ & \\begin{array} &s.t. &y&#94;{(i)}(w&#94;Tx&#94;{(i)} + b) ≥ \\tilde{\\gamma}*||w||, &i=1,\\ldots,m\\\\ \\end{array} \\end{align} $$ 一帆风顺地旅途到此结束 到上面的公式（latex给公式上标号 不会啊）， 应该是已经得到一个待优化的问题。 那我们还能再进一步优化吗？我们要真正地去发现、 分析、 探索。做科研就是这样， 但因为没有具体的方向， 我们就要有一些指导性的原则， 遇到 什么问题， 大概用什么样的思路地尝试。 技术问题， 暂不提供无标准答案的填空题， 有心的读者请先再草稿纸上写写你的想法， 你要来优化， 会怎么做？写思路。 优化 所以， 就来看这个式子 $$ \\max_{w,b} \\frac{y(w&#94;Tx+b)}{\\|w\\|}=\\frac{\\hat{\\gamma}}{||w||} $$ 首先， \\(w 和 ||w||\\) 和 \\(b\\) 是未知的， 待求的， 肯定没法下手了。 那上面的这个 \\(\\hat{\\gamma}\\) 是不是能做点文章呢? y 就是给它取正，取正 = 取绝对值， 平方也能取正， 好， 小本子上记下， 来个求平方？ 还有呢？ \\(w&#94;Tx+b\\) 是个线性关系， 对吧？ 所以， 它有什么性质， 而且还是个跟除法有关的性质呢？ 不知道 编不出来 等比变化不变 最简方程 可线性组合 submit 等比变化 那小本本上的求平方就被我们扔脑后了， 求平方还会搞得更复杂。 将 \\(\\hat{\\gamma}=y(w&#94;Tx+b) 的 w和b\\) 按比例变化时， 有两点 对目标函数的优化没影响， 这个比较直观， 因为方程变化后， 最近点还是最近点， 几何间隔（最近点到超平面的几何距离 ） \\(\\tilde{\\gamma}\\) 不变。 不等式约束不变化， 没影响。 几何间隔 \\(\\tilde{\\gamma}\\) 不变, 左式变化的比例， 会等比地影响到 \\(||w||\\) 。 那我们就开始搞坏事了~~~就要去给它变一下。 怎么变？ 等于0 等于1 除以几何间隔 除以||w|| submit 别人的解释 好吧， 我还是无法严密地说清楚这一变化的原因。 李航的《统计学习方法》就说 \\(\\hat{\\gamma}\\) 的取值不影响最优化问题的解 pluskid 写的是固定变量， 固定的方式有两种： 固定 \\(\\|w\\|\\) 固定 \\(\\hat{\\gamma}\\) ， 出于方便推导和优化的目的，选择第二种 Ng的描述为： Recall our earlier discussion that we can add an arbitrary scaling constraint on w and b without changing anything. This is the key idea we'll use now. We will introduce the scaling constraint that the functional margin of w, b with respect to the training set must be 1: $$\\hat{\\gamma} = 1.$$ Since multiplying w and b by some constant results in the functional margin being multiplied by that same constant, this is indeed a scaling constraint, and can be satisfied by rescaling w, b. Plugging this into our problem above, and noting that maximizing $$\\hat{\\gamma}/||w|| = 1/||w||$$ 继续 总之， 令 \\(\\hat{\\gamma}=1\\) 则我们的目标函数化为： $$ \\begin{align} &\\max_{w,b} \\frac{1}{\\|w\\|} \\\\ & \\begin{array} & s.t., y_i(w&#94;Tx_i+b)\\geq 1, i=1,\\ldots,m\\\\ \\end{array} \\end{align} $$ 通过求解这个问题，我们就可以找到一个 margin 最大的 classifier ，如下图所示，中间的红色线条是 Optimal Hyper Plane ，另外两条线到红线的距离都是等于 \\(\\tilde{\\gamma}\\) 的： 倒数变形 到上一步时， 我们得到了一个优化问题， 优化一个 1/||w|| , 一个倒数， 不好。 根据最优化理论——我也不懂， \\(\\max \\frac{1}{||w||}\\) 等价于 \\(\\min ||w||\\) 有什么问题吗? 没问题 不成立 不能求导 不知道 值不连续 submit 等效变形 不能用一次的， 那就改成平方， 对求最优化问题没影响， 另外求导的原因， 再加上一个参数， 最终结果如下： $$ \\begin{align} &\\min_{w,b} \\frac{1}{2}\\|w\\|&#94;2 \\\\ & \\begin{array} & s.t., y_i(w&#94;Tx_i+b)\\geq 1, i=1,\\ldots,m\\\\ \\end{array} \\end{align} $$ 最终我们得到了一个凸优化问题，或者更具体地说，它是一个二次优化问题——目标函数是二次的，约束条件是线性的。这个问题可以用任何现成的 QP (Quadratic Programming) 的优化包进行求解。 总结 复习 回忆一下， 我们整个过程做了哪些事。 从二元线性分类开始， 我们明确要求超平面， 分类器都是这么干的。 超平面有很多个， 我们就要有对超平面的评估标准。 评估标准就要计算距离， 我们就用上了几何距离。 有了几何距离， 我们就有最近点的几何距离， 就是几何间隔。 知道了几何间隔， 我们就要求出最大的几何间隔 及 对应的超平面， 绕了一圈， 又绕回到第1条。 优化公式里的 \\(\\hat{\\gamma}=y(w&#94;Tx+b)\\) 有着特殊的性质， 取值对最优化问题的解不影响。 所以我们把它设为1了。 最后再把倒数形式的 \\(\\max \\frac{1}{||w||}\\) 转成 \\(\\min \\frac{1}{2}\\|w\\|&#94;2\\) 恭喜！！！ 一路艰辛， SVM 这才完成了最简单的部分， 后面理论 的推导更加复杂， 做好心理准备吧！ 下一节 支持向量 并没有写出来 如果您觉得这种学习方式有帮助的话， 呃， 那就好~~~ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"机器学习","title":"支持向量机系列一之介绍"},{"url":"http://sndnyang.github.io/svm-2-dual.html","text":"免责说明 本文参考以下文献： pluskid支持向量机系列博文，特别是图片引用 pluskid-svm Andrew Ng在斯坦福的cs229讲义， cs229 jerrylead 博文 jerrylead-svm , pluskid 的公式显示出问题， 看着头大 在下文笔较烂， 恐贻笑大方。 不过因为是markdown 写的， 有不足， 改进比较方便， 所以欢迎提出意见及建议，找出问题， 谢谢。 导读 在上一篇 svm介绍 中， 我们已经得到了如下一个公式： $$ \\begin{align} &\\min_{w,b} \\frac{1}{2}\\|w\\|&#94;2 \\\\ & \\begin{array} & s.t., y_i(w&#94;Tx_i+b)\\geq 1, i=1,\\ldots,m\\\\ \\end{array} \\end{align} $$ 这个式子或者说优化问题 大家都说是有现成的优化方法来求解， 所以完成了一部分内容。 既然已经能用了， 为什么还要继续讲下去， 肯定是有更优的方案。 这也是明摆的事。 如果说上面的多数内容是普通读者(会来学习svm或机器学习的人)能顺利理解每一步公式的话， 后面的内容对于很多人就困难得多了， 特别是对高数没学好的（比如我）来说。 我现在强行凑文章， 也不合适， 还是得先学好数学了再说。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"机器学习","title":"支持向量机系列二之对偶化"},{"url":"http://sndnyang.github.io/conditional-probability.html","text":"问题引入 讲概念、 讲定义都是太抽象的， 还是从问题开始， 先有个直观的印象。 例一 抽奖 有M个人要抽N张入场券，若某人第k个抽，但在此之前已知前k-1个均未抽到入场券，问此时他抽到的概率是多少， 与不知道前k-1人的状态时的概率相比， 是否有变化？ 设 A：\"第k个人抽到入场券\" B：\"前k-1个人均未抽到入场券\" 已知在不考虑B的情况下， P(A) = N/M 直观分析 原题\"B已经发生的情况下， A的概率\"里包含了几个新的事件， 需要计算概率， 分别是 AB A|B B|A B A or B submit 计算概率 因为本人水平有限， 暂未实现多个填空的问题 所以请自行在草稿纸上计算出 P(B) 和 P(AB) 再进行下一步——如果直接点下一步， 也行 相关 根据 P(AB) 和 P(B), 可知 P(AB)/P(B) = N / (M-k+1) = P(A*) 这样， 我们就发现 P(A*) = P(AB)/P(B) 这是巧合吗？ 例二 人口调查 暂略 例三 肿瘤 暂略 too 总结 根据前面的例子， 可知此时A发生的概率已经有了新的意义。 我们想想， 叫什么？ 在已知B发生的条件下， A发生的概率 有了新定义， 就要引入一个新的记法， 记做 P(A|B) |后面的B 是已知条件 条件概率定义 设A，B为事件，P(B)>0，定义 P(A|B) = P(AB)/P(B) 称为是B发生条件下A发生的概率（conditional probability of the event A given the event B has occurred） 验证条件概率性质 略 乘法公式 虽然最好的方法是从问题来引出 我们需要乘法公式， 但我找不出来例子就算了， 乘法公式太简单了 由条件概率公式变形， 得到乘法公式： P(AB) = P(A|B)P(B) 意义： 计算积事件的概率， 通常可避免计算组合数 独立性即条件概率成立的条件 问题引出 设一个家庭生男孩、女孩是等可能的。 考察任一两个孩子家庭，分别求\"老二是女孩\"的概率和在\"老大是男孩\"的条件下\"老二是女孩\"的概率 一道常识题， 都是50% 设A为\"老二是女孩\",B为\"老大是男孩\" 则 S = {(bb),(bg),(gb),(gg)} A = {(bg),(gg)} B = {(bb),(bg)} AB = {(bg)} 条件概率 P(A|B) = 1/2 结论 上例中条件概率与无条件概率是一样的，说明\"老大是男孩\"这一事件对\"老二是女孩\"这一事件的概率没有影响，或者说这两个事件是独立的。 独立性定义 一般地，若P(A)=P(A|B)，或等价地若P(AB)=P(A)P(B)，称事件A，B独立(independent). 独立性判断 呃， 经验~~~ 多事件独立 事件 \\(A_1,...,A_n $相互独立，指下列 $2&#94;n-n-1\\) 个等式均成立 公式略——任意2到n个事件的组合 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"数学","title":"条件概率"},{"url":"http://sndnyang.github.io/prob-measure.html","text":"定义 学派 频率派 贝叶斯派 公理化整合 计算概率 频率说： 在系列重复随机试验中， 考察随机事件发生的频率（稳定值） 样本信息 主观说（贝叶斯派）：根据以往的资料或经验， 形成的关于随机事件可能性的印象 先验信息 等可能说（贝叶斯派）：基本事件的发生没有偏向性，都是等可能的 无信息 公理化定义 概率：定义在S（样本空间）的事件族上的实值函数 P， 满足： 非负， $ P(A) \\geq 0 , \\forall A \\in S $ 规范， 必然事件概率为1 P(S) = 1 可列可加， 互斥事件之和的概率 = 各自概率之和 性质 不可能事件概率为零 $ P(\\varnothing) = 0 $ 有限可加性 单调性 事件概率小于等于 1 对立事件 加法公式 推广","tags":"数学","title":"概率-度量可能性"},{"url":"http://sndnyang.github.io/prob-stat-intro.html","text":"概率直观定义 概率就是一个事情发生的可能性。 但这个感性的认识并不严格， 不能准确地描述 概率定义严格化 研究对象 什么问题（现象、 事件）有可能性？ 这类问题才是概率要研究的内容 很明显， 简单来分， 自然现象可分为两类 确定性现象， 没概率的事 不确定现象(可能) 无规律现象 随机现象：大量重复实验存在统计规律性的现象，概率研究对象 数理统计 研究对象 研究对象： 数据 收集 整理 分析 推断或预测 概率与统计 数理统计为概率论面向实际问题提供联系桥梁。 概率论 为 数理统计方法 的合理性提供理论证明。","tags":"数学","title":"概统介绍"},{"url":"http://sndnyang.github.io/quick-sort.html","text":"欢迎在zhimind上学习 本教程将尽我所能，指导您理解、练习并掌握快速排序算法。虽然目前仅限于使用javascript, 但算法对其他语言是通用的， 具体的语言不会影响您的理解。 左侧是javascript输入控制台，现在先告诉我们您的名字, 请输入 setName('您的昵称') 另外，有一些有用的命令: 输入 help() 来查看帮助吧！ 排序问题 现实中非常常见的一个问题就是， 给定一堆乱序的数字或名称， 给它们排好序。 之前可能已经学过以下几种排序算法: 冒泡排序 选择排序 插入排序 归并排序 堆排序 我们现在又要用新的方法实现了, 它就是 快速排序 。 在开始正题之前， 先来查看待排序数组 v[] 的数据 ， 请输入 print_list() 分治思想 不同于选择或冒泡排序逐个处理的暴力搜索思想， 我 们现在来考虑分治的思想 划分的方式 从中间位置划分，分后治之的是归并排序。 如果不指定位置划分， 有其他方法划分否？ 另外能否边分边治？ 还有哪些可能的划分方式? 随机 值大小 位置 不知道 submit 怎么选值呢? 不按位置，那我们只能按实际值的大小来划分。 那怎么选划分值呢？ 随机一个 第一个 最后一个 中间那一个 平均值 中位数 不知道 submit 准备划分 既然已经知道了划分的k值， 那么现在就来划分数组了。 目标就是让小于k的数放到左边， 大于等于k的数在右边，k在中间 想法是简单，可这不是废话吗？排好序的就有这性质啊。 那乱序的数组不排序怎么做呢？ 分析初始和目标状态 关于初始状态，只知道 k在数组第一个位置 k左边没有数，为空 右集合是一堆乱序数。 反过来看目标状态，是不是也是三个集合： k自己是一个集合 比k小的数组成一个集合 不比k小的数组成一个集合（除k） 正好对应上 既然如此， 就定义两个空集合（k本身是一个集合）， 分别叫做 left, right. 请写代码 left=[],right=[] 遍历划分 很简单， 我们只要遍历一遍数组v[]，将里面的元素按比k值的大小结果，相应地添加到left和right 请实现， 得到left, right结果 请从第二位开始从左往右遍历， 否则顺序不匹配， 也过不了 递归解决子问题 目前求得三个集合， k, 比k小， 不比k小。 然后要递归处理子问题， 首先， 当问题规模 <= 1时， 不需要再划分， 直接返回该数组-- 作为递归出口 其次， 子问题处理完毕后， 三块集合要连接， 才能向更上层返回。 请基于前面几步， 编写一个递归函数quicksort， 并调用它来处理数组v[] 快速排序优化， 请待后续分解 以上部分是最容易实现的快速排序方法， 但有浪费一些空间， 教科书上最常见的不需要这部分空间, 会有一些小陷阱， 我暂时写不下去了--打算先写点别的 如何求解 所以现在问题就是 如何求 i(index), 就是k的目标位置 从初始状态开始， k 在第一个位置，而js数组下标从0开始， 所以 i = 0 目标位置可以由什么直接决定? 不比k小的个数 比k大的个数 比k小的个数 和k相等的个数 submit 那请找出比 k 小的值的个数 so easy! 请在得到该值后（直接数个数也行），建议用循环比较（文本框问题全部写成一行)，并保存到变量里， 输入 变量或值 哪里不对？ 看起来位置是知道了， 但感觉哪里不对？ 哪里都不对 知道k位置，还不知道左右集合大小 只知道k位置，其他值没说 有哪里不对 submit 能否在计算 k 位置的同时， 把集合划分好？ 之前你是怎么统计 <k 的值的个数的？ 还记得吧？ 从左往右扫描时（或从右往左），假设不扫描k所在的第一位 是不是 看到一个小的数，就加1呢？ 如果求的是 >= k 的个数， 也是类似的， 不是吗？ 做成动画的话， 是不是 k 的位置往右移动了一格呢？ 那有什么问题吗？ 原位置留的坑怎么办？ 不知道看到哪里了？ 新位置的值怎么办？ 这些都不是问题 submit 向右移动到新位置 新位置上的值怎么办？ 只用下标记位置 用临时变量保存起来 submit 原位置怎么办？ 留空 k 我也不知道 随便找个小于k的数填上 正看到的那个小于k的数来填上 submit 顺利？ 上一步有什么问题？ 想想上上一步 新位置上的值是怎么处理的？ 有问题？我不知道 位置只是下标,原位置的实际值会被覆盖 k的位置可能会乱掉 submit 如何避免覆盖？ 当然是 两个位置的值进行交换 用临时变量保存 submit 回顾一下？ 那我们脑海里的动画似乎可以顺利进行了 选择好 k 的值——先假设是数组的第一个数， 当前位置是下标0 数组从左往右扫描时（或从右往左）， 遍历时怎么处理？ 看到一个小于k的数，k的位置向右走一格， 原位置和扫描到的位置进行交换(即小于k的值被移到了k的左边，而在原位置上的数是之前扫描过的不小于k的数，交换后仍然保持在k的右边)。 否则继续遍历， 直到遍历完整个数组。 好， 那我们开始走一遍 先选一个 k 请用代码选出当前数组的第一个值,及下标 i=0;k = ??? ，请不要直接填写具体值 循环遍历 假设从左往右扫描， 都说了边分边治，为什么不呢？难不成还等回来再处理？ 那现在的问题就是， 在我们遍历时， 能不能顺便把小的扔在一起，不小于k的扔在一起？ 假设现在左右两边集合都是空的，遍历时小的放到数组左端， 不小 的加到数组右端， 省略若干字和一步 但想想，这两个集合是互斥的，不重叠的，我把左边的搞好了，k就知道了， 右边自然就剩下并满足了，为什么要小也判断一下，大也判断一下 所以只需要在遍历时， 发现小的就放到数组左端， 像是去排队一样 , 一开始队伍长度为0， 所以我们定义一个变量 var set_length=0 , 也可以用队首队尾概念定为-1，问题都不大 现在请用代码实现 集合长度 变化过程 遍历；逐个处理；（这个暂时没想好 怎么算通过测试， 请随意输入） . 是不是只要知道k 在目标状态时的位置， 并保证左边的都小于k, 右边的都大于等 于k， 就知道左右集合大小了呢， 至于它们内部需要有序吗？我们不管。 分后才治之？ 正确实现 所以整个过程就是， 当遍历到某个值v[i]时， if (v[i]小于k) {v[set_length] = v[i]; set_length++;} 是不是有什么问题呢——对吧， v[set_length] 被覆盖了， 原来的 值就这么随意的get out了吗？所以， 我们不能简单地覆盖， 而是应该交换两个位置的值 下面就请正确实现 整个划分过程吧， 一定要正确地划分！不然不让 过哦， 用很多算法书上的 while 循环或一些算法书上的for循环遍历都 可以，只要满足k 左边的值都小于k,右边的值都不小于k, 请使用已定义 变量 l 或 k 或 global_l, global_k， 代码写成一行 请将 k 目标状态所在位置的值保存在 变量 global_l 中。 参考答案: l = 1; for(var j = 1; j &lt v.length; j++){ // 这个for 循环要写成 一行 if (v[j] &lt k){ swap(v, j, l); l++; } } swap(v, l-1, 0) global_l = l-1; 可以像归并排序那样分完再治吗？ 如果没学过归并排序， 以下几节不用细看 正如之前提到的， 在学习分治算法时， 老师通常会讲 归并排序和快速排序。 如果有学过 归并排序 , 应该有印象， 最常规的归并排序是先不断地递归划分成子问题，直到不可再划分， 等到返回时， 再将子问题进行合并。 所以是先分后治， 分完再治。 那快速排序可以这样吗？我们每层都可以求出划分的位置，是否可以 先递归求子问题， 再返回求解主问题？ 可以 不可以 submit 撒花庆祝！ Congratulations, {{ firstName }}, 你完成了快速排序的学习（中间 少了很多步还没写呢）。 如果觉得有意义, 但没完全掌握或希望复习的话， 用 reset() 重新学习吧！","tags":"算法","title":"快速排序"},{"url":"http://sndnyang.github.io/random-event.html","text":"随机试验 对随机现象的观测 样本和样本空间 试验的每一种结果就是一个样本s 所有可能的结果 就是样本空间S 随机事件 样本空间的子集 事件运算 类集合运算 省略","tags":"数学","title":"随机事件"},{"url":"http://sndnyang.github.io/tu-jie-shu-xue-xue-xi-zhi-ju-zhen.html","text":"matrix 矩阵的英文叫 Matrix， 原意是\"母体， 基质\"， 作者认为西方原意是指为了形成一个整体而填充进去的填充物。 所以 $$ \\begin{pmatrix} 1&2 \\\\ 3&4 \\end{pmatrix} $$ 在西方人的眼中很可能是数字填充在了括号的空间里。 用黑客帝国来理解呢？ 其实它的英文名是 matrix, 直译应该是母体的意思， 矩阵是个母体， 里面的数字就是啥？ 其实矩阵的译名应该不错， 矩形不一定对， 但目前只见过矩形的。 阵也是个整体， 个体站在需要的位置上。 原文这段主要在吐槽 日文里的行列译法， 而且应该是跟 他们的队列、 排队 相重了。 还有当年日本文字是竖写的， 行、列的意思与现在相反。 矩阵的出现 矩阵公认是根据方程组发明的。 比如一个方程组 $$ \\begin{equation} \\left\\{ \\begin{aligned} x+5y+2z=9 \\\\ 4x+6y+z=12 \\\\ 9x+3y+3z = 6 \\end{aligned} \\right. \\end{equation} $$ 如果方程式再增多， 写起来就非常烦琐了。 于是数学家经过抽象（也就是偷懒）， 发明了 Matrix 概念。 怎么抽象？ 提取系数 提取未知变量 submit 抽象 没错， 系数和变量分开装， 先是变成了这样(latex公式不太会写)： $$ \\begin{equation} \\begin{aligned} (1 \\ 5 \\ 2) \\\\ (4 \\ 6 \\ 1) \\\\ (9 \\ 3 \\ 3) \\end{aligned} \\times (x \\ y \\ z) = ? \\end{equation} $$ 再把所有数字放进一个括号里， 就成一个整体 A 了， $$ A=\\begin{pmatrix} 1&5&2 \\\\ 4&6&1 \\\\ 9&3&3 \\end{pmatrix} $$ 问题就成了求方程: $$ A*(x \\ y \\ z) = ? $$ 你可能会想:\"A的这些数字之间没联系， 怎么看成整体？\" 所以这就是抽象的威力了， 数学家不只是偷懒， 他们还给矩阵定义了很多严密的规则（运算规则）， 使得大家都认可了这些规则。 所以， 学数学的过程 其实也包括锻炼抽象思维能力， 甚至于具体知识用不上，就只剩下抽象、 逻辑等思维能力了， 不然可以说高等数学真的完全没用。 矩阵的现实意义 之前提到matrix 的原意， 但数学上matrix 矩阵 到底算个什么东西呢？ 教科书上喜欢的定义是： $$ 由 m \\times n 个数组成的 m 行 n列的数表 ， 称为一个 m行n列的矩阵，或 m \\times n 矩阵 $$ 只抽取了数字， 对数字背后潜藏的意义无动于衷。 最关键的是定义加减乘除（貌似很少说除）规则后， 还让你手算~~~ 这样的计算， 只知方法， 不知意义， 就很可能使学生越来越讨厌数学。 原文从销售例子介绍了一堆， 但我觉得 他说的\"看到矩阵， 在脑中就应该浮现出原来的数据表\" 不太现实。 矩阵和数据表 中间还有个方程组这一步， 甚至高观点里矩阵相乘是什么线性变换， 跟现实的市场数据就套不上了。 所以决定直接跳到乘法运算分析这部分(最后面加减也无视了)。 乘法运算为什么是行乘列？ 我们已经得到了一个这样的式子 $$ \\begin{equation} \\begin{pmatrix} 1&5&2 \\\\ 4&6&1 \\\\ 9&3&3 \\end{pmatrix} \\times \\begin{pmatrix} x & y & z \\end{pmatrix} = ? \\end{equation} $$ 不对， 课本上是这样的啊 $$ \\begin{equation} \\begin{pmatrix} 1&5&2 \\\\ 4&6&1 \\\\ 9&3&3 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} \\end{equation} $$ 为什么要竖着排？ 就是这样定义的 节约空间 好玩 不走异常路 不知道 submit 解释 现在解释这个 可能没什么意义， 纯粹科普。 但不好意思的是， 原文里 这段的例子不好打~~~放弃了。 大概意思就是， 如果矩阵乘法使用行乘行的话（不考虑列乘行这种更违背习惯的）， 假设左矩阵（被乘数矩阵？）固定了 那右矩阵再扩展的话， 得纵向延伸也就是继续加新的行， 但计算的结果（矩阵）却是横向延伸，加新的列。 延伸方向不一样。 乘数矩阵添加了第i行， 计算结果矩阵却添加了第i列。 所以改成行乘列的话， 乘数和计算结果矩阵延伸方向就一致， 第j列对应第j列。 符合从左向右看算式的习惯。 不好意思， 内容就这么多~~~ 作者其实在讨论最基本的东西， 可以说 -- 这本书的内容不看也没问题 他重点不是把各种高深的理论解释一遍， 让你全部弄懂。 作者希望的是\"把日常生活和抽象世界（数学）紧紧联系起来， 就能理解数学\"。所以应该是通过他写的这几个例子， 有这方面的意识， 懂得怎么去联系。 说起来， 这话也没错， 但对于有些知识数学知识来说， 很难跟日常生活联系起来。 比如抽象代数群环域， 据说 刚提出时， 连大数学家欧拉都无法理解， 欧拉公式都有点跟现实世界联系不起来了， 何况欧拉看不懂的。 联系的应该是他另外地方说的模板， 也就是包括日常生活经验以及以往的数学知识。 没有模板， 全新的内容学起来就会很痛苦。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"线性代数","title":"图解数学学习之矩阵"},{"url":"http://sndnyang.github.io/alphago-papers.html","text":"参考文献 原文:Mastering the Game of Go with Deep Neural Networks and Tree Search alphago-原理 郑宇,张钧波 alphago-分析 田渊栋 开源代码 alphago-code 战绩 对欧洲冠军 Fan Hui formal games were 1 hour main time plus 3 periods of 30 seconds byoyomi informal games were 3 periods of 30 seconds byoyomi 对李世石 2016.3.9 alpha胜 2016.3.10 alpha胜 2016.3.12 alpha胜 2016.3.13 李世石胜 2016.3.15 alpha胜 期待与柯洁的对战 李世石重下战书 基本定义 棋盘状态 动作 action a : action 动作 暴搜不可行！！！ 组合爆炸！！！ 围棋的可能状态数大约在 250&#94;150 国际象棋 35&#94;80 策略 减少搜索树的深度， 即先行评估位置， 避免深度递归 减少搜索树的广度， 即减少可能动作分支 方法 步骤 用棋谱数据 训练 监督学习策略(走棋)网络, 同时训练快速走子策略 对策略网络进行强化学习， 程序自我对弈 训练一个价值网络， 预测胜率 用MCTS 结合策略网络和价值网络 组成 链接：http://zhuanlan.zhihu.com/yuandong/20607684 来源：知乎 走棋网络（Policy Network），给定当前局面，预测/采样下一步的走棋。 快速走子（Fast rollout），目标和1一样，但在适当牺牲走棋质量的条件下，速度要比1快1000倍。 估值网络（Value Network），给定当前局面，估计是白胜还是黑胜。 蒙特卡罗树搜索（Monte Carlo Tree Search，MCTS)，把以上这三个部分连起来，形成一个完整的系统。 一. 策略网络学习 监督学习 训练集数据： KGS 专业棋手(5-9段)的棋谱， 大概16万局棋， 3千万种棋盘状态 学习到一个预测模型 g 状态S 预测模型 g:S->p(a|S) 概率 p(a|S) 概率最大的动作 a 模型学习算法 深度学习： Convolutional Neural Network (CNN)， 卷积神经网络 围棋对局势的评估很难建模， 抽象 CNN正好擅长抽象 另用线性模型训练快速策略 随机梯度下降 预测 输入： 棋盘状态S 输出： 所有合法动作a 的概率分布 二. 策略网络强化 对弈激励 当前版本的策略网络 与 随机的一个版本 胜 z_t = +1, 负= -1, 未结束=0 瓶颈 强化学习 存在理论瓶颈， 而且应该是被证明了， 没记。 三. 价值网络强化 步骤 输入状态S, 经过 普通策略网络 生成前 U-1步 随机采样 决定 第U步 增强策略网络 完成剩下博弈 胜负作为输出 得到价值网络， 判断该盘面的输赢概率 reduce 搜索空间的方案 减少搜索树的深度， 价值网络 value network 减少搜索树的广度， 策略网络 policy network 四. monte-carlo 树搜索 步骤 选择， 用策略网络剪枝 扩展 评估， 使用价值网络 回溯 树的组成 对 每条边(状态s, 动作a) 动作值 action value Q(s, a) 访问次数 visit count N(s, a) 先验概率 prior probability P(s, a), 初始化为 策略网络值 p(a|s) 图示： 描述 根据 ， 找到叶子结点 用策略网络计算所有可能下一步的概率， 逐个进行3 用价值网络和快速走子策略评估","tags":"研究","title":"alphago-总结"},{"url":"http://sndnyang.github.io/classical-music-week1.html","text":"4. 音乐传播过程-声波和耳朵 长波低音高， 短波高音高 空气（外耳） - 内耳 - 电化学信号 - basilar membrane（耳蜗基底膜） - 纤毛感应特定声波 - 大脑 - primary auditory nerve - auditory cortex(大脑皮层) in temporal lobe 其他相关： 1. prefrontal cortex(lobe) -- where am i in this piece 2. motor cortex parietal lobe -- movement 3. hippocampus - memory 4. limbic system, amygdala -- emotion 5. ... 6. why we like what we like. 对音乐模板、模式(template)的预测方式 nurture -- 文化培养 nature 7. 西方音乐的语法syntax leading tone -- pull toward the home pitch or tonic large leap -- reversed by following pitch harmony -- must fit with the melody chord progression -- harmonies usually return home to tonic 8. 音乐的本质 nature overtone series 乐器震动出声时， 其实不只一个音， 只是听觉系统让我们只听到最低音， 因为它声音最大 这个最低音振幅最大， 定为 fundamental tone , 其他音 overtones 后面几个音和前面做和音","tags":"音乐","title":"古典音乐导论-第一周"},{"url":"http://sndnyang.github.io/multi_layer_cd_suver.html","text":"摘要 Community Detection in Multi-Layer Graphs: A Survey 本文介绍多层网络下聚落检测问题， 并对相应算法做综述 导论 - 过 背景知识 群落/社区 community densely-connected components/subgraph relative/similar 比如： 同校、 同系、 同班是一个 community 同一个社团、 公司 同一领域的研究 多层网络模型 关系的不同方面就可以表达成多个独立图组成的多层图， 里面的每个、每层图就代表了一个方面 比如： 同学关系 微信好友 微博好友 单层图定义 a weighted graph (V,w) V is a set of vertices w is a set of edge weights: (V × V ) → [0,1]. 点映射(图层之间) node mapping is a function from a graph layer L1 = (V1 ,w1 ) to another graph layer L2 = (V2 ,w2 ) V1 × V2 → [0,1]. For each u ∈ V 1 , the set C(u) = {v ∈ V2 |f(u,v) > 0} is the set of V2 vertices corresponding to u. 对于一个facebook上的账号（个人）： twitter 上没有账号 twitter 上只有一个号--pillar(柱型) multi-layer graph twitter 上多个号 多层图定义 a tuple MLN = (L1 ,...,Ll ,IM) where Li = (Vi ,wi ),i ∈ 1,...,l are graph layers IM (Identity Mapping) is an l ×l matrix of node mappings, with $ IM_{i,j} : V_i ×V_j → [0,1] $ 例： 症状 疾病名 细菌、病毒或基因 信息网络定义： 是个有向图， 存在\"点\"到\"点类别\" 的函数映射 及 \"边\"到\"关系(边)类别\"的函数映射 异构信息网络 Heterogeneous Information Networks 点的类别 或 关系的类别个数大于1的信息网络。 异构信息网络与多层网络模型 等价 但强调不太相同 heterogeneous information networks emphasize heterogeneous types of entities connected by different relationships 主要方法 分类 聚类扩展 cluster expansion 矩阵分解 matrix factorization 统一距离？ unified distance 基于概率模型 model based 模式挖掘 pattern mining 图合并 graph merging 特点 多数只支持两层图 一层是图的原始拓扑结构信息 其他层一般是利用点的属性信息来计算相似度 聚类扩展 Cluster Expansion 论文： Scalable community discovery on textual data with relations 基于关系（文章引用）与文本属性 针对的问题 大型文档语料 -- large cocument corpus 没有同时考虑 textual attribute 和 relations(文献里的引用？) 大数据集的可扩展性scalability 多数算法基于一堆要（人工）设定的参数 思路 非监督方法 快速地找到初始的核， 作为群落的种子 核进行扩展（或合并merge)， 扩展成群落，（提高scalability) cores dictate the formation and topics of communities 核 用来表示 社区的构造和主题 步骤 4 steps: core probing core merging, 根据主题相似度进行合并 affiliation, 利用关系信息，将core扩展成初始社区 classification， 主题不相关的成员从社区中移除 第一步 Core Probing 基本思想 co-occurrence analysis: multiple objects are linked simultaneously by others, they are more likely to be able to define a coherent topic scope prob 步骤 生成每个点的outgoing relations 用关联规则来计算频繁项集(Apriori) 与 Apriori 的不同点 不使用固定的过滤阈值， 根据项集的长度决定阈值 项集存在包含关系，如果项集 S1 和 S2存在 $ S1 \\in S2 $, 不保留S1 core merging 保证了合并后核的高度一致性， 不受过滤阈值的影响 证明过程略 步骤 输入参数: core probing 返回的核 迭代： 对S中任意一对核Ki, Kj， 如果重叠， 转2 计算p-min, p-max, p- 如果 Ki, Kj的交集不为空，且 pi- 或 pj- 属于 该交集， 转4 从S 中移除Ki, 和 Kj, 加入Ki,Kj的并集。 如果遍历完， S 没有变化， 则退出 计算 p-min, p-max, p- p-min, pmax: 在特征空间内， 为 core生成了边界框 p- : 中心 图示： Affiliation Propagation 完成cores probe后，剩余的点作为 affiliated members 初始化社区C = 找到的核K ， 迭代处理： 对K中的每个点d，把所有的、其他的、能连到d的点u 加到C中 设定迭代次数， 避免关系环 或迭代中 没有新的点加入 相关概念 好像没什么用 两个社区的公共成员则为 interdisciplinary member 点和社区间的相近度(closeness)用迭代时的次数代表 Intra-Community Classification 只根据relation找到的社区 很可能误判(false hits) 要根据属性分析， 将当前的C 划分成两个集合， C' 和 C- 步骤 核K 视作是 positive example正例， 即肯定属于这个社区 选择社区C的核K（正例） 和 其他社区的核（negative example) 将所有点转换成 特征向量（feature vector）来代表它们的topical position 使用 LDA（Latent Dirichlet Allocation）来降维 使用某种分类器（SVM），将负标签的点都移除 图示 主要贡献 用关联规则、频繁项集来初始化 统一距离 Unified Distance structural and attribute similarities using a unified distance measure SA-Cluster 步骤 建立统一距离度量， 新的图 用新的图 进行聚类， 类k-means unified distance measure 基于属性增广图(attribute-argmented graph), 使用Random Walk with Restart (RWR) 邻点随机游走距离 Neighborhood Random Walk Distance l as the length that a random walk can go c ∈ (0, 1) as the restart probability attribute-argmented graph 添加属性点（attribute vertices），代表属性的值。 原始的点连接到对应的属性点上 两点上共同的属性点越多， 两点相似度直觉上就越高。 聚类算法 利用unified distance measure， 进行 k-medoids clustering（类似 k-means） 选择每个聚簇(cluster)最中心的点 其余点分配给最近的中心点。 迭代， 调整边的权重 聚类中心初始化 思想： 从vi走 l 步能到的点越多， vi越可能是中心 计算点的密度函数： 降序排列， 选择前k点作为聚类中心 聚类过程 分配点到最近的中心，即有最大random walk distance的中心点 对每个cluster ,用随机游走距离 计算\"平均点\" 寻找新的中心点，距\"平均点\"最近 不停迭代， 直到 聚类目标函数 收敛 聚类目标函数 目标是最大化 问题转化 有以上的目标函数后， 可转化成三个子问题 聚类分配 中心更新 权重调整 权重自我调整 在每次迭代时， 进行权重调整 属性 ai 权重在第t+1次迭代的计算公式为： 投票机制 majority voting mechanism counts the number of vertices within clusters that share the same attribute values with the centroids on ai 主要贡献 一个统一的距离评估方式， 将结构和属性相似度结合 带权重的自调整方法， 调节结构属性相似度的重要度 基于模型方法 Model-Based Method model-based community detection approach based on both structural and attribute aspects of a graph 步骤关键点 概率模型的构建， 结合结构和属性信息， 不使用人工定义的距离 变分法(variational approach)解决模型 构建概率模型 聚类属性图定义： X: n x n 的邻接矩阵 Y: n x t 的属性矩阵 Z: n x 1 的聚类向量， 即每个点所属的聚类 目标： 求最优化： 其中 联合概率分布 alpha - 每个聚类的点分布（vertex distribution) theta - 属性分布(attribute distribution) phi - 类间 边出现概率(edge occurrence prob) 两大问题 Z 的N个变量最大化 计算量过大， 全局最优基本不可能 计算Z的后验概率分布时， 不存在 p(Z|X,Y)的closed-form expression 变分法 variational algorithm 使用variational distribution q(α, θ, φ, Z) 来逼近原分布 并且对 variational distribution 作限制 全局最优就转成求局部最优 两个新问题 如何定义the family of variational distributions 如何从中找出最优分布， 最接近p(α, θ, φ, Z|X, Y) Parametric Family Optimizing Variational Parameters measure the distance between a variational distribution q(α, θ, φ, Z) and the true posterior p(α, θ, φ, Z|X, Y) 等价于 最大化 关系式： 图合并 Graph Merging combine structural and attribute information using the graph merging process CODICIL 步骤 创建内容边 create content edges 边组合 combining edges 边采样 sampling edges with bias 聚类 clustering creating content edges 对每个点vi, 用cosine相似度， 计算k 内容最近邻 在vi 和 k近邻间 建立content edges combining edges 将新创建的content edges 和 初始的拓扑边集进行简单的联合(unified) sampling edges with bias 对每个点 vi， 从邻点选择要保留的边， 通过 cosine 相似度或Jaccard 相似度 clustering 因为图合并部分独立于community detection， 所以任意 community detection 都可以， 这块不是本文的重点 主要贡献 通过 用内容信息消除连接结构里的噪音， 来强化社区信号 矩阵分解 Matrix Factorization 论文： Community Detection with Edge Content in Social Media Networks Edge-Induced Matrix Factorization 主要idea 通过从多层图中抽取相同因子(common factors) 把不同信息进行结合 使用通用的聚类方法处理 方法 使用 低秩矩阵因子分解(low-rank matrix factorization) 来逼近目标矩阵O， P: n x n 的特征矩阵 lambda(大写的？): n x n 特征值矩阵 目标 对于多个目标矩阵O&#94;i, i = 1,-,l 要算出一个common factor matrix 求最小化： P: n x n的所有层 公因子矩阵 Λ&#94;i: n x n 矩阵， 第i层的特征 || ·|| is the Frobenius norm α: regularization 参数 全局转局部最优 迭代处理： 固定P , 优化 Λ&#94;i 固定Λ&#94;i , 优化 P 直到 收敛 模式挖掘 Pattern Mining Coherent Closed Quasi-Clique Discovery from Large Dense Graph Databases Cocain 方法 子图挖掘算法， 搜索多层图中频率高于某给定阈值的 quasi-cliques 基础定义 gamma(γ)-Quasi-clique cross-graph quasi-clique: a set of vertices belonging to a quasi-clique appears on all layers must be the maximal set Edge Cut, Edge Connectivity edge cut is a set of edges Ec such that G'=(V ,E-Ec) is disconnected A minimum cut is the smallest set among all edge cuts. The edge connectivity of G, denoted by κ(G), is the size of the minimum cut coherent subgraph: a subgraph that satisfies a minimum cut bound gamma(γ)-Isomorphism 同构 若两个图G1, G2是 gamma同构， 当且仅当： 都是 γgamma-quasi-cliques 点个数相同 存在 biject f:V1->V2, 对V1中的每个点v, 满足F1(v) = F2(f(v)) multiset 点的标签的集合(a bag of vertex labels) 忽略顺序 突出多样性 定义为 M(G)， G的multiset string of a graph Given a k-graph g, any sequence of all elements in M(g) 给定 k-graph g, M(g)的任意一种序列 canonical form of a graph the minimum string among all its strings and denoted by CF(G) 图的最小 string, 记作 CF(G) 有引理： 两个γ-quasi-cliques Q1 Q2 是γ同构， 当且仅当 CF(Q1) = CF(Q2) 步骤 将子图转成 canonical forms 枚举γ-quasi-cliques可行解(feasible candidate for γ-quasi-cliques), 用DFS策略进行剪枝 基于 闭包检查规划(closure-checking scheme)， 选择出闭包的 γ-quasi-cliques 枚举策略 枚举树 满足： 子代必须能归入祖先 关键： 对每个 quasi-clique Q, 处理完它的子代后， 进行闭包检查 主要贡献 find cross-graph quasi-cliques in a multi-layer graph that are frequent, coherent, and closed 另一篇模式挖掘 论文 论文： Mining Coherent Subgraphs in Multi-Layer Graphs with Edge Labels 本文贡献 提出了带边标签的多层图聚类的新范式 提出了MLCS, 避免了结果集的冗余 提出了最好优先搜索算法MiMAG 来求MLCS聚类的近似解 multi-layer coherent subgraph (MLCS) model clusters of vertices that are densely connected by edges with similar labels in a subset of the graph layers 找聚类， 满足条件：在某层的图中，不仅边的密度高，且具有相似的标签。 the edge labels represent characteristics of the relations quasi-clique One-dimensional MLCS cluster One-dimensional MLCS cluster 某一图（层）的点集满足以下条件： 形成一个 0.5-quasi-clique 点集的每条边的两个顶点： dist(l_i(x), l_i(y)) <= w, edge label 为连续值时需要w, 不然置为0. 多层 MLCS cluster 冗余关系 redundancey relation MiMAG 算法 Mining Multi-layered, Attributed Graphs 计算出最大化、 无冗余、 高质量（不是最优质量）的聚类 基于寻找quasi-cliques的快速算法。 总结 Apriori 频繁项集的， 特例或通用 随机游走 概率模型 矩阵分解 clique community 没有严格定义 未来研究方向 通用多层图的适应性 General multi-layer graph applicability 当前算法一般仅研究了 pillar(柱形)多层图 现实世界不保证不同层之间正好一一对应 所以现有算法的泛化， 对通用多层图的适应性非常有意义 多层图的不确定性 Uncertainty in multi-layer graphs 现有的研究都假定 图数据已经清理完毕， 缺少噪音、歧义的研究 constructing multi-layer graphs with entity resolution and/or trustworthy analysis certainly enhances the quality of the community detection process 可扩展性问题 所以可能要考虑并行及分布式之类的方法 或是对多层图的特征向量矩阵（feature-vector matrices）进行采样 Temporal analysis 图是随时间变化的。 目前存在一些对单层图的时间变化的研究， 但基本不可用于多层图 谢谢！","tags":"研究","title":"多层网络聚落检测综述"},{"url":"http://sndnyang.github.io/GaoCD.html","text":"导论 算法思路 通过 划分密度(partition density) 这个目标函数的最优化来寻找 连接群落link communities 通过 novel genotype representation method, 将 连接群落映射回 点群落。 群落数自动发现 算法描述 框架 目标函数 partition density D only considers the link density within the community, different from the common community definition that a community should be densely intra-connected and sparsely connected with the rest communities.# 划分密度D $$ D(c) = \\frac{m_c - (n_c - 1)}{\\frac{n_c(n_c-1)}{2} - (n_c-1)} $$ partition density D is the average of Dc over all communities $$ D = \\frac{2}{M}\\sum_c m_c\\frac{m_c - (n_c - 1)}{(n_c-2)(n_c-1)} $$ 3.3 基因表达 编码 基于连接的表示方法， 群体中的个体g 有 m 个基因， 下标i 代表边的序号 m 是边数——吓死人了。 gj 从连接的点中选一个。 当无向图中两边共点时， 两边相连 解码 把基因型转化成 分割（由连接群落组成）， gi 作为基因型， 值 j 可看作是边 i 和 边 j 有一个共同点， 并应该归入同一群落中。 桥接边： 连接两个 聚落的边。 Fine tuning: 调整 单一映射方法得到的点群落 的点附属关系 寻找有多附属关系的点 membership 计算这种点 对各群落是否有贡献——如果加入的话。 贡献计算方法： $$ AD(c) = 2 * \\frac{|E(c)|}/{|c|} $$ 添加点后， EC 上升， 则OK if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"数据挖掘","title":"GaoCD-总结"},{"url":"http://sndnyang.github.io/ema_comminities_dynamic_networks.html","text":"摘要： 目标： 最大化当前数据的聚类准确性 最小化阶段过渡时的聚类漂移 clustering drift 新概念： temporal smoothness 短时平滑性 snapshot quality , temporal quality 快照质量和短时质量 优点： provides a solution representing the best trade-off between the accuracy of the clustering obtained, and the deviation from one time step to the successive. 为聚类的准确性及阶段过渡时的变动提出了一个最优折衷的方案 ** 问题是这几个东西都不是这篇文章提的概念， 只是函数可能有变化 导言 进化聚类方法(evolutionary clustering) 利用 temporal smoothness 框架。 核心假设： abrupt changes of clustering in a short time period are not desirable （译： 短时间内聚类突变是不值得要的？不合适的？） it smooths each community over time 平滑性的实现 折衷： snapshot quality: 在当前阶段所拥有数据下， 聚类要尽可能精确。 temporal cost: 每个聚类在阶段过渡时， 不能发生剧烈变化。 本文方法 名字： DYNMOGA (DYNamic MultiObjective Genetic Algorithms) 目标 最大化 snapshot quality, 表明当前聚类效果（准确性）， 为此调整了 modularity 的概念 最小化 temporal cost， 表明两阶段间聚类差别， 为此去计算 归一化互信息(normalized mutual information) 优势 利用这两个方法的优势 选择性搜索解空间， 不需要提前知道 聚类个数。 本文主要贡献 将动态网络中群落结构的检测问题 建模成 多目标优化问题--以前肯定有人弄过了，也算贡献？ 本方法可以考虑成 通用框架，应用于进化聚类。 仅仅需要修改目标函数，测试不同的质量函数--别人的算法也可以，这篇就是利用别人的框架。 本方法不需要参数， 不需要为快照和短时成本设置权重， 也不用设定聚类个数--不知道他人工作情况。 相关工作 主要工作 Evolutionary Clustering by Chakrabarti et al. in [13] 认为changes of connections in short time periods could be caused by noise. 提出了 temporal smoothness 和 snapshot cost temporal cost 问题是： not allow that the number of communities varies over time FacetNet by Lin et al[5] particle-and-density based clustering method by Kim and Han [3] 这些方法的主要问题 聚类个数 不知道。 相对于要选择 参数 alpha 去应用于 temporal smoothness。 DYNMOGA算法 DYNMOGA has been adapted with a customized population type that suitably represents a partitioning of a network and endowed with two complementary objectives 他们使用了 matlab 实现的 NSGA-II 算法框架, DYNMOGA支持 定制的、可表示网络分割情况的群体类型, 并具有两种互补的目标（然而并没有说是哪两种）。 目标函数 定义 \\($\\) CR&#94;t = { C&#94;t_1, ... C&#94;t_k } 是图在 t 阶段的聚类结果 一个聚类中有 n_S 个结点 m_S 条边。 m_S(u) = {v | v \\in C_t } 是结点u 在聚类C&#94;t 的邻点个数 c_S = { (u, v) | u \\in C&#94;t, v \\notin C&#94;t} 是聚类C&#94;t边界的边数。 l_S 是 只连接 模块 C&#94;t_S 内部结点 的边总数。 d_S 是 C&#94;t_S 中点的度数之和 \\($\\) 多种分值定义 Q: the first term of each summand is the fraction of edges inside a community, while the second one is the expected value of the fraction of edges that would be in the network if edges fall at random without regard to the community structure. Values approaching 1 indicate strong community structure modularity 颗粒度 ： $$ Q = \\sum&#94;k_{s=1}[\\frac{l_s}{m} - (\\frac{d_s}{2m})&#94;2] $$ conductance 导率, the fraction of edges pointing outside the clustering： $$ CO = \\sum&#94;k_{S=1}\\frac{c_S}{2m_S+c_S} $$ Normalized Cut 归一化分割 the fraction of total edge connections to all the nodes in the graph: $$ NC = \\sum&#94;k_{S=1}\\frac{c_S}{2m_S+c_S} + \\frac{c_S}{2(m-m_S)+c_S} $$ Community Score 群落分值, measure the fraction of internal edges of each cluster per nodes： $$ CS = \\sum&#94;k_{s=1}(\\sum_{u \\in C&#94;t}(\\frac{m_S(v)}{n_S})&#94;2) * \\frac{2m_S}{n_S} $$ 基因表达 locus-based adjacency representation [34] 每个个体包含 n 个基因， n 指代 结点的个数 每个基因 取值范围 1-n， 即第i个基因与第j个基因之间有连接，该划分到同一群落 ** 注： 这种表达肯定不能用于 群落重叠问题——然而 现实是， 主流用法 就是这样，大同小异 好处： 由个体组成部分的个数，在解码步骤中自动得到 decoding step 解码 使用并查集 建立并查集 makeset 对每条边去查找, findset 查到后的进行合并 初始化 一个有若干个体的群体， 对每个点i, 在邻接点中随机选择一个作为值， 表示 存在边 (i,j) uniform crossover 均匀交叉 给定两个父辈个体， 创建一个随机二元mask, 进行选择， 当 mask 为0时， 取第一个父辈个体的基因（值）， 为1时， 取第二个父辈个体。 如此组成子代的基因 突变 与初始化类似， 对结点i 随机变更值成其他邻点。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"数据挖掘","title":"进化多目标方法在动态网络聚落检测中的应用-总结"},{"url":"http://sndnyang.github.io/ea_based_communities_survey.html","text":"网络相关背景知识 定义 群落检测没有标准定义， 目前一般视为： 一组顶点，之间可能有着共同的属性或在图中起到相似的作用 分类 common model 共同？普通？模型 directed model 有向图模型 signed model 正负向模型 overlapping model 重叠模型 dynamic model 动态模型 进化算法与多目标优化 进化算法 相同性质： 省 框架： Algorithm 1 General framework of EAs 输入： 参数与问题实例 输出： 最优方案 Begin: population initialisation store optimal solutions for i = 1 to max_iteration do for each individual in the population do generate a new individual through stochastic components evaluate the fitness of the new individual endfor update optimal solutions endfor End 多目标优化 定义： 略 Pareto optimal solution: 待看书， 此处略 适应函数 单目标优化 4.1.1 基于颗粒度的模型 因为目标是多目标优化，先略， 如果有用再回来看 4.1.2 multi-resolution model 多分辨率？模型 同上 4.2 多目标优化 其他model 略 重叠模型 操作子 设计 个体表示 个体重现 个体局部搜索 结论 主要思想： 将群落检测建模成 单目标或多目标优化问题 设计元启发方法来解决 问题一： 根据 no free lunch 理论， 没有通用方法能解决全部类型的网络 不同网络的时-空特性不同 问题二： 由于数据集过大， 基于元启发方法的群落检测是LSGO问题（大规模全局优化）， 包含大量的决策变量，对现存优化技术是个挑战。 如何又快又好就值得思考 网络群落问题将超越纯粹结构分析，变成强调网络智能。","tags":"研究","title":"基于进化算法的群落检测问题综述总结"},{"url":"http://sndnyang.github.io/overlap_communities_survey.html","text":"算法 1. Clique Percolation 中文名？派系过滤 假设 群落由 完全连通子图的重叠集合组成——a community consists of overlapping sets of fully connected subgraphs 思路 detects communities by searching for adjacent cliques 扩展内容 派系(Cliques)。在一个无向网络图中，\"派系\"指的是至少包含3个点的最大完备子图。这个概念包含3层含义：①一个派系至少包含三个点。②派系是完备的，根据完备图的定义，派系中任何两点之间都存在直接联系。③派系是\"最大\"的，即向这个子图中增加任何一点，将改变其\"完备\"的性质。 n-派系(n-Cliques)。对于一个总图来说，如果其中的一个子图满足如下条件，就称之为n-派系：在该子图中，任何两点之间在总图中的距离(即捷径的长度)最大不超过n。从形式化角度说，令d(i,j)代表两点和n在总图中的距离，那么一个n-派系的形式化定义就是一个满足如下条件的拥有点集的子图，即：d(i,J)\\le n，对于所有的，n_i,n_j\\in N,来说，在总图中不存在与子图中的任何点的距离不超过n的点。 n-宗派(n—Clan)。所谓n-宗派(n—Clan)是指满足以下条件的n-派系，即其中任何两点之间的捷径的距离都不超过n。可见，所有的n-宗派都是n-派系。 k-丛(k-Plex)。一个k-丛就是满足下列条件的一个凝聚子群，即在这样一个子群中，每个点都至少与除了k个点之外的其他点直接相连。也就是说，当这个凝聚子群的规模为n时，其中每个点至少都与该凝聚子群中n-k个点有直接联系，即每个点的度数都至少为n—k。 某个的步骤之一 begins by identifying all cliques of size k in a network, a new graph is constructed such that each vertex represents one of these k-cliques 结论 more like pattern matching rather than finding communities since they aim to find specific, localized structure in a network. 2. Line Graph and Link Partitioning 中文名？连接划分 思路 partitioning links A node in the original graph is called overlapping if links connected to it are put in more than one cluster. 3. Local Expansion and Optimization 中文名？局部增广和优化 思路 based on growing a natural community or a partial community rely on a local benefit function that characterizes the quality of a densely connected group of nodes 4. Fuzzy Detection 中文名？模糊检测 思路 quantify the strength of association between all pairs of nodes and communities 例子 Non-negative Matrix Factorization 5. Agent-Based and Dynamical Algorithms 中文名？基于啥的动态算法 思路 label propagation algorithm by allowing a node to have multiple labels 6. others 中文名——无法分类 :) 评估方法 1. Normalized Mutual Information 中文名？标准互信息 2. Omega Index 结论","tags":"数据挖掘","title":"社区覆盖问题总结"},{"url":"http://sndnyang.github.io/findbugs_summary.html","text":"原文: Finding Bugs is Easy by David Hovemeyer, William Pugh 摘要 旧方法基于 formal methods 和 复杂程序分析， 难用， 无作用 bug patterns - detectors 简单的自动技术在遇到常规错误和难解特性时都有用 导论 conclusion 不存在这种bug, 过于明显，以至于在实际代码中没有找到例子——发现的bug中，有些十分明显， 让我们吃惊， 即使是在生产应用和库里 现代OO语言的高度复杂性， 对语言特性及API的滥用是屡见不鲜的。 自动bug检测可以在 程序正确性 上起到巨大作用","tags":"软件工程","title":"FindBugs总结"},{"url":"http://sndnyang.github.io/human_kernel_summary.html","text":"bayesian nonparametric models such as Gaussian processes function extrapolation problems kernel learning framework ** reverse the human-like and inductive biases of human across a set of behavioral experiments to gain psychological insights and to extrapolate in human model ability determined by its support(which solutions are a priori possible ) inductive biases (which solutions are a priori likely) controlled by a covariance kernel","tags":"研究","title":"human kernel 总结"},{"url":"http://sndnyang.github.io/FOCS_summary.html","text":"基本定义 图： G(V, E) 目标—— 找到一簇子图(全部并正确)， 每个子图都是一个团（community) 即 $ S = {S_i | S_i \\subset V } $ 团（community)： 子图中任意点在该子图中的连通性 高于 非团的子图 定义 包含点 $ v_j $ 的团的集合为： $$ S(v_j) = \\{S_i | v_j \\in S_i \\land S_i \\in S \\} $$ disjoint cluster: $$ |S(v_j)| \\le 1 $$ overlapped cluster: > 1 定义 \\( N(v_j) $ 为 $v_j\\) 的邻接点 定义 \\( N_i(v_j) $ 为 $v_j\\) 在团 \\(S_i\\) 的邻接点， 即 $$ N_i(v_j) =\\{v_k | (v_j, v_k) \\in E \\land v_k \\in S_i \\} $$ 新概念定义 团连通性 community connectedness, 即点 \\(v_j\\) 在团 \\(S_i\\) 邻点超阈值个数 除以 该团点数, 代表 点对应团的归属性。 $$ \\zeta&#94;i_j = \\frac{|N_i(v_j)|-K+1}{|S_i| - K} if |N_i(v_j)| > K, else, 0 $$ 邻接连通性 neighborhood connectedness， 即 点 \\(v_j\\) 在团 \\(S_i\\) 邻点数 除以 \\(v_j\\) 的总邻点数， 代表 点加入新团的可能性 $$ \\xi&#94;i_j = \\frac{|N_i(v_j)|}{|N(v_j)|} $$ 外围结点 peripheral node: \\(v_i\\) 的团邻接点 $$ Added_i = \\{v_k|v_k \\in N(v_i) \\land v_k \\in S_i \\}, \\forall S_i \\in S&#94;l $$ 步骤 初始化 初始化全部有K个以上邻接点的点， 由它及其邻接点组成团 \\(S_i\\) 定义该阶段的外围结点 脱离阶段 对前面所有团里的点 \\( V_j\\) , 计算相应的 团连通性 $ \\zeta&#94;i_j $ 邻接连通性 $ \\xi&#94;i_j $ 将[0, 1] 区间划分为 \\(max(20, N(v_j))\\) 块， 每块初始化为0. 根据团连通性分数， 统计各区间 点的个数。 标记 最右的非0元， 并开始向左遍历， 直到： 遍历完毕 或 遇到某区间，<=标记值(最右非零元)， 且<=左边区间值， 这个值选为 留存阈值 stay cut-of of \\zeta 外围结点 \\(v_k \\in Added_i $ 排除出 $S_i\\) , 当团连通性分数 $ \\zeta&#94;i_k $ 比留存阈值低。 Removal of only peripheral nodes ensures that nodes that form the core of a community are never eliminated 扩充阶段 对上一阶段处理后的团中所有点 \\(v_j\\) ， 当以下条件满足： 1. 该点未入 \\( S_i\\) 团 2. 该点选入 \\(S_i\\) 团的可能性高（即 邻接连通性 \\(\\xi&#94;i_j\\) 高于选中阈值 join cut-off ） join cut-off 选中阈值的计算方式与 stay 相同 去重阶段 代码描述 参考链接 focs-code /*! * * IPython notebook * */ /* CSS font colors for translated ANSI colors. */ .ansibold { font-weight: bold; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; border-left-width: 1px; padding-left: 5px; background: linear-gradient(to right, transparent -40px, transparent 1px, transparent 1px, transparent 100%); } div.cell.jupyter-soft-selected { border-left-color: #90CAF9; border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected { border-color: #ababab; border-left-width: 0px; padding-left: 6px; background: linear-gradient(to right, #42A5F5 -40px, #42A5F5 5px, transparent 5px, transparent 100%); } @media print { div.cell.selected { border-color: transparent; } } div.cell.selected.jupyter-soft-selected { border-left-width: 0; padding-left: 6px; background: linear-gradient(to right, #42A5F5 -40px, #42A5F5 7px, #E3F2FD 7px, #E3F2FD 100%); } .edit_mode div.cell.selected { border-color: #66BB6A; border-left-width: 0px; padding-left: 6px; background: linear-gradient(to right, #66BB6A -40px, #66BB6A 5px, transparent 5px, transparent 100%); } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don't highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } @-moz-document url-prefix() { div.inner_cell { overflow-x: hidden; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell > div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area > div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area > div.highlight > pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the <head> if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ padding: 0.4em; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. We need the 0 value because of how we size */ /* .CodeMirror-lines */ padding: 0; border: 0; border-radius: 0; } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev <Maniac@SoftwareManiacs.Org> Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are 'text' as well as 'stream', but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html td, .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell > div.prompt { display: none; } } div.text_cell_render { /*font-family: \"Helvetica Neue\", Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } .highlight .hll { background-color: #ffffcc } .highlight { background: #f8f8f8; } .highlight .c { color: #408080; font-style: italic } /* Comment */ .highlight .err { border: 1px solid #FF0000 } /* Error */ .highlight .k { color: #008000; font-weight: bold } /* Keyword */ .highlight .o { color: #666666 } /* Operator */ .highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */ .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */ .highlight .cp { color: #BC7A00 } /* Comment.Preproc */ .highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */ .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */ .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */ .highlight .gd { color: #A00000 } /* Generic.Deleted */ .highlight .ge { font-style: italic } /* Generic.Emph */ .highlight .gr { color: #FF0000 } /* Generic.Error */ .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight .gi { color: #00A000 } /* Generic.Inserted */ .highlight .go { color: #888888 } /* Generic.Output */ .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight .gs { font-weight: bold } /* Generic.Strong */ .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight .gt { color: #0044DD } /* Generic.Traceback */ .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight .kp { color: #008000 } /* Keyword.Pseudo */ .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight .kt { color: #B00040 } /* Keyword.Type */ .highlight .m { color: #666666 } /* Literal.Number */ .highlight .s { color: #BA2121 } /* Literal.String */ .highlight .na { color: #7D9029 } /* Name.Attribute */ .highlight .nb { color: #008000 } /* Name.Builtin */ .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight .no { color: #880000 } /* Name.Constant */ .highlight .nd { color: #AA22FF } /* Name.Decorator */ .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */ .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */ .highlight .nf { color: #0000FF } /* Name.Function */ .highlight .nl { color: #A0A000 } /* Name.Label */ .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight .nv { color: #19177C } /* Name.Variable */ .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight .w { color: #bbbbbb } /* Text.Whitespace */ .highlight .mb { color: #666666 } /* Literal.Number.Bin */ .highlight .mf { color: #666666 } /* Literal.Number.Float */ .highlight .mh { color: #666666 } /* Literal.Number.Hex */ .highlight .mi { color: #666666 } /* Literal.Number.Integer */ .highlight .mo { color: #666666 } /* Literal.Number.Oct */ .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight .sc { color: #BA2121 } /* Literal.String.Char */ .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */ .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */ .highlight .sx { color: #008000 } /* Literal.String.Other */ .highlight .sr { color: #BB6688 } /* Literal.String.Regex */ .highlight .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight .ss { color: #19177C } /* Literal.String.Symbol */ .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight .vc { color: #19177C } /* Name.Variable.Class */ .highlight .vg { color: #19177C } /* Name.Variable.Global */ .highlight .vi { color: #19177C } /* Name.Variable.Instance */ .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */ /* Temporary definitions which will become obsolete with Notebook release 5.0 */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-bold { font-weight: bold; } In [2]: % matplotlib inline import time import matplotlib.pyplot as plt import numpy as np import networkx as nx In [3]: def random_init_graph (): import random from itertools import combinations edges = [] for ( u , v ) in combinations ( range ( 10 ), 2 ): r = random . random () if r < 0.5 : edges . append (( u , v )) for ( u , v ) in combinations ( range ( 8 ), 2 ): r = random . random () if r < 0.5 : edges . append (( u + 10 , v + 10 )) for ( u , v ) in combinations ( range ( 9 ), 2 ): r = random . random () if r < 0.6 : edges . append (( u + 18 , v + 18 )) for ( u , v ) in combinations ( range ( 5 ), 2 ): r = random . random () if r < 0.4 : edges . append (( u + 27 , v + 27 )) for ( u , v ) in combinations ( range ( 6 ), 2 ): r = random . random () if r < 0.1 : edges . append (( u , v + 10 )) for ( u , v ) in combinations ( range ( 7 ), 2 ): r = random . random () if r < 0.3 : edges . append (( u , v + 18 )) for ( u , v ) in combinations ( range ( 6 ), 2 ): r = random . random () if r < 0.2 : edges . append (( u , v + 27 )) print len ( edges ) test = nx . Graph () test . add_edges_from ( edges ) fp = file ( 'dataset' + str ( len ( test )) + '.txt' , 'w' ) for ( u , v ) in edges : fp . write ( ' %d %d \\n ' % ( u , v )) fp . close () nx . draw ( test , with_label = True ) pos = nx . spring_layout ( test ) nx . draw_networkx ( test , pos = pos ) In [ ]: In [4]: added = {} In [5]: def initializeCommunities ( g , k , S ): node_num = 0 degree = 0 for v in g . nodes (): neighbors = g . neighbors ( v ) n_len = len ( neighbors ) node_num += 1 degree += n_len if n_len >= k : S [ v ] = set ( neighbors ) S [ v ] . add ( v ) #added[v] = set(neighbors) #print 'init finish' print \"average degree is\" , float ( degree ) / node_num bucks = max ( 20 , float ( degree ) / node_num ) In [6]: def duplicationRemovel ( S , ovl ): delete_list = [] nodes = sorted ( S . keys ()) count = 0 for u in nodes : if u not in S : continue for v in sorted ( S [ u ]): if u == v : continue if v in S : join = S [ u ] . intersection ( S [ v ]) join_len = len ( join ) if u == 11878 : print u , v , join , join_len if join_len + 0.001 >= ovl * len ( S [ u ]) and join_len + 0.001 >= ovl * len ( S [ v ]): count += 1 s = v if len ( S [ u ]) > len ( S [ v ]) else u m = u if s == v else v #print 'when %d , Communtiy %d removed for duplication. Duplicate with %d' % (u, s, m) S . pop ( s ) if s == u : break return S In [19]: def xi ( v , S , g ): neighbors = set ( g . neighbors ( v )) return 1.0 * len ( neighbors . intersection ( S )) / len ( neighbors ) def psi ( C , Cdot ): return 1.0 * len ( C . intersection ( Cdot )) / min ( len ( C ), len ( Cdot )) def findStayOff ( temp ): anchor = 0 mark = 0 for e in range ( len ( temp ) - 1 , 0 , - 1 ): if not mark and temp [ e ]: mark = e break #print temp, mark, for e in range ( mark - 1 , 0 , - 1 ): if temp [ e ] < temp [ mark ]: mark = e if temp [ e - 1 ] >= temp [ e ] and temp [ e ] == temp [ mark ]: # print mark, e anchor = e + 1 break #print anchor return anchor In [8]: temp = [ 6 , 1 , 2 , 2 , 2 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 2 , 0 , 0 ] print findStayOff ( temp ) 9 In [9]: print G . neighbors ( 23757 ) x = set ( G . neighbors ( 23757 )) for i in G . neighbors ( 23757 ): if i not in S : continue print i , S [ i ] . intersection ( x ) v = 23757 print zeta_scores [ 23757 ] anchor = selectBucket ( zeta_scores [ v ] . values (), bucks ) x = [ 0.23809523809523808 , 0.13333333333333333 , 0.18181818181818182 , 0 , 0.9 , 0.13333333333333333 , 0.25 , 0 , 0.6666666666666666 , 0.5 , 0.46153846153846156 , 0 , 0.18181818181818182 , 0.05 , 0.2222222222222222 , 0 , 0 , 0.9411764705882353 , 0 ] print selectBucket ( x , bucks ) --------------------------------------------------------------------------- NameError Traceback (most recent call last) <ipython-input-9-af98e7840219> in <module> () ----> 1 print G . neighbors ( 23757 ) 2 x = set ( G . neighbors ( 23757 ) ) 3 for i in G . neighbors ( 23757 ) : 4 if i not in S : 5 continue NameError : name 'G' is not defined In [10]: def zeta ( v , S , g , k ): neighbors = set ( g . neighbors ( v )) . intersection ( S ) return 1.0 * ( len ( neighbors ) - k + 1 ) / ( len ( S ) - k ) if len ( neighbors ) > k else 0 def computeScoreList ( S , g , k ): zeta_scores = {} count = 0 join_scores = {} for i in S : for vj in S [ i ]: zeta_scores [ vj ] = {} join_scores [ vj ] = {} for i in S : Si = S [ i ] Si_len = len ( Si ) count += Si_len for vj in Si : if vj == i : continue neighbors = g . neighbors ( vj ) n_len = len ( neighbors ) sin = Si . intersection ( neighbors ) sin_len = len ( sin ) if sin_len < k : zeta_scores [ vj ][ i ] = 0 join_scores [ vj ][ i ] = 0 else : zetascore = float ( sin_len - k ) / ( Si_len - k ) joinscore = sin_len / n_len zeta_scores [ vj ][ i ] = zetascore zeta_scores [ vj ] #k = zetascore join_scores [ vj ][ i ] = joinscore #print 'zeta compute count', count # for vj in zeta_scores: # print vj, zeta_scores[vj], g.neighbors(vj) return zeta_scores , join_scores In [11]: def leaveCommunities ( S , g , k , ovl , zeta_scores , zetacut ): delete_list = [] leave = True for s in sorted ( S . keys ()): count = len ( S [ s ]) for n in sorted ( S [ s ]): if n == s : continue if n not in zetacut or zeta_scores [ n ][ s ] < ( zetacut [ n ] - 0.001 ) / bucks or zeta_scores [ n ][ s ] <= 0.001 : S [ s ] . remove ( n ) count -= 1 if count <= k : S . pop ( s ) leave = False break return leave In [12]: def selectBucket ( scores_list , count ): comm_count = 0 bucket_list = [ 0 ] * count for e in scores_list : if e < 0.001 : continue comm_count += 1 bucket = int (( e - 0.001 ) * count ) #print bucket, 'count ' , count, 'e ', e bucket_list [ bucket ] += 1 if comm_count > 1 : anchor = findStayOff ( bucket_list ) else : anchor = 0 #fp.write(\" %s comm_count %d bucket is %d\\n\" % (str(bucket_list), comm_count, anchor)) #print \" %s comm_count %d bucket is %d\\n\" % (str(bucket_list), comm_count, anchor) #print bucket_list, return anchor In [13]: def expandCommunities ( S , g , join_scores ): for v in join_scores : count = bucks anchor = selectBucket ( join_scores [ v ] . values (), count ) join_scores [ v ][ 'cutoff' ] = ( anchor - 1 ) * 1.0 / count #for e in join_scores: # print e, join_scores[e] #for e in added: # print e, added[e] status = True #nowadded = {} for i in S : #nowadded[i] = set() for vj in list ( S [ i ]): for uk in g . neighbors ( vj ): if uk not in join_scores or i not in join_scores [ uk ]: #print 'not in' , uk, i, uk not in join_scores, i not in join_scores[uk] continue if join_scores [ uk ][ i ] > join_scores [ uk ][ 'cutoff' ] and uk not in S [ i ]: S [ i ] . add ( uk ) status = False return status In [14]: def summary_cluster ( S ): count = 0 for i in S : count += len ( S [ i ]) return len ( S ), count In [15]: def preferredCommunities ( g , k , ovl ): S = {} initializeCommunities ( g , k , S ) print \"init stage, cluster %d ge, total node %d \" % summary_cluster ( S ), time . time () - prev expand = 10 while expand : if expand <= 0 : break expand -= 1 t = 10 while t : t -= 1 S = duplicationRemovel ( S , ovl ) print 'After duplicate removal, cluster %d ge, total node %d ' % summary_cluster ( S ), time . time () - prev zeta_scores , join_scores = computeScoreList ( S , g , k ) zeta_cutoff = {} for v in zeta_scores : anchor = selectBucket ( zeta_scores [ v ] . values (), bucks ) zeta_cutoff [ v ] = anchor leave = leaveCommunities ( S , g , k , ovl , zeta_scores , zeta_cutoff ) print 'After leave function, cluster %d ge, total node %d ' % summary_cluster ( S ), time . time () - prev if leave : break status = expandCommunities ( S , g , join_scores ) print 'After expand function, cluster %d ge, total node %d ' % summary_cluster ( S ), time . time () - prev if status : break print 'finish, cluster %d ge, total node %d ' % summary_cluster ( S ) return S In [16]: #data = np.loadtxt('G:/project/dataset/dblp/com-dblp.ungraph.txt', dtype=np.int32, delimiter='\\t') data = np . loadtxt ( 'G:/software/open_source/focs-master/tmp.txt' , dtype = np . int32 , delimiter = ' \\t ' , usecols = ( 0 , 1 )) G = nx . Graph () G . add_edges_from ( data ) g = nx . adjacency_matrix ( G ) In [ ]: print G . number_of_nodes () In [17]: S = {} bucks = 20 k = 2 OVL = 0.6 initializeCommunities ( G , k , S ) #print summary_cluster(S) #duplicationRemovel(S, OVL) #print summary_cluster(S) average degree is 6.83028835571 In [11]: print len ( S [ 40935 ]) print len ( S [ 175011 ]) print S [ 40935 ] . intersection ( S [ 175011 ]) 341 34 set([175011, 40935, 106127, 28051, 36087, 96057]) In [138]: zeta_scores , join_scores = computeScoreList ( S , G , k ) zeta_cutoff = {} fp = file ( 'G:/software/open_source/focs-master/cutoff_pyt.txt' , 'w' ) for v in sorted ( G . nodes ()): count = bucks fp . write ( \"phase 1 iter 0 cutoff %d \" % v ) if v in zeta_scores : anchor = selectBucket ( zeta_scores [ v ] . values (), bucks ) else : anchor = selectBucket ([], bucks ) zeta_cutoff [ v ] = anchor #print v, zeta_scores[v]['cutoff'] fp . close () In [140]: #print len(S.keys()) #for i in sorted(S.keys()): leaveCommunities ( S , G , k , OVL , zeta_scores , zeta_cutoff ) print summary_cluster ( S ) #fp = file('G:/software/open_source/focs-master/cutoff_pyt.txt', 'w') #for v in sorted(zeta_scores): # count = bucks # fp.write(\"phase 1 cutoff %d \" % v) # anchor = selectBucket(zeta_scores[v].values(), bucks) #print v, anchor #print v, zeta_scores[v]['cutoff'] #fp.close() (703, 4291) In [20]: S = {} bucks = 20 prev = time . time () start = prev z = preferredCommunities ( G , 2 , 0.6 ) print 'total time' , time . time () - start average degree is 6.83028835571 init stage, cluster 5995 ge, total node 64964 0.0380001068115 11878 56537 set([56537, 11878]) 2 11878 83823 set([11878, 83823]) 2 After duplicate removal, cluster 5738 ge, total node 62242 0.186000108719 After leave function, cluster 703 ge, total node 4291 0.699000120163 After duplicate removal, cluster 596 ge, total node 3852 0.705000162125 After leave function, cluster 181 ge, total node 972 0.745000123978 After duplicate removal, cluster 181 ge, total node 972 0.746000051498 After leave function, cluster 122 ge, total node 700 0.756000041962 After duplicate removal, cluster 122 ge, total node 700 0.757000207901 After leave function, cluster 117 ge, total node 678 0.764000177383 After duplicate removal, cluster 117 ge, total node 678 0.765000104904 After leave function, cluster 116 ge, total node 675 0.774000167847 After duplicate removal, cluster 116 ge, total node 675 0.774000167847 After leave function, cluster 116 ge, total node 675 0.781000137329 After expand function, cluster 116 ge, total node 675 0.789000034332 finish, cluster 116 ge, total node 675 total time 0.790000200272 In [ ]: z = preferredCommunities ( test , 2 , 0.6 ) In [ ]: colors = [ 'r' ] * len ( test . nodes ()) cmap = { 0 : 'b' , 10 : 'yellow' , 27 : 'g' } for e in z : for n in z [ e ]: colors [ n ] = cmap [ e ] print colors In [ ]: nx . draw_networkx ( test , node_size = 150 , node_color = colors ) In [ ]: pcdqdata = np . loadtxt ( 'G:/software/open_source/focs-master/tmp.txt' , dtype = np . int32 , delimiter = ' \\t ' , usecols = ( 0 , 1 )) pcdqG = nx . Graph () pcdqG . add_edges_from ( pcdqdata ) g = nx . adjacency_matrix ( pcdqG ) In [ ]: pcdqS = {} added = {} prev = time . time () z = preferredCommunities ( pcdqG , 2 , 0.6 ) print time . time () - prev In [ ]: pcdqS = {} added = {} prev = time . time () initializeCommunities ( pcdqG , 2 , pcdqS ) duplicationRemovel ( pcdqS , 0.6 ) #z = preferredCommunities(pcdqG, 2, 0.6) print time . time () - prev In [ ]: log = file ( 'log1.txt' , 'w' ) for u in sorted ( pcdqS . keys ())[: 10 ]: for v in sorted ( pcdqS [ u ]): if u == v : continue print u , v , zeta_scores [ v ][ 'cutoff' ], zeta_scores [ v ][ u ] #log.write(\"node %d nei node %d, cut-off %.3f, real score %.3f\\n\" % (u, v, zeta_scores[v]['cutoff'], zeta_scores[v][u])) log . close () In [ ]: print pcdqS [ 275 ] print zeta_scores [ 275 ][ 'cutoff' ] print zeta_scores [ 31054 ] x = zeta_scores [ 275 ] . values () ratio = 0.05 bucket_list = [ 0 ] * 21 for e in x : bucket = int ( e / ratio ) #print bucket, 'count ' , count, 'e ', e bucket_list [ bucket ] += 1 print bucket_list anchor = selectBucket ( x , 20 ) print anchor print ratio * ( anchor - 1 ) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: 'center',\" + \" displayIndent: '0em',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['$','$'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'black ! important'} }\" + \" } \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); } if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"数据挖掘","title":"FOCS总结"},{"url":"http://sndnyang.github.io/d3js_learn_1.html","text":"流程 一、添加 svg 画布， 得到一个 选择器selection var svg = d3.select(\"body\") //选择文档中的某一元素，根据CSS规范，如 \"body\" .append(\"svg\") //添加一个svg元素, 符合html操作 .attr(\"width\", width) //设定宽度 .attr(\"height\", height); //设定高度 二、布局（转换数据） 2.1 种类 布局种类 2.2 定义布局 var mylayout = d3.layout.tree() // 例： Tree布局 2.3 设置布局的基本属性（接上一项） .size ([ width , height ]) // tree 只想到这个属性 2.4 用布局转换数据 var nodes = mylayout.nodes(data)[.reverse()] // reverse 逆序， data格式有讲究， json且属性名字限定 var links = mylayout.links(nodes) // 树图要生成点和边 或者 var piedata = pie(dataset); // 饼状图就不需要边了 三、数据绑定到元素（默认新建元素） 3.1 从画布选择器中，再选择后代元素 svg.select(name) // 选择第一个匹配的元素 或者 svg.selectAll(name) // 选择全部匹配的元素 3.2 加载数据（接上一项） .data ( dataset ) // 元素和数据集一对一加载 , 此时得到的叫 update 部分 或者 .datum ( oneData ) // 一个数据绑定给全部元素 3.3 对应数据来创建元素（接上一项），如果元素是现成的不需要建 .enter () // 只能接上一项 数据加载 , 此时得到的叫 enter 部分 .append ( type ) // 创建需要类型的元素 3.4 数据属性设置（例） 根据上一项的 type 和 数据， 设置需要的属性 .attr ( \"x\" , 20 ) //屏幕上的起始横坐标 .attr ( \"y\" , function ( d , i ) { //屏幕上的起始纵坐标 return i * rectHeight ; }) .attr ( \"width\" , function ( d ) { // 元素宽度（有这个属性的话） return d ; }) .attr ( \"height\" , rectHeight-2 ) // 元素高度（有这个属性的话） .attr ( \"fill\" , \"steelblue\" ) ; // 颜色填充 3.5 事件设置（也是属性） .on ( \"mouseover\" , function ( d , i ) {} ) .on ( \"mouseout\" , function ( d , i ) {} ) .on ( \"click\" , function ( d , i ) {} ) 在该元素下继续添加其他子元素 前面3.1-3.5步骤结果保存在某变量中， 即可使用该变量继续append,设置属性和事件 四、动画效果 4.1 方法 transition() // 启动过渡效果, 其前后是图形变化前后的状态（形状、位置、颜色等等） duration() // 指定过渡的持续时间，单位为毫秒 ease() 指定过渡的方式，常用的有： linear：普通的线性变化 circle：慢慢地到达变换的最终状态 elastic：带有弹跳的到达最终状态 bounce：在最终状态处弹跳几次 delay() 指定延迟的时间，可用匿名函数function(d,i) 指定各个的延迟 4.2 创建动态效果 var transition = selection.transition() .duration(time) .attr()... // 定义变量是可能用于4.3 4.3 对子元素进行处理 如果元素中有子元素，需要一并处理。 transition.select(name).attr()","tags":"工具","title":"D3.js 学习心得一"},{"url":"http://sndnyang.github.io/memory-movies-week1.html","text":"记忆概念 分类 working memory episodic memory semantic memory procedural memory working memory workbench(工作台) -- 维持、操作思维和意识 特点：短暂","tags":"心理学","title":"记忆与电影-第一周"},{"url":"http://sndnyang.github.io/automata-hw1.html","text":"编程容易，笔算不易，且写且珍惜 开篇语 第二周的编程练习非常简单——前两轮开课时不知道是不是会难很多， 总之这次把代码框架都搭好了， 顺利的话， 10分钟就OK了。 不顺利的地方在哪儿——我使用的是python版本， 里面有个小bug，我看不懂输出。 在源文件里找了半天代码结构没明白， 最后打算从main开始吧， 一看， 代码里面是这样写的 def main(filepath): return Start('testRE.in') if __name__ == '__main__': main(sys.argv[1]) 好吧，难怪我的文件名参数没用——剩下的在看懂他输出是什么内容后很快就解决了。 无耻的分界线 你以为我就想说这个？ NO！ 最起码笔算不易还没说呢！！！ 本周第一个视频讲的是正则表达式基础，从定义到正则表达式转换成NFA CUT！！！ 概念没兴趣， RE转NFA 学过的内容，看到那张图就OK了， 主要是确实so easy. CONTINUE！！！ 然后就到DFA转RE了， 说实话吧， 过程不是很复杂，对于我这种人来说，就一个公式（虽然后面不停地修正自己对过程理解上的缺陷）， 套公式，谁不会呢？！ 转折 我还真不会了， 小测第一题就是DFA转RE, 4个状态之间的转换， 套用公式简单 $$ R&#94;k_{ij} =R&#94;{k-1}{ij} + R&#94;{k-1}(R&#94;{k-1}{kk})* R&#94;{k-1} $$ 问题有几个： 1. 状态的序号， 给状态按什么顺序分配序号最好呢，在这里可能没影响，不过我换了好几次。 2. 手算真是很绕， 整个下午，多半时间都花在推导上了，连午觉都想想后起来先推导了几次，实在绕晕了才午休。 在纸上推导被绕的过程中， 顺手写代码，模拟一下这个公式， 就是个递归的公式，用nnn 的数组来记录状态嘛。 初始版的数组下标就不对，不经过额外状态的路径（直接连结或无连结）被我忽略了， 另外也没有组织好正则表达式的表达形式，括号没用好。 输出的结果自然是无效的。 最后第二周的第一个小测是我经过7次连蒙带猜后，总算拿到5分。 第一题纸算太难，第二题花费很长时间来理解题意，后3题时不时拖后腿，几次前两题答对（后几次已经不是猜了），后三题不小心出错。 万万没想到（其实不至于） 到晚上， 做其他事耐心缺失之下， 又打开了代码， 决定调整好数组下标， 再组织好括号的输出。很快修改完毕， 随意运行之后，输出结果居然就这么达到预期 因 honor code， 只摘取与题目要求无关的输出部分 k i j regular expression 4 1 1 1(11+0(01+10))*(1+00) 4 1 2 1(11+0(01+10))*01 4 1 3 1(11+0(01+10))*0 4 1 4 1+1(11+0(01+10))*(11+0(01+10)) 4 2 1 0(11+0(01+10))*(1+00) 4 2 2 0(11+0(01+10))*01 4 2 3 0(11+0(01+10))*0 4 2 4 0+0(11+0(01+10))*(11+0(01+10)) 4 3 1 0+(01+10)(11+0(01+10))*(1+00) 4 3 2 1+(01+10)(11+0(01+10))*01 4 3 3 (01+10)(11+0(01+10))*0 虽然没有经过完全化简——也不确认全部正确，但形式上是没问题了。 测验第一题对应的结果也是正确的。 根据输出的结果， 回顾题目， 我去， 选项怎么这么明显啊， 我之前的推导都在为了什么？ 结论 个人经验， 手工推导DFA到RE 非常容易错乱，而老师题目中的几个选项稍认真分析下，可以直接判断正误， 我之前是有多不认真呢。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"CS","title":"自动机作业1-正则表达式"},{"url":"http://sndnyang.github.io/algo_connectivity.html","text":"问题定义： 给定 N个物体（点） 存在两种操作： 连接： 连接两点 查询连通性： 两点间是否存在路径 问题建模： 对象建模： 简单就是个点， 然后用个数组下标0 —— N-1来表示 连通性建模： '连接到' 等价于以下数学表示： 反射： 自身是连通的。 对称： 如果p连接到q，则q也连接到p 传递： 如果p连接到q，q又连通r， 则p 也连通r. 连通分量(connected component) 相互连通的物体的最大集合 操作的实现: Find查询: 查询两点是否在同一分量 Union连接：","tags":"算法","title":"连通性问题"},{"url":"http://sndnyang.github.io/vi-vim-tips.html","text":"vi 小技巧 部分 vi +xx 文件名，可以直接跳到位置的， 和vim一样。xx代表行数 查找时， \\<xxx> 代表全词匹配——vim也一样，而且更先进的是，当光标在该单词上时，vim快捷键shift+8就是向下查找，shift+3就是向上查找。 vim 技巧 模式 ctrl-v 或 ctrl-q 进入可视块状态， 即 列编辑模式。 页面跳转 gg 文件首行 G 文件末尾 H M L 光标跳转页顶，页中，页底 zt zz zb 光标所在行置顶、置中、置底 排版缩进 按v进入visual状态，选择多行，用>或<缩进或缩出 等效于 x >>/<< x行缩进 通常根据语言特征使用自动缩进排版：在命令状态下对当前行用== （连按=两次）, 或对多行用n==（n是自然数）表示自动缩进从当前行起的下面n行。你可以试试把代码缩进任意打乱再用n==排版，相当于一般IDE里的code format。使用gg=G可对整篇代码进行排版 至于如何针对自定义语言制订缩进规则，还有点问题，成功率不高。 代码跳转 % 跳转到配对的括号去 [[ 跳转到代码块的开头去(但要求代码块中'{'必须单独占一行) gD 跳转到局部变量的定义处 '' 跳转到光标上次停靠的地方, 是两个'单引号, 而不是一个\" 双引号 书签 mx 设置书签,x只能是a-z的26个字母 `x 跳转到书签处(\"\"是1左边的键)","tags":"工具","title":"vi-vim小技巧"}]}