<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>懒龙微薄</title><link href="/" rel="alternate"></link><link href="/feeds/shell.atom.xml" rel="self"></link><id>/</id><updated>2014-08-13T11:51:02+08:00</updated><entry><title>ksh手册</title><link href="/ksh_manual.html" rel="alternate"></link><updated>2014-08-13T11:51:02+08:00</updated><author><name>杨秀隆</name></author><id>tag:,2014-08-13:ksh_manual.html</id><summary type="html">
&lt;h1 id="1"&gt;1.语法&lt;/h1&gt;
&lt;h2 id="_1"&gt;特殊的文件&lt;/h2&gt;
&lt;p&gt;/etc/profile  在登录时首先自动执行。 &lt;br/&gt;
$HOME/.profile  在登录时第二个自动执行。 &lt;br/&gt;
$ENV  在创建一个新的KShell时指定要读的一个文件。   &lt;/p&gt;
&lt;h2 id="_2"&gt;文件名元字符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;匹配有零或零个以上字符的字符串   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;?  匹配任何单个字符   &lt;/li&gt;
&lt;li&gt;[abc…]  匹配括号内任何一个字符，也可用连字符指定一个范围（例如，a-z,A-Z,0-9）   &lt;/li&gt;
&lt;li&gt;[!abc…]  匹配任何不包括在括号内的字符   &lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;?(pattern)  匹配模式的零个或一个实例   &lt;/li&gt;
&lt;li&gt;*(pattern)  匹配指定模式的零个或多个实例   &lt;/li&gt;
&lt;li&gt;＋(pattern)  匹配指定模式的一个或多个实例   &lt;/li&gt;
&lt;li&gt;＠(pattern)  只匹配指定模式的一个实例   &lt;/li&gt;
&lt;li&gt;！(pattern)  匹配任何不匹配模式的字符串   &lt;/li&gt;
&lt;li&gt;\n  匹配与(…)中的第n个子模式匹配的文本。   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个模式pattern可能是由分隔符“|”或“＆”分隔的模式的序列， &lt;br/&gt;
例：pr !(*.o|core) | lp   &lt;/p&gt;
&lt;h2 id="_3"&gt;引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;;  命令分隔符   &lt;/li&gt;
&lt;li&gt;＆  后台执行   &lt;/li&gt;
&lt;li&gt;( )  命令分组   &lt;/li&gt;
&lt;li&gt;|  管道   &lt;/li&gt;
&lt;li&gt;&amp;lt; &amp;gt; &amp;amp;  重定向符号   &lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;? [ ] ~ + - @ !  文件名元字符   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;““  中间的字符会逐字引用，除了`` 替换命令和$ 替换变量.   &lt;/li&gt;
&lt;li&gt;‘’  中间的所有字符都会逐字引用   &lt;/li&gt;
&lt;li&gt;\  在其后的字符会按其原来的意义逐字采用.如在””中使用 \”,`,\$   &lt;/li&gt;
&lt;li&gt;\a 警告，\b退格,\f 换页,\n 换行,\r 回车,\ 制表符,\v 垂直制表符,   &lt;/li&gt;
&lt;li&gt;\nnn 八进制值,\xnn 十六进制值,\’ 单引号,\” 双引号,\ 反斜线,   &lt;/li&gt;
&lt;li&gt;``  命令的替换   &lt;/li&gt;
&lt;li&gt;$  变量的替换   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;命令形式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cmd &amp;amp;  在后台执行   &lt;/li&gt;
&lt;li&gt;Cmd1;cmd2  命令序列，依次执行   &lt;/li&gt;
&lt;li&gt;{cmd1;cmd2;}  将命令做为一组来执行   &lt;/li&gt;
&lt;li&gt;(cmd1;cmd2)  在子shell中，将命令做为一组执行   &lt;/li&gt;
&lt;li&gt;Cmd1|cmd2  管道;将cmd1的输出作为cmd2的输入   &lt;/li&gt;
&lt;li&gt;Cmd1 &lt;code&gt;cmd2&lt;/code&gt;  命令替换;用cmd2的输出作为cmd1的参数   &lt;/li&gt;
&lt;li&gt;Cmd1$(cmd2)  命令替换，可以嵌套   &lt;/li&gt;
&lt;li&gt;Cmd$((expression))  运算替换。用表达式结果作为参数   &lt;/li&gt;
&lt;li&gt;Cmd1&amp;amp;&amp;amp;cmd2  逻辑与。如果cmd1成功才执行cmd2   &lt;/li&gt;
&lt;li&gt;Cmd1||cmd2  逻辑或。如果cmd1成功则不会执行cmd2   &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt;重定向形式&lt;/h2&gt;
&lt;h3 id="_6"&gt;文件描述符：&lt;/h3&gt;
&lt;p&gt;0         标准输入  stdin  默认为键盘 &lt;br/&gt;
1         标准输出  stdout &lt;br/&gt;
2         标准错误  stderr   &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Cmd &amp;gt; file  将cmd的结果输出到file(覆盖) &lt;br/&gt;
Cmd &amp;gt;&amp;gt; file  将cmd的结果输出到file(追加) &lt;br/&gt;
Cmd &amp;lt; file  从file中获取cmd 的输入 &lt;br/&gt;
Cmd &amp;lt;&amp;lt; text  将shell脚本的内容（直到遇见一个和text一样的标记为止）作为cmd的输入 &lt;br/&gt;
Cmd &amp;lt;&amp;gt; file  在标准输入上打开文件以便读写   &lt;/p&gt;
&lt;p&gt;Cmd &amp;gt;&amp;amp;n  将输出发送到文件描述符n。ll &amp;gt;&amp;amp;1 &lt;br/&gt;
Cmd m&amp;gt;&amp;amp;n　将本来输出的m中的内容转发到n中。Ll 3&amp;gt;&amp;amp;2 &lt;br/&gt;
Cmd &amp;gt;&amp;amp;-  关闭标准输出 &lt;br/&gt;
Cmd &amp;lt;&amp;amp;n　获取输入 &lt;br/&gt;
Cmd m&amp;lt;&amp;amp;n &lt;br/&gt;
Cmd &amp;lt;&amp;amp;-　关闭标准输入 &lt;br/&gt;
在文件描述符和一个重定向符号间不允许有空格。   &lt;/p&gt;
&lt;p&gt;Cmd 2&amp;gt;file  将标准错误发到file中 &lt;br/&gt;
Cmd &amp;gt; file 2&amp;gt;&amp;amp;1  将标准错误和标准输出都发到file &lt;br/&gt;
Cmd &amp;gt; f1 2&amp;gt;f2  将标准输出发到f1,标准错误发到f2 &lt;br/&gt;
Cmd | tee files  将输出发送到标准输出和files中 &lt;br/&gt;
Cmd 2&amp;gt;&amp;amp;1 | tee files  将输出和错误同时发到标准输出和files中   &lt;/p&gt;
&lt;h1 id="2"&gt;2. 变量&lt;/h1&gt;
&lt;h2 id="_7"&gt;变量替换&lt;/h2&gt;
&lt;p&gt;下列表达式中不允许使用空格。冒号是可选的，如果用冒号那么变量必须是非空的并设置了初始值。   &lt;/p&gt;
&lt;p&gt;Var=value…  将变量var 设为value &lt;br/&gt;
${var}  使用变量var的值;如果变量和其后面的文本是分开的则可以不加大括号。 &lt;br/&gt;
${var:-value}  如果变量var已设置则使用它，否则使用值value &lt;br/&gt;
${var:=value}  如果变量var已设置则使用它，否则使用值value并将value赋给变量var &lt;br/&gt;
${var:+value}  如果变量var已设置则使用value，否则什么也不使用   &lt;/p&gt;
&lt;p&gt;例:echo ${u-$d};echo ${tmp-&lt;code&gt;date&lt;/code&gt;}如果没设tmp,则执行date;   &lt;/p&gt;
&lt;h2 id="_8"&gt;内置变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$#  命令行参数的个数   &lt;/li&gt;
&lt;li&gt;$?　上一条命令执行后返回的值   &lt;/li&gt;
&lt;li&gt;$$　当前进程的进程号(PID), 通常用于在shell脚本中创建临时文件的名称   &lt;/li&gt;
&lt;li&gt;$0　第一个参数即命令名   &lt;/li&gt;
&lt;li&gt;$n　命令行上的第n个参数   &lt;/li&gt;
&lt;li&gt;$ * 将命令行上所有参数作为一个字符串   &lt;/li&gt;
&lt;li&gt;$@　命令行上所有参数，但每个参数都被引号引起来   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;h2 id="_9"&gt;特殊内置变量&lt;/h2&gt;
&lt;p&gt;LINENO  脚本或函数内正在执行的命令的行号 &lt;br/&gt;
OLDPWD　前一个工作目录（由CD设置） &lt;br/&gt;
PPID　　当前SHELL的父进程的进程号 &lt;br/&gt;
PWD　　　当前工作目录（由CD设置） &lt;br/&gt;
RANDOM[=n]　每次引用时产生一个随机数，如果给定n则以整数n开始 &lt;br/&gt;
SECONDS 这个整型变量的值是指从这个shell会话启动算起所过去的秒数。但它更有用的是用脚本中的计时。 &lt;br/&gt;
    例：start=$SECONDS &lt;br/&gt;
        read answer &lt;br/&gt;
        finish=$SECONDS   &lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id="_10"&gt;特殊内置变量续&lt;/h2&gt;
&lt;p&gt;TMOUT   如果设置了该变量，则在没有输入的情况下经过TMOUT变量所指定的秒数后，shell退出。值为0时无效。 &lt;br/&gt;
CDPATH &lt;br/&gt;
允许用户使用简单文件名作为CD的参数，从而快速改变目录。设置方法与PATH类似，通常在启动文件中设置。如果CD的参数是一个绝对路径，则不会查询CDPATH. &lt;br/&gt;
例：CDPATH=:/u1/nr:/u1/progs: &lt;br/&gt;
    export CDPATH &lt;br/&gt;
    cd nr &lt;br/&gt;
    就会进到nr中去。 &lt;br/&gt;
    注意：变量必须大写，定义后必须导出.   &lt;/p&gt;
&lt;h2 id="_11"&gt;数组&lt;/h2&gt;
&lt;p&gt;Kshell支持一维数组，最多支持1024个元素。第一个元素为０。 &lt;br/&gt;
Set –A name value0 value1 … &lt;br/&gt;
声明数组，指定的值就成为name的元素。   &lt;/p&gt;
&lt;p&gt;${name[i]}　i为0至1023的值，可以是表达式。返回数组元素i &lt;br/&gt;
${name}　返回数组元素０ &lt;br/&gt;
${name[&lt;em&gt;]},${name[@]}　返回所有元素 &lt;br/&gt;
下标[&lt;/em&gt;]和[@]都可以提取整个数组的内容。但当它们在引号中使用时其行为是不同的。使用@可生成一个数组，这个数组是原始数组的副本，而使用&lt;em&gt;，则生成的仅仅是具有单一元素的数组(或者是一个普通变量)。 &lt;br/&gt;
    例：set -A a "${names[&lt;/em&gt;]}" &lt;br/&gt;
        set -A b "${names[@]}"  &lt;br/&gt;
        set|head -5 &lt;br/&gt;
        a[0]='alex helen jenny scott' &lt;br/&gt;
        b[0]=alex &lt;br/&gt;
        b[1]=helen &lt;br/&gt;
        b[2]=jenny &lt;br/&gt;
        b[3]=scott &lt;br/&gt;
    ${#name[*]}　返回数组元素个数   &lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id="_12"&gt;运算符&lt;/h2&gt;
&lt;p&gt;Kshell使用C语言中的运算符。 &lt;br/&gt;
% 求余;&amp;lt;&amp;lt; 左移;&amp;gt;&amp;gt; 右移;&amp;lt;= 小于等于;&amp;gt;=　大于等于;&amp;lt; 小于;   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大于;== 相等;!= 不等;&amp;amp;&amp;amp; 逻辑与;||　逻辑或;   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="3"&gt;3.内置命令&lt;/h1&gt;
&lt;h2 id="_13"&gt;条件执行语句。&lt;/h2&gt;
&lt;p&gt;If condition1 &lt;br/&gt;
Then 
    commands1 &lt;br/&gt;
[elif condition2 &lt;br/&gt;
Then 
    commands2] &lt;br/&gt;
… &lt;br/&gt;
[else commands3] &lt;br/&gt;
Fi   &lt;/p&gt;
&lt;h2 id="_14"&gt;循环控制&lt;/h2&gt;
&lt;h3 id="for"&gt;for&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;For&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   
&lt;span class="n"&gt;Do&lt;/span&gt;   
   &lt;span class="n"&gt;Commands&lt;/span&gt;   
&lt;span class="n"&gt;Done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使变量x(在可选的值列表中)执行commands，省略时假定为”$@”位置参数 &lt;br/&gt;
例: &lt;br/&gt;
    For item in &lt;code&gt;cat program_list&lt;/code&gt; &lt;br/&gt;
    Do &lt;br/&gt;
       Grep –c “$item.[co]” chap* &lt;br/&gt;
    Done   &lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id="repeat"&gt;repeat&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;   
&lt;span class="k"&gt;do&lt;/span&gt;   
    &lt;span class="n"&gt;commands&lt;/span&gt;   
&lt;span class="n"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定一个命令序列执行的次数。 &lt;br/&gt;
例： &lt;br/&gt;
    repeat 3 &lt;br/&gt;
    do &lt;br/&gt;
        echo "bye" &lt;br/&gt;
    done   &lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id="select"&gt;select&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Select&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   
&lt;span class="n"&gt;Do&lt;/span&gt;   
   &lt;span class="n"&gt;Commands&lt;/span&gt;   
&lt;span class="n"&gt;Done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="listreturn"&gt;显示一列按list中顺序编号的菜单项。让用户键入行号选择或按return重新显示。&lt;/h2&gt;
&lt;p&gt;例: &lt;br/&gt;
    Ps3=”select thd item number:” &lt;br/&gt;
    Select event in format page view exit &lt;br/&gt;
    Do &lt;br/&gt;
       Case “event” in &lt;br/&gt;
          Format) nroff $file | lp;; &lt;br/&gt;
          Page) pr $file | lp;; &lt;br/&gt;
          View) more $file;; &lt;br/&gt;
          Exit) exit 0;; &lt;br/&gt;
          *)    echo “invalid selection”;; &lt;br/&gt;
       Esac &lt;br/&gt;
    Done   &lt;/p&gt;
&lt;h2 id="case"&gt;控制语句case&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Case&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;   
     &lt;span class="n"&gt;Pattern1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;cmds1&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;   
     &lt;span class="n"&gt;Pattern2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;cmds2&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;   
     &lt;span class="err"&gt;…&lt;/span&gt;   
     &lt;span class="err"&gt;…&lt;/span&gt;   
&lt;span class="n"&gt;Esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似于select case.例:   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Case&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt;   
   &lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;yea&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;   
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;tT&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;   
   &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;unknown&lt;/span&gt; &lt;span class="n"&gt;option&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;;&lt;/span&gt;   
&lt;span class="n"&gt;Esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_15"&gt;函数&lt;/h2&gt;
&lt;p&gt;Function name{commands;}  定义一个函数 &lt;br/&gt;
or &lt;br/&gt;
functionName {commands;}&lt;/p&gt;
&lt;p&gt;必须有commands&lt;/p&gt;
&lt;h2 id="_16"&gt;&lt;/h2&gt;
&lt;p&gt;Eval args  args是一行包含shell变量的代码.eval首先进行变量扩展，并且运行由此产生的命令。在shell变量包括了重定向符号，别名或其他变量时是有用的。 &lt;br/&gt;
例: &lt;br/&gt;
    Eval sort $file $out   &lt;/p&gt;
&lt;p&gt;Export [name=[value]…] &lt;br/&gt;
定义全局变量，让其它shell脚本也可以使用。无参数时输出当前定义的全局变量。   &lt;/p&gt;
&lt;p&gt;Let expressions  执行一个或多个表达式。表达式中的变量前不必有$.如果表达式中包含了空格或其他特殊字符，则必须引起来。 &lt;br/&gt;
例：let “I = I + 1” 或 let i=i+1   &lt;/p&gt;
&lt;p&gt;Read [var1[?string]] [var2 …]  从标准输入读入一行给相应的变量，并把剩余的单词给最后一个变量。String为相应的提示信息.无参时只等待一次输入。   &lt;/p&gt;
&lt;p&gt;Readonly [var1[=value] var2[=value] …]  设置只读变量,无参时显示所有只读变量 &lt;br/&gt;
select the item number:   &lt;/p&gt;
&lt;p&gt;set [options arg1 arg2 …]  无参时输出所有已知变量的值。   &lt;/p&gt;
&lt;p&gt;Shift [n]  交换位置参数（如将$2变为$1）.如果给出n,则向左移动n个位置。通常用于在while循环中迭代命令行参数。N可以是一个整数表达式。   &lt;/p&gt;
&lt;p&gt;Sleep [n]  睡眠n秒钟   &lt;/p&gt;
&lt;h2 id="_17"&gt;条件判断&lt;/h2&gt;
&lt;p&gt;Test condition 或[ condition ]  判断条件，为真返回0,否则返回非0.   &lt;/p&gt;
&lt;h3 id="_18"&gt;文件：&lt;/h3&gt;
&lt;p&gt;-a filename         如果该文件存在而为真 &lt;br/&gt;
-d filename         如果该文件存在且为一个目录，则为真 &lt;br/&gt;
-f filename         如果该文件存在且为一个常规文件，则为真 &lt;br/&gt;
-L filename         如果该文件存在且为一个符号链接，为真 &lt;br/&gt;
-r filename         如果该文件存在且用户对其有读取权限，真 &lt;br/&gt;
-s filename         如果该文件存在且包含信息(大于0字节)，真 &lt;br/&gt;
-w filename         如果该文件存在且对其有写入权，真 &lt;br/&gt;
-x filename         如果该文件存在且对其有执行权，真 &lt;br/&gt;
File1 -nt file2     如果file1存在且在file2后修改则值为真(指修改时间)&lt;br/&gt;
File1 -ot file2     如果file1存在且在file2前修改则值为真(指修改时间)   &lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id="_19"&gt;字符串：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;string          如果string不为空字符串则值为真   &lt;/li&gt;
&lt;li&gt;-n string       如果string字符长度大于0则值为真   &lt;/li&gt;
&lt;li&gt;-z string       如果string字符长度等于0则值为真   &lt;/li&gt;
&lt;li&gt;string1=sting2      如果string1等于string2则值为真   &lt;/li&gt;
&lt;li&gt;string1!=string2        如果string1不等于string2则值为真 &lt;br/&gt;
string2可以是通配符模式。   &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_20"&gt;整数比较：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gt&lt;/span&gt; &lt;span class="err"&gt;大于；&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ge&lt;/span&gt; &lt;span class="err"&gt;大于或等于；&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eq&lt;/span&gt; &lt;span class="err"&gt;等于；&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ne&lt;/span&gt; &lt;span class="err"&gt;不等于&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;le&lt;/span&gt; &lt;span class="err"&gt;小于或等于&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;lt&lt;/span&gt; &lt;span class="err"&gt;小于&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_21"&gt;组合：&lt;/h3&gt;
&lt;p&gt;! condition                         如果condition为假则为真 &lt;br/&gt;
condition1 –a condition2           如果两个条件都为真则为真            &lt;br/&gt;
condition1 –o condition2           如果两个条件有一个为真则为真   &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;trap [[commands] signals]  如果接收到任何的信号signals则执行命令commands.如果完全忽略commands则会重新设置由默认行为处理指定的信号。 &lt;br/&gt;
例： &lt;br/&gt;
Trap “” 2 ;忽略信号2（中断，通常是ctrl+c） &lt;br/&gt;
Trap 2 ;恢复中断2 &lt;br/&gt;
Trap “rm –f $tmp;exit” 0 1 2 15 ;当shell程序退出，用户退出，按ctrl+c或执行kill时删除$tmp.   &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Typeset [options] [var [var]…]设置变量属性 &lt;br/&gt;
- -u 将变量值中所有字母全部转换成大写 &lt;br/&gt;
- -l 将变量值中所有字母全部转换成小写 &lt;br/&gt;
- -i 将变量值设为整数类型.-ix x为相应的进制，表示时为x#变量值，可用于进制转换。 &lt;br/&gt;
     例：typeset -i2 vv  vv=2    echo $vv    2#10 &lt;br/&gt;
     typeset -i 相当于integer &lt;br/&gt;
- -L width 在width宽度之内左对齐 &lt;br/&gt;
- -R width 在width宽度之内右对齐，前面空位用空格填充 &lt;br/&gt;
- -Z width 在width宽度之内右对齐，变量如果是数字，则前面空位用零填充 &lt;br/&gt;
     如果忽略width,将使用赋给这个变量的第一个值的宽度。 &lt;br/&gt;
- -x 设置一个变量全局。typeset -x 相当于 export &lt;br/&gt;
- -r 设置一个变量具有只读属性，在设置的同时或之前，要先给这些变量赋值。 &lt;br/&gt;
    例：typeset -r  PATH FPATH=/usr/local/funcs &lt;br/&gt;
    typeset -r 相当于 readonly   &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;不带参数的typeset可以列出变量和变量的属性。查看指定的变量属性可用type|grep day &lt;br/&gt;
使用带有某一选项的typeset来看看哪一个变量具有特定的属性：typeset -z   &lt;/p&gt;
&lt;p&gt;Unset var  删除一个变量，将它置为空   &lt;/p&gt;
&lt;hr/&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Until&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;   
&lt;span class="n"&gt;Do&lt;/span&gt;   
   &lt;span class="n"&gt;Commands&lt;/span&gt;   
&lt;span class="n"&gt;Done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行命令command直到满足条件condition.   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;While&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt;   
&lt;span class="n"&gt;Do&lt;/span&gt;   
   &lt;span class="n"&gt;Commands&lt;/span&gt;   
&lt;span class="n"&gt;Done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果满足条件condition则执行commands   &lt;/p&gt;</summary><category term="shell"></category></entry><entry><title>Ksh自动补全</title><link href="/ksh_auto_complete.html" rel="alternate"></link><updated>2014-06-25T17:04:31+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-06-25:ksh_auto_complete.html</id><summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1&gt;KSH的自动补全&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方法一：
    set -o vi
历史命令功能（esc -，esc +）自动补全文件名（esc \）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法二：
    set -o emacs&lt;br /&gt;
历史命令功能（ctrl-n，ctrl-p），自动补全文件名(按两次esc)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;找不到自动补全命令的功能，还是bash比较人性化。&lt;/p&gt;</summary></entry><entry><title>awk与sed</title><link href="/awkyu-sed.html" rel="alternate"></link><updated>2014-06-25T00:00:00+08:00</updated><author><name>杨秀隆</name></author><id>tag:,2014-06-25:awkyu-sed.html</id><summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2&gt;插入&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;sdfasdf&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1i&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;$var&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;替换&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;def&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dsfds&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gdkok&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>shell 替换与插入</title><link href="/shell-ti-huan-yu-cha-ru.html" rel="alternate"></link><updated>2014-06-25T00:00:00+08:00</updated><author><name>杨秀隆</name></author><id>tag:,2014-06-25:shell-ti-huan-yu-cha-ru.html</id><summary type="html">&lt;h1&gt;sed 使用技巧&lt;/h1&gt;
&lt;h2&gt;替换&lt;/h2&gt;
&lt;h2&gt;插入&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;sdfasdf&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1i&lt;/span&gt;&lt;span class="se"&gt;\\&lt;/span&gt;&lt;span class="s"&gt;$var&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>shell_功能</title><link href="/shell_gong-neng.html" rel="alternate"></link><updated>2014-06-23T11:25:48+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-06-23:shell_gong-neng.html</id><summary type="html">&lt;p&gt;% shell 特殊功能
% 杨秀隆&lt;br /&gt;
% 20140605&lt;/p&gt;
&lt;h1&gt;有用功能&lt;/h1&gt;
&lt;h2&gt;编码判断加转换&lt;/h2&gt;
&lt;p&gt;enca 或 iconv&lt;/p&gt;
&lt;h3&gt;一、利用iconv命令进行文件内容编码转换&lt;/h3&gt;
&lt;p&gt;下载地址 &lt;a href="http://99.6.145.70:8090/res/iconv.exe"&gt;iconv&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用法：iconv [选项...] [文件...]&lt;/p&gt;
&lt;p&gt;有如下选项可用:&lt;/p&gt;
&lt;p&gt;输入/输出格式规范：&lt;/p&gt;
&lt;p&gt;-f, --from-code=名称 原始文本编码&lt;/p&gt;
&lt;p&gt;-t, --to-code=名称 输出编码&lt;/p&gt;
&lt;h3&gt;二、enca&lt;/h3&gt;
&lt;p&gt;下载地址 &lt;a href="http://99.6.145.70:8090/res/enca.exe"&gt;enca&lt;/a&gt; 和 &lt;a href="http://99.6.145.70:8090/res/enconv.exe"&gt;enconv&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;enca用法如下：&lt;/p&gt;
&lt;p&gt;enca -L zh_CN file 检查文件的编码&lt;/p&gt;
&lt;p&gt;enca -L zh_CN -x UTF-8 file 将文件编码转换为"UTF-8"编码&lt;/p&gt;
&lt;p&gt;enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样&lt;/p&gt;
&lt;p&gt;除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。&lt;/p&gt;
&lt;p&gt;转换单个文件的编码
enca -L none -x utf-8  index.html&lt;/p&gt;
&lt;h2&gt;参数太长&lt;/h2&gt;
&lt;p&gt;如 rm -f * 删除当前路径下所有文件时，可能文件太多，报错Argument list too long&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ls&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xargs&lt;/span&gt; &lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写个循环也行，但是肯定没有上面一句就搞定简单。&lt;/p&gt;
&lt;h2&gt;判断操作系统 uname&lt;/h2&gt;
&lt;h2&gt;命令行参数处理模块&lt;/h2&gt;
&lt;p&gt;Shell中提供了一条获取和处理命令行选项的语句，即getopts语句。该语句的格式为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;getopts&lt;/span&gt; &lt;span class="n"&gt;option_string&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;option_string中包含一个有效的单字符选项。若getopts命令在命令行中发现了连字符，那么它将用连字符后面的字符同 option_string相比较。若有匹配，则把变量variable的值设为该选项。若无匹配，则variable设为?。当getopts发现连字符后面没有字符，会返回一个非零的状态值。Shell程序中可以利用getopts的返回值建立一个循环。&lt;/p&gt;
&lt;p&gt;有时侯选项中还带一个值，getopts命令同样也支持这一功能。这时需要在option_string中选项字母后加一个冒号。当 getopts命令发现冒号后，会从命令行该选项后读取该值。若该值存在，那么将被存在一个特殊的变量OPTARG中。如果该值不存在，getopts命令将在OPTARG中存放一个问号，并且在标准错误输出上显示一条消息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;optstring&lt;br /&gt;
  option字符串，会逐个匹配  &lt;/li&gt;
&lt;li&gt;varname
  每次匹配成功的选项  &lt;/li&gt;
&lt;li&gt;arg&lt;br /&gt;
  参数列表，没写时它会取命令行参数列表  &lt;/li&gt;
&lt;li&gt;$OPTIND&lt;br /&gt;
  特殊变量，option index，会逐个递增, 初始值为1  &lt;/li&gt;
&lt;li&gt;$OPTARG&lt;br /&gt;
  特殊变量，option argument，不同情况下有不同的值  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;细则1：&lt;br /&gt;
当optstring以”:“开头时,getopts会区分invalid option错误和miss option argument。 invalid option错误时,varname会被设成?,$OPTARG是出问题的option；miss option argument时,varname会被设成:(在我的fedora系统里测试OPTARG为?),$OPTARG是出问题的option.&lt;/p&gt;
&lt;p&gt;当optstring不以”:“开头,invalid option错误和miss option argument错误都会使varname被设成?, $OPTARG是出问题的option(在我的fedora系统里测试OPTARG为空).&lt;/p&gt;
&lt;p&gt;细则2：&lt;br /&gt;
当optstring中的字母跟”:“时,表明该option可接参数,参数(argument)放在$OPTARG中,如果缺参数,且optstring是以”:“开头,则varname的值会是:(在我的fedora系统里测试OPTARG为?),$OPTARG是该option, 否则varname的值是?,$OPTARG是该option.(参照细则1)(在我的fedora系统里测试OPTARG为空)&lt;/p&gt;</summary></entry><entry><title>ksh_语法</title><link href="/ksh_yu-fa.html" rel="alternate"></link><updated>2014-06-20T14:18:56+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-06-20:ksh_yu-fa.html</id><summary type="html">&lt;p&gt;% shell 语法&lt;br /&gt;
% 杨秀隆&lt;br /&gt;
% 2014-06-11&lt;/p&gt;
&lt;h1&gt;数学运算&lt;/h1&gt;
&lt;p&gt;使用的是 (( 运算式 )) &lt;/p&gt;
&lt;p&gt;示例 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;((&lt;/span&gt; &lt;span class="n"&gt;bch_id&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="err"&gt;不支持&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; 
&lt;span class="p"&gt;((&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pre&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="err"&gt;不能用&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;pre&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或是 let var=运算式&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;new_rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;old_rank&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进制情况 value too great for base :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;let&lt;/span&gt; &lt;span class="n"&gt;new_rank&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;#$&lt;/span&gt;&lt;span class="n"&gt;old_rank&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="err"&gt;十进制&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;分支条件&lt;/h1&gt;
&lt;p&gt;shell 或者说 ksh 的else if 使用 elif 写法， 简洁易用的写法&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3456&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3456&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;elif&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4567&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4567&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;elif&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1234&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1234&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;/h1&gt;</summary></entry><entry><title>shell_技巧</title><link href="/shell_ji-qiao.html" rel="alternate"></link><updated>2014-06-09T10:18:02+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-06-09:shell_ji-qiao.html</id><summary type="html">&lt;p&gt;% 编写健壮的 shell 脚本&lt;br /&gt;
% 杨秀隆&lt;br /&gt;
% 20140605&lt;/p&gt;
&lt;h1&gt;有效技巧&lt;/h1&gt;
&lt;h2&gt;防止变量未赋值&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;nounset&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用这个选项可以使脚本在使用未初始化的变量时直接退出&lt;/p&gt;
&lt;h2&gt;shell 字符串变量中的空格&lt;/h2&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; dokjd    &amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保留全部空格： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$x&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去除头尾空格:      &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;shell string总结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;空串判断  if [ -z "$line" ]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在awk使用时，全部是数字的外部string变量需要前后加双引号，不然会当作数值，打印时会出bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for循环遍历文件时，使用 for line in &lt;code&gt;cat $filename&lt;/code&gt;
    缺点: 当行内有空格时，一行会被划分成两行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上一条的替代方法 while read line do done &amp;lt; filename
    缺点：过程中需要 命令行交互时， 无法输入命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;shell 字符串格式化&lt;/h2&gt;
&lt;p&gt;和C相似   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%-12s&amp;quot;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$x&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;awk 和 c 的几乎一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;awk&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;printf&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%s-%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;二次赋值&lt;/h2&gt;
&lt;h3&gt;数组中二次赋值&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;i=1;
x[1]=2;
echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;eval 变量二次赋值&lt;/h3&gt;
&lt;p&gt;见证奇迹的时刻:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;first_item&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;PROJECT_NAME&amp;quot;&lt;/span&gt;  
&lt;span class="n"&gt;eval&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;first_item&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;LB03&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PROJECT_NAME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;LB03&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;引申到数组的利用上&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;set -A array_name &amp;quot;PROJECT_NAME&amp;quot; &amp;quot;BRANCH&amp;quot;
set -A array_value &amp;quot;LB03&amp;quot; &amp;quot;DEV&amp;quot;
eval &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;array_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;array_value&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
echo &amp;quot;BRANCH =&amp;quot; &lt;span class="nv"&gt;$BRANCH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果应该是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BRANCH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DEV&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参数太长&lt;/h2&gt;
&lt;p&gt;如 rm -f * 删除当前路径下所有文件时，可能文件太多，报错Argument list too long&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ls&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xargs&lt;/span&gt; &lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;写个循环也行，但是肯定没有上面一句就搞定简单。&lt;/p&gt;
&lt;h2&gt;判断操作系统 uname&lt;/h2&gt;</summary></entry><entry><title>find_grep</title><link href="/find_grep.html" rel="alternate"></link><updated>2014-06-06T14:53:22+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-06-06:find_grep.html</id><summary type="html">&lt;p&gt;% find与grep&lt;br /&gt;
% 杨秀隆&lt;br /&gt;
% 20140606&lt;/p&gt;
&lt;h1&gt;find 手册&lt;/h1&gt;
&lt;h1&gt;grep 手册&lt;/h1&gt;
&lt;h2&gt;grep使用shell环境变量&lt;/h2&gt;
&lt;p&gt;grep -p "$var" 即可
只要在var里把形式定义好&lt;/p&gt;
&lt;h2&gt;整词匹配 -w&lt;/h2&gt;
&lt;h1&gt;find 加 grep 递归查找文件中字符串&lt;/h1&gt;
&lt;p&gt;命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;GateWay.cfg&amp;quot;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;xargs&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;^9520&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;递归查找 名为GateWay.cfg文件下  含有的 9520打头的字符   并将错误信息重定向到/dev/null下&lt;/p&gt;
&lt;p&gt;格式说明:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;find 部分&lt;br /&gt;
find 主要使用格式如下:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;file_name_pattern&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;说明：&lt;br /&gt;
file_name_pattern中，支持shell 通配符 *&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grep 部分&lt;br /&gt;
grep 主要使用格式如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="n"&gt;filelist&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用参数 : &lt;br /&gt;
-E  正则表达式
3. 管道 部分
find 后 | xargs 表示 将find到的文件内容作为参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;</summary></entry><entry><title>ksh_数组</title><link href="/ksh_shu-zu.html" rel="alternate"></link><updated>2014-06-06T14:26:36+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-06-06:ksh_shu-zu.html</id><summary type="html">&lt;p&gt;% ksh数组的使用方法&lt;/p&gt;
&lt;h1&gt;一、 定义&lt;/h1&gt;
&lt;h2&gt;定义与初始化数组变量：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;value1&lt;/span&gt; &lt;span class="n"&gt;value2&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;valuen&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;对应bash定义形式&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;arr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element1&lt;/span&gt; &lt;span class="n"&gt;element2&lt;/span&gt; &lt;span class="n"&gt;element3&lt;/span&gt;&lt;span class="p"&gt;......&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;给数组赋值也可以定义数组：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下标是从0开始&lt;/p&gt;
&lt;h1&gt;二、 使用&lt;/h1&gt;
&lt;h2&gt;访问数组变量：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;一次访问数组变量中的所有元素：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>shell_时间</title><link href="/shell_shi-jian.html" rel="alternate"></link><updated>2014-06-06T09:44:02+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-06-06:shell_shi-jian.html</id><summary type="html">&lt;p&gt;% shell中时间相关说明&lt;br /&gt;
% 杨秀隆&lt;br /&gt;
% 20140606 &lt;/p&gt;
&lt;h2&gt;date命令的使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不带任何参数的使用，结果:
    Tue Jan  7 07:25:17 CST 2014&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间显示格式  date +%Y%m%D%H%M%S, 即加号后%字母%字母2......&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用格式参数 
    %Y   year
    %m   month
    %d   当月几号
    %D   等价于  %m/%d/%y
    %H   24小时制
    %h   月份的英文缩写
    %M   分钟
    %S   秒
    %s   January 1, 1970至今多少秒，UNIGW系统的标准方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;sleep&lt;/h2&gt;
&lt;p&gt;sleep只支持整数，即秒为单位&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sleep&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;秒&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要毫秒级的sleep时，需要使用外部工具，如perl，C&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;perl&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt; &lt;span class="err"&gt;毫秒&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>grep技巧</title><link href="/grepji-qiao.html" rel="alternate"></link><updated>2014-05-23T09:59:36+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-23:grepji-qiao.html</id><summary type="html">&lt;p&gt;% 编写健壮的 shell 脚本
% 杨秀隆&lt;br /&gt;
% &lt;/p&gt;
&lt;h2&gt;grep使用shell环境变量&lt;/h2&gt;
&lt;p&gt;grep -p "$var" 即可
只要在var里把形式定义好&lt;/p&gt;
&lt;h2&gt;整词匹配 -w&lt;/h2&gt;</summary></entry><entry><title>参数处理</title><link href="/can-shu-chu-li.html" rel="alternate"></link><updated>2014-05-15T15:04:56+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-15:can-shu-chu-li.html</id><summary type="html">&lt;h1&gt;参数处理-Shell传入参数的处理&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;$# 传递到脚本的参数个数  &lt;/li&gt;
&lt;li&gt;$﹡ 以一个单字符串显示所有向脚本传递的参数。与位置变量不同，此选项参数可超过9个  &lt;/li&gt;
&lt;li&gt;$$ 脚本运行的当前进程ID号  &lt;/li&gt;
&lt;li&gt;$! 后台运行的最后一个进程的进程ID号  &lt;/li&gt;
&lt;li&gt;$@ 与$#相同，但是使用时加引号，并在引号中返回每个参数  &lt;/li&gt;
&lt;li&gt;$- 显示shell使用的当前选项，与set命令功能相同  &lt;/li&gt;
&lt;li&gt;$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;变量 含义&lt;/h2&gt;
&lt;p&gt;$0 脚本名字 &lt;br /&gt;
$1 位置参数 #1 &lt;br /&gt;
$2 - $9 位置参数 #2 - #9 &lt;br /&gt;
${10} 位置参数 #10 &lt;br /&gt;
$# 位置参数的个数 &lt;br /&gt;
"$﹡" 所有的位置参数(作为单个字符串) * &lt;br /&gt;
"$@" 所有的位置参数(每个都作为独立的字符串) &lt;br /&gt;
${#﹡} 传递到脚本中的命令行参数的个数 &lt;br /&gt;
${#@} 传递到脚本中的命令行参数的个数 &lt;br /&gt;
$? 返回值 &lt;br /&gt;
$$ 脚本的进程ID(PID) &lt;br /&gt;
$- 传递到脚本中的标志(使用set) &lt;br /&gt;
$_ 之前命令的最后一个参数 &lt;br /&gt;
$! 运行在后台的最后一个作业的进程ID(PID)   &lt;/p&gt;
&lt;h2&gt;特殊处理语句或命令&lt;/h2&gt;
&lt;p&gt;shift 语句， 命令行参数左移排除。&lt;/p&gt;</summary></entry><entry><title>tar_压缩</title><link href="/tar_ya-suo.html" rel="alternate"></link><updated>2014-05-13T15:40:08+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-13:tar_ya-suo.html</id><summary type="html">&lt;p&gt;﻿% tar 命令说明&lt;br /&gt;
% 杨秀隆&lt;br /&gt;
% 2014年5月13日 修订&lt;/p&gt;
&lt;h1&gt;tar 命令&lt;/h1&gt;
&lt;h2&gt;基本参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;-c: 建立压缩档案&lt;/li&gt;
&lt;li&gt;-x：解压&lt;/li&gt;
&lt;li&gt;-t：查看内容&lt;/li&gt;
&lt;li&gt;-r：向压缩归档文件末尾追加文件&lt;/li&gt;
&lt;li&gt;-u：更新原压缩包中的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。&lt;/p&gt;
&lt;p&gt;-z：有gzip属性的
-j：有bz2属性的
-Z：有compress属性的
-v：显示所有过程
-O：将文件解开到标准输出&lt;/p&gt;
&lt;p&gt;下面的参数-f是必须的&lt;/p&gt;
&lt;p&gt;-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。&lt;/p&gt;
&lt;h1&gt;tar -cf all.tar *.jpg&lt;/h1&gt;
&lt;p&gt;这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。 &lt;/p&gt;
&lt;h1&gt;tar -rf all.tar *.gif&lt;/h1&gt;
&lt;p&gt;这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。 &lt;/p&gt;
&lt;h1&gt;tar -uf all.tar logo.gif&lt;/h1&gt;
&lt;p&gt;这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。 &lt;/p&gt;
&lt;h1&gt;tar -tf all.tar&lt;/h1&gt;
&lt;p&gt;这条命令是列出all.tar包中所有文件，-t是列出文件的意思 &lt;/p&gt;
&lt;h1&gt;tar -xf all.tar&lt;/h1&gt;
&lt;p&gt;这条命令是解出all.tar包中所有文件，-x是解开的意思 &lt;/p&gt;
&lt;p&gt;压缩&lt;/p&gt;
&lt;p&gt;tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg&lt;/p&gt;
&lt;p&gt;tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz&lt;/p&gt;
&lt;p&gt;tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2&lt;/p&gt;
&lt;p&gt;tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z&lt;/p&gt;
&lt;p&gt;rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux&lt;/p&gt;
&lt;p&gt;zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux&lt;/p&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;p&gt;tar –xvf file.tar //解压 tar包&lt;/p&gt;
&lt;p&gt;tar -xzvf file.tar.gz //解压tar.gz&lt;/p&gt;
&lt;p&gt;tar -xjvf file.tar.bz2   //解压 tar.bz2&lt;/p&gt;
&lt;p&gt;tar –xZvf file.tar.Z   //解压tar.Z&lt;/p&gt;
&lt;p&gt;unrar e file.rar //解压rar&lt;/p&gt;
&lt;p&gt;unzip file.zip //解压zip&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;1、*.tar 用 tar –xvf 解压&lt;/p&gt;
&lt;p&gt;2、*.gz 用 gzip -d或者gunzip 解压&lt;/p&gt;
&lt;p&gt;3、&lt;em&gt;.tar.gz和&lt;/em&gt;.tgz 用 tar –xzf 解压&lt;/p&gt;
&lt;p&gt;4、*.bz2 用 bzip2 -d或者用bunzip2 解压&lt;/p&gt;
&lt;p&gt;5、*.tar.bz2用tar –xjf 解压&lt;/p&gt;
&lt;p&gt;6、*.Z 用 uncompress 解压&lt;/p&gt;
&lt;p&gt;7、*.tar.Z 用tar –xZf 解压&lt;/p&gt;
&lt;p&gt;8、*.rar 用 unrar e解压&lt;/p&gt;
&lt;p&gt;9、*.zip 用 unzip 解压&lt;/p&gt;</summary></entry><entry><title>ksh_judge</title><link href="/ksh_judge.html" rel="alternate"></link><updated>2014-05-13T13:16:46+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-13:ksh_judge.html</id><summary type="html">&lt;h1&gt;ksh 判断&lt;/h1&gt;
&lt;h2&gt;一. 基础比较&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;运算符号代表意义&lt;/li&gt;
&lt;li&gt;=   等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串    &lt;/li&gt;
&lt;li&gt;!=  不等于 应用于：整型或字符串比较 如果在[] 中，只能是字符串  &lt;/li&gt;
&lt;li&gt;&amp;lt;    小于 应用于：整型比较 在[] 中，不能使用 表示字符串   &lt;/li&gt;
&lt;li&gt;&amp;gt;   大于应用于：整型比较 在[] 中，不能使用 表示字符串  &lt;/li&gt;
&lt;li&gt;-eq 等于 应用于：整型比较  &lt;/li&gt;
&lt;li&gt;-ne 不等于 应用于：整型比较  &lt;/li&gt;
&lt;li&gt;-lt 小于 应用于：整型比较  &lt;/li&gt;
&lt;li&gt;-gt 大于 应用于：整型比较  &lt;/li&gt;
&lt;li&gt;-le 小于或等于 应用于：整型比较  &lt;/li&gt;
&lt;li&gt;-ge 大于或等于 应用于：整型比较  &lt;/li&gt;
&lt;li&gt;-a  双方都成立（and） 逻辑表达式 –a 逻辑表达式  &lt;/li&gt;
&lt;li&gt;-o  单方成立（or） 逻辑表达式 –o 逻辑表达式  &lt;/li&gt;
&lt;li&gt;-z  空字符串  &lt;/li&gt;
&lt;li&gt;-n  非空字符串  &lt;/li&gt;
&lt;li&gt;逻辑的『和(and)』『或(or)』  &lt;/li&gt;
&lt;li&gt;&amp;amp;&amp;amp;  逻辑的 AND 的意思  &lt;/li&gt;
&lt;li&gt;||  逻辑的 OR 的意思  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;二. 特殊比较&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;关于档案与目录的侦测逻辑卷标！  &lt;/li&gt;
&lt;li&gt;-f  常用！侦测『档案』是否存在 eg: if [ -f filename ]  &lt;/li&gt;
&lt;li&gt;-d  常用！侦测『目录』是否存在  &lt;/li&gt;
&lt;li&gt;-b  侦测是否为一个『 block 档案』  &lt;/li&gt;
&lt;li&gt;-c  侦测是否为一个『 character 档案』  &lt;/li&gt;
&lt;li&gt;-S  侦测是否为一个『 socket 标签档案』  &lt;/li&gt;
&lt;li&gt;-L  侦测是否为一个『 symbolic link 的档案』  &lt;/li&gt;
&lt;li&gt;-e  侦测『某个东西』是否存在！  &lt;/li&gt;
&lt;li&gt;关于程序的逻辑卷标！  &lt;/li&gt;
&lt;li&gt;-G  侦测是否由 GID 所执行的程序所拥有  &lt;/li&gt;
&lt;li&gt;-O  侦测是否由 UID 所执行的程序所拥有  &lt;/li&gt;
&lt;li&gt;-p  侦测是否为程序间传送信息的 name pipe 或是 FIFO （老实说，这个不太懂！）  &lt;/li&gt;
&lt;li&gt;关于档案的属性侦测！  &lt;/li&gt;
&lt;li&gt;-r  侦测是否为可读的属性  &lt;/li&gt;
&lt;li&gt;-w  侦测是否为可以写入的属性  &lt;/li&gt;
&lt;li&gt;-x  侦测是否为可执行的属性  &lt;/li&gt;
&lt;li&gt;-s  侦测是否为『非空白档案』  &lt;/li&gt;
&lt;li&gt;-u  侦测是否具有『 SUID 』的属性  &lt;/li&gt;
&lt;li&gt;-g  侦测是否具有『 SGID 』的属性  &lt;/li&gt;
&lt;li&gt;-k  侦测是否具有『 sticky bit 』的属性  &lt;/li&gt;
&lt;li&gt;两个档案之间的判断与比较；例如[ test file1 -nt file2 ]    &lt;/li&gt;
&lt;li&gt;-nt 第一个档案比第二个档案新  &lt;/li&gt;
&lt;li&gt;-ot 第一个档案比第二个档案旧  &lt;/li&gt;
&lt;li&gt;-ef 第一个档案与第二个档案为同一个档案（ link 之类的档案）  &lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>端口监听</title><link href="/duan-kou-jian-ting.html" rel="alternate"></link><updated>2014-05-04T09:24:04+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-04:duan-kou-jian-ting.html</id><summary type="html">&lt;h1&gt;windows、linux、aix 查询端口号占用情况&lt;/h1&gt;
&lt;p&gt;一、windows&lt;/p&gt;
&lt;p&gt;方法一&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提升权限后&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;netstat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;方法二&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询端口占用的进程ID&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;netstat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;  &lt;span class="err"&gt;各个端口占用&lt;/span&gt;
  &lt;span class="n"&gt;netstat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ano&lt;/span&gt;   &lt;span class="err"&gt;各个端口占用和进程&lt;/span&gt;&lt;span class="n"&gt;PID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例： 
      netstat -aon | findstr "80"&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;TCP&lt;/span&gt;    &lt;span class="mf"&gt;127.0.0.1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;9080&lt;/span&gt;         &lt;span class="mf"&gt;0.0.0.0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;              &lt;span class="n"&gt;LISTENING&lt;/span&gt;       &lt;span class="mi"&gt;4632&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看端口号所对应的应用程序&lt;/p&gt;
&lt;p&gt;tasklist | findstr "  4632" &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终止进程 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;taskkill&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="mi"&gt;4632&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; 
&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;taskkill&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;im&lt;/span&gt; &lt;span class="n"&gt;GROOVE&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再次查询是否成功终止&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tasklist&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;findstr&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4632&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;emsp; 如果成功终止此次执行命令后应返回空.，则表示成功，终止 PID 为 4632 的进程。 &lt;/p&gt;
&lt;p&gt;二、Linux&lt;/p&gt;
&lt;p&gt;方法一:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.查询端口号占用，根据端口查看进程信息 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;server2&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;lsof&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;2.根据进程号查看进程对应的可执行程序  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ps&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="err"&gt;进程号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法二:  &lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据端口号得到其占用的进程的详细信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="n"&gt;netstat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tlnp&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据端口号查询，查询其占用进程ID&lt;/p&gt;
&lt;p&gt;netstat -tlnp|grep 80|awk '{print $7}'|awk -F '/' '{print $1}'&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;或是用下面的命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;   &lt;span class="n"&gt;netstat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pan&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/blockquote&gt;
&lt;p&gt;三、AIX&lt;/p&gt;
&lt;p&gt;命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;netstat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Aan&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;获得25号端口的PCB(protocol control block),&lt;br /&gt;
且查看协议为tcp. (输出信息中第一列即是PCB)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;netstat -Aan |grep 25&lt;br /&gt;
 f100070000d373b0 tcp4 0 0 &lt;em&gt;.25 &lt;/em&gt;.&lt;em&gt; LISTEN &lt;br /&gt;
 f100070000d25600 udp 0 0 &lt;/em&gt;.&lt;em&gt; &lt;/em&gt;.&lt;em&gt;&lt;br /&gt;
 f100070000d25400 udp 0 0 &lt;/em&gt;.&lt;em&gt; &lt;/em&gt;.&lt;em&gt;&lt;br /&gt;
 f100070000d25000 udp 0 0 &lt;/em&gt;.&lt;em&gt; &lt;/em&gt;.&lt;em&gt;&lt;br /&gt;
 f100070000d25c00 udp 0 0 127.255.255.255.12 &lt;/em&gt;.&lt;em&gt;&lt;br /&gt;
 f100070000d2d200 udp 0 0 10.10.10.255.123 &lt;/em&gt;.&lt;em&gt;&lt;br /&gt;
 f100070000d25a00 udp4 0 0 &lt;/em&gt;.514 &lt;em&gt;.&lt;/em&gt;&lt;br /&gt;
 f100070000d25200 udp4 0 0 &lt;em&gt;.517 &lt;/em&gt;.*   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是tcp连接,那么# rmsock &lt;PCB&gt; tcpcb&lt;br /&gt;
 如果是udp连接,那么# rmsock &lt;PCB&gt; inpcb &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;     &lt;span class="n"&gt;rmsock&lt;/span&gt; &lt;span class="n"&gt;f100070000d373b0&lt;/span&gt; &lt;span class="n"&gt;tcpcb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;The socket 0xd37008 is being held by proccess 213096 (sendmail).    &lt;/p&gt;
&lt;p&gt;结果显示25号端口正在被sendmail进程使用，PID为213096. &lt;/p&gt;
&lt;/blockquote&gt;</summary></entry><entry><title>KSH自动补全</title><link href="/kshzi-dong-bu-quan.html" rel="alternate"></link><updated>2014-05-04T09:24:04+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-04:kshzi-dong-bu-quan.html</id><summary type="html">&lt;h1&gt;设置KSH的自动补全和历史命令功能&lt;/h1&gt;
&lt;h2&gt;- 方法一：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;vi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;历史命令功能（esc -，esc +）自动补全文件名（esc \）。&lt;/p&gt;
&lt;h2&gt;- 方法二：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;emacs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;历史命令功能（ctrl-n，ctrl-p），自动补全文件名(按两次esc)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;找不到自动补全命令的功能，还是bash比较人性化。&lt;/p&gt;</summary></entry><entry><title>profile设置</title><link href="/profileshe-zhi.html" rel="alternate"></link><updated>2014-05-04T09:24:04+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-04:profileshe-zhi.html</id><summary type="html">&lt;h1&gt;ksh profile常用配置&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;stty erase ^H &lt;br /&gt;
按Backspace键可以向后删除字符，&lt;br /&gt;
输入stty erase ctrl+v ctrl+h  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set -o vi &lt;br /&gt;
 让输入行工作于vi模式,则可以使用vi专用指令了&lt;br /&gt;
 可以使用 set -o emacs， 则是使用emacs指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TERM=vt100 &lt;br /&gt;
 这样在异地登录的用户方可使用vi&lt;br /&gt;
 各人各用， 这条不要用，除非我不用的环境……  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PS1=&lt;code&gt;/usr/ucb/whoami&lt;/code&gt;"@"&lt;code&gt;hostname&lt;/code&gt;:${ORACLE_SID}"$";export PS1 &lt;br /&gt;
 包含登陆用户、主机名、数据库SID的提示符  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EDITOR=vi;export EDITOR &lt;br /&gt;
 不设置则无法crontab -e  crontab&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HISTSIZE=200;export HISTSIZE &lt;br /&gt;
 保存的历史命令数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LANG=zh_CN.GBK;export LANG; &lt;br /&gt;
 让系统显示中文信息, 已有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stty -istrip cs8 &lt;br /&gt;
 将所有的输入截取成8bits的资料，因为中文的资料都是8bits的&lt;br /&gt;
 未使用过&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LC_CTYPE=zh_CN.GBK;export LC_CTYPE&lt;br /&gt;
 让系统可以使用中文
 未使用过&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;alias history='fc -l' &lt;br /&gt;
 显示历史命令&lt;br /&gt;
 可能还是原命令短一点，但是history好记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;alias r='fc -e -' 重复执行最后一条命令,  &lt;strong&gt;慎用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>shell_file</title><link href="/shell_file.html" rel="alternate"></link><updated>2014-05-04T09:24:04+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-04:shell_file.html</id><summary type="html">&lt;h1&gt;shell文件&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;文件存在 if [[ -e $filename ]]&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>shell变量空格</title><link href="/shellbian-liang-kong-ge.html" rel="alternate"></link><updated>2014-05-04T09:24:04+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-04:shellbian-liang-kong-ge.html</id><summary type="html">&lt;h1&gt;shell 字符串变量中的空格&lt;/h1&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; dokjd    &amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保留全部空格： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$x&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去除头尾空格:      &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>if_else_elif</title><link href="/if_else_elif.html" rel="alternate"></link><updated>2014-05-04T09:20:24+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-05-04:if_else_elif.html</id><summary type="html">&lt;p&gt;﻿&lt;/p&gt;
&lt;h1&gt;if else elif&lt;/h1&gt;
&lt;p&gt;shell 或者说 ksh 的else if 使用 elif 写法， 简洁易用的写法&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3456&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3456&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;elif&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4567&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;4567&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;elif&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1234&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1234&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;none&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>shell_string</title><link href="/shell_string.html" rel="alternate"></link><updated>2014-01-22T16:41:32+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-01-22:shell_string.html</id><summary type="html">&lt;h1&gt;shell string总结&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;空串判断  if [ -z "$line" ]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在awk使用时，全部是数字的外部string变量需要前后加双引号，不然会当作数值，打印时会出bug&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for循环遍历文件时，使用 for line in &lt;code&gt;cat $filename&lt;/code&gt;
    缺点: 当行内有空格时，一行会被划分成两行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上一条的替代方法 while read line do done &amp;lt; filename
    缺点：过程中需要 命令行交互时， 无法输入命令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>ksh_数学运算</title><link href="/ksh_shu-xue-yun-suan.html" rel="alternate"></link><updated>2014-01-07T10:56:26+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-01-07:ksh_shu-xue-yun-suan.html</id><summary type="html">&lt;h1&gt;ksh 里的数学运算&lt;/h1&gt;
&lt;p&gt;ksh 里的数学运算不同于 bash，且资料不多，难以查询&lt;/p&gt;
&lt;p&gt;实际使用的是 (( 运算式 )) 
示例 :
    (( bch_id += 1 )) 不支持 ++ 
    (( next = pre + 1 )) 不能用 next=((pre+1))&lt;/p&gt;</summary></entry><entry><title>date</title><link href="/date.html" rel="alternate"></link><updated>2014-01-07T09:34:36+08:00</updated><author><name>sndnyang</name></author><id>tag:,2014-01-07:date.html</id><summary type="html">&lt;h1&gt;date命令的使用&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不带任何参数的使用，结果:
    Tue Jan  7 07:25:17 CST 2014&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间显示格式  date +%Y%m%D%H%M%S, 即加号后%字母%字母2......&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常用格式参数 
    %Y   year
    %m   month
    %d   当月几号
    %D   等价于  %m/%d/%y
    %H   24小时制
    %h   月份的英文缩写
    %M   分钟
    %S   秒
    %s   January 1, 1970至今多少秒，UNIGW系统的标准方式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary></entry></feed>